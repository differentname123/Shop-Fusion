{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\nvar util = require('@antv/util');\nvar glMatrix = require('gl-matrix');\n\n/**\n * support 2 modes in rendering:\n * * immediate\n * * delayed: render at the end of frame with dirty-rectangle\n */\nvar CanvasRendererPlugin = /** @class */ (function () {\n    function CanvasRendererPlugin(canvasRendererPluginOptions) {\n        this.canvasRendererPluginOptions = canvasRendererPluginOptions;\n        this.removedRBushNodeAABBs = [];\n        this.renderQueue = [];\n        /**\n         * This stack is only used by clipPath for now.\n         */\n        this.restoreStack = [];\n        this.clearFullScreen = false;\n        /**\n         * view projection matrix\n         */\n        this.vpMatrix = glMatrix.mat4.create();\n        this.dprMatrix = glMatrix.mat4.create();\n        this.tmpMat4 = glMatrix.mat4.create();\n        this.vec3a = glMatrix.vec3.create();\n        this.vec3b = glMatrix.vec3.create();\n        this.vec3c = glMatrix.vec3.create();\n        this.vec3d = glMatrix.vec3.create();\n    }\n    CanvasRendererPlugin.prototype.apply = function (context, runtime) {\n        var _this = this;\n        this.context = context;\n        var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot, \n        // @ts-ignore\n        pathGeneratorFactory = context.pathGeneratorFactory;\n        this.rBush = rBushRoot;\n        this.pathGeneratorFactory = pathGeneratorFactory;\n        var contextService = context.contextService;\n        var canvas = renderingContext.root.ownerDocument.defaultView;\n        var handleUnmounted = function (e) {\n            var object = e.target;\n            // remove r-bush node\n            // @ts-ignore\n            var rBushNode = object.rBushNode;\n            if (rBushNode.aabb) {\n                // save removed aabbs for dirty-rectangle rendering later\n                _this.removedRBushNodeAABBs.push(rBushNode.aabb);\n            }\n        };\n        var handleCulled = function (e) {\n            var object = e.target;\n            // @ts-ignore\n            var rBushNode = object.rBushNode;\n            if (rBushNode.aabb) {\n                // save removed aabbs for dirty-rectangle rendering later\n                _this.removedRBushNodeAABBs.push(rBushNode.aabb);\n            }\n        };\n        renderingService.hooks.init.tap(CanvasRendererPlugin.tag, function () {\n            canvas.addEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n            canvas.addEventListener(gLite.ElementEvent.CULLED, handleCulled);\n            // clear fullscreen\n            var dpr = contextService.getDPR();\n            var width = config.width, height = config.height;\n            var context = contextService.getContext();\n            _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);\n        });\n        renderingService.hooks.destroy.tap(CanvasRendererPlugin.tag, function () {\n            canvas.removeEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n            canvas.removeEventListener(gLite.ElementEvent.CULLED, handleCulled);\n            _this.renderQueue = [];\n            _this.removedRBushNodeAABBs = [];\n            _this.restoreStack = [];\n        });\n        renderingService.hooks.beginFrame.tap(CanvasRendererPlugin.tag, function () {\n            var context = contextService.getContext();\n            var dpr = contextService.getDPR();\n            var width = config.width, height = config.height;\n            var _a = _this.canvasRendererPluginOptions, dirtyObjectNumThreshold = _a.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _a.dirtyObjectRatioThreshold;\n            // some heuristic conditions such as 80% object changed\n            var _b = renderingService.getStats(), total = _b.total, rendered = _b.rendered;\n            var ratio = rendered / total;\n            _this.clearFullScreen =\n                renderingService.disableDirtyRectangleRendering() ||\n                    (rendered > dirtyObjectNumThreshold &&\n                        ratio > dirtyObjectRatioThreshold);\n            if (context) {\n                context.resetTransform\n                    ? context.resetTransform()\n                    : context.setTransform(1, 0, 0, 1, 0, 0);\n                if (_this.clearFullScreen) {\n                    _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);\n                }\n            }\n        });\n        var renderByZIndex = function (object, context) {\n            if (object.isVisible() && !object.isCulled()) {\n                _this.renderDisplayObject(object, context, _this.context, _this.restoreStack, runtime);\n                // if (object.renderable.) {\n                // if we did a full screen rendering last frame\n                _this.saveDirtyAABB(object);\n                // }\n            }\n            var sorted = object.sortable.sorted || object.childNodes;\n            // should account for z-index\n            sorted.forEach(function (child) {\n                renderByZIndex(child, context);\n            });\n        };\n        // render at the end of frame\n        renderingService.hooks.endFrame.tap(CanvasRendererPlugin.tag, function () {\n            var context = contextService.getContext();\n            // clear & clip dirty rectangle\n            var dpr = contextService.getDPR();\n            glMatrix.mat4.fromScaling(_this.dprMatrix, [dpr, dpr, 1]);\n            glMatrix.mat4.multiply(_this.vpMatrix, _this.dprMatrix, camera.getOrthoMatrix());\n            // if (this.clearFullScreen) {\n            if (_this.clearFullScreen) {\n                // console.log('canvas renderer fcp...');\n                renderByZIndex(renderingContext.root, context);\n            }\n            else {\n                // console.log('canvas renderer next...');\n                // merge removed AABB\n                var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, tslib.__spreadArray([_this.mergeDirtyAABBs(_this.renderQueue)], tslib.__read(_this.removedRBushNodeAABBs.map(function (_a) {\n                    var minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n                    var aabb = new gLite.AABB();\n                    aabb.setMinMax(\n                    // vec3.fromValues(minX, minY, 0),\n                    // vec3.fromValues(maxX, maxY, 0),\n                    [minX, minY, 0], [maxX, maxY, 0]);\n                    return aabb;\n                })), false));\n                _this.removedRBushNodeAABBs = [];\n                if (gLite.AABB.isEmpty(dirtyRenderBounds)) {\n                    _this.renderQueue = [];\n                    return;\n                }\n                var dirtyRect = _this.convertAABB2Rect(dirtyRenderBounds);\n                var x = dirtyRect.x, y = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;\n                var tl = glMatrix.vec3.transformMat4(_this.vec3a, [x, y, 0], _this.vpMatrix);\n                var tr = glMatrix.vec3.transformMat4(_this.vec3b, [x + width, y, 0], _this.vpMatrix);\n                var bl = glMatrix.vec3.transformMat4(_this.vec3c, [x, y + height, 0], _this.vpMatrix);\n                var br = glMatrix.vec3.transformMat4(_this.vec3d, [x + width, y + height, 0], _this.vpMatrix);\n                var minx = Math.min(tl[0], tr[0], br[0], bl[0]);\n                var miny = Math.min(tl[1], tr[1], br[1], bl[1]);\n                var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);\n                var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);\n                var ix = Math.floor(minx);\n                var iy = Math.floor(miny);\n                var iwidth = Math.ceil(maxx - minx);\n                var iheight = Math.ceil(maxy - miny);\n                context.save();\n                _this.clearRect(context, ix, iy, iwidth, iheight, config.background);\n                context.beginPath();\n                context.rect(ix, iy, iwidth, iheight);\n                context.clip();\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n                context.setTransform(_this.vpMatrix[0], _this.vpMatrix[1], _this.vpMatrix[4], _this.vpMatrix[5], _this.vpMatrix[12], _this.vpMatrix[13]);\n                // draw dirty rectangle\n                var enableDirtyRectangleRenderingDebug = config.renderer.getConfig().enableDirtyRectangleRenderingDebug;\n                if (enableDirtyRectangleRenderingDebug) {\n                    canvas.dispatchEvent(new gLite.CustomEvent(gLite.CanvasEvent.DIRTY_RECTANGLE, {\n                        dirtyRect: {\n                            x: ix,\n                            y: iy,\n                            width: iwidth,\n                            height: iheight,\n                        },\n                    }));\n                }\n                // search objects intersect with dirty rectangle\n                var dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);\n                // do rendering\n                dirtyObjects\n                    // sort by z-index\n                    .sort(function (a, b) { return a.sortable.renderOrder - b.sortable.renderOrder; })\n                    .forEach(function (object) {\n                    // culled object should not be rendered\n                    if (object && object.isVisible() && !object.isCulled()) {\n                        _this.renderDisplayObject(object, context, _this.context, _this.restoreStack, runtime);\n                    }\n                });\n                context.restore();\n                // save dirty AABBs in last frame\n                _this.renderQueue.forEach(function (object) {\n                    _this.saveDirtyAABB(object);\n                });\n                // clear queue\n                _this.renderQueue = [];\n            }\n            // pop restore stack, eg. root -> parent -> child\n            _this.restoreStack.forEach(function () {\n                context.restore();\n            });\n            // clear restore stack\n            _this.restoreStack = [];\n        });\n        renderingService.hooks.render.tap(CanvasRendererPlugin.tag, function (object) {\n            if (!_this.clearFullScreen) {\n                // render at the end of frame\n                _this.renderQueue.push(object);\n            }\n        });\n    };\n    CanvasRendererPlugin.prototype.clearRect = function (context, x, y, width, height, background) {\n        // clearRect is faster than fillRect @see https://stackoverflow.com/a/30830253\n        context.clearRect(x, y, width, height);\n        if (background) {\n            context.fillStyle = background;\n            context.fillRect(x, y, width, height);\n        }\n    };\n    CanvasRendererPlugin.prototype.renderDisplayObject = function (object, context, canvasContext, restoreStack, runtime) {\n        var nodeName = object.nodeName;\n        // console.log('canvas render:', object);\n        // restore to its ancestor\n        var parent = restoreStack[restoreStack.length - 1];\n        if (parent &&\n            !(object.compareDocumentPosition(parent) & gLite.Node.DOCUMENT_POSITION_CONTAINS)) {\n            context.restore();\n            restoreStack.pop();\n        }\n        // @ts-ignore\n        var styleRenderer = this.context.styleRendererFactory[nodeName];\n        var generatePath = this.pathGeneratorFactory[nodeName];\n        // clip path\n        var clipPath = object.parsedStyle.clipPath;\n        if (clipPath) {\n            this.applyWorldTransform(context, clipPath);\n            // generate path in local space\n            var generatePath_1 = this.pathGeneratorFactory[clipPath.nodeName];\n            if (generatePath_1) {\n                context.save();\n                // save clip\n                restoreStack.push(object);\n                context.beginPath();\n                generatePath_1(context, clipPath.parsedStyle);\n                context.closePath();\n                context.clip();\n            }\n        }\n        // fill & stroke\n        if (styleRenderer) {\n            this.applyWorldTransform(context, object);\n            context.save();\n            // apply attributes to context\n            this.applyAttributesToContext(context, object);\n        }\n        if (generatePath) {\n            context.beginPath();\n            generatePath(context, object.parsedStyle);\n            if (object.nodeName !== gLite.Shape.LINE &&\n                object.nodeName !== gLite.Shape.PATH &&\n                object.nodeName !== gLite.Shape.POLYLINE) {\n                context.closePath();\n            }\n        }\n        // fill & stroke\n        if (styleRenderer) {\n            styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime);\n            // restore applied attributes, eg. shadowBlur shadowColor...\n            context.restore();\n        }\n        // finish rendering, clear dirty flag\n        object.renderable.dirty = false;\n    };\n    CanvasRendererPlugin.prototype.convertAABB2Rect = function (aabb) {\n        var min = aabb.getMin();\n        var max = aabb.getMax();\n        // expand the rectangle a bit to avoid artifacts\n        // @see https://www.yuque.com/antv/ou292n/bi8nix#ExvCu\n        var minX = Math.floor(min[0]);\n        var minY = Math.floor(min[1]);\n        var maxX = Math.ceil(max[0]);\n        var maxY = Math.ceil(max[1]);\n        var width = maxX - minX;\n        var height = maxY - minY;\n        return { x: minX, y: minY, width: width, height: height };\n    };\n    /**\n     * TODO: merge dirty rectangles with some strategies.\n     * For now, we just simply merge all the rectangles into one.\n     * @see https://idom.me/articles/841.html\n     */\n    CanvasRendererPlugin.prototype.mergeDirtyAABBs = function (dirtyObjects) {\n        // merge into a big AABB\n        // TODO: skip descendant if ancestor is caculated, but compareNodePosition is really slow\n        var aabb = new gLite.AABB();\n        dirtyObjects.forEach(function (object) {\n            var renderBounds = object.getRenderBounds();\n            aabb.add(renderBounds);\n            var dirtyRenderBounds = object.renderable.dirtyRenderBounds;\n            if (dirtyRenderBounds) {\n                aabb.add(dirtyRenderBounds);\n            }\n        });\n        return aabb;\n    };\n    CanvasRendererPlugin.prototype.searchDirtyObjects = function (dirtyRectangle) {\n        // search in r-tree, get all affected nodes\n        var _a = tslib.__read(dirtyRectangle.getMin(), 2), minX = _a[0], minY = _a[1];\n        var _b = tslib.__read(dirtyRectangle.getMax(), 2), maxX = _b[0], maxY = _b[1];\n        var rBushNodes = this.rBush.search({\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY,\n        });\n        return rBushNodes.map(function (_a) {\n            var displayObject = _a.displayObject;\n            return displayObject;\n        });\n    };\n    CanvasRendererPlugin.prototype.saveDirtyAABB = function (object) {\n        var renderable = object.renderable;\n        if (!renderable.dirtyRenderBounds) {\n            renderable.dirtyRenderBounds = new gLite.AABB();\n        }\n        var renderBounds = object.getRenderBounds();\n        if (renderBounds) {\n            // save last dirty aabb\n            renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);\n        }\n    };\n    /**\n     * TODO: batch the same global attributes\n     */\n    CanvasRendererPlugin.prototype.applyAttributesToContext = function (context, object) {\n        var _a = object.parsedStyle, stroke = _a.stroke, fill = _a.fill, opacity = _a.opacity, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset;\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash\n        if (lineDash) {\n            context.setLineDash(lineDash);\n        }\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset\n        if (!util.isNil(lineDashOffset)) {\n            context.lineDashOffset = lineDashOffset;\n        }\n        if (!util.isNil(opacity)) {\n            context.globalAlpha *= opacity;\n        }\n        if (!util.isNil(stroke) &&\n            !Array.isArray(stroke) &&\n            !stroke.isNone) {\n            context.strokeStyle = object.attributes.stroke;\n        }\n        if (!util.isNil(fill) && !Array.isArray(fill) && !fill.isNone) {\n            context.fillStyle = object.attributes.fill;\n        }\n    };\n    CanvasRendererPlugin.prototype.applyWorldTransform = function (context, object, matrix) {\n        var tx = 0;\n        var ty = 0;\n        var anchor = (object.parsedStyle || {}).anchor;\n        var anchorX = (anchor && anchor[0]) || 0;\n        var anchorY = (anchor && anchor[1]) || 0;\n        if (anchorX !== 0 || anchorY !== 0) {\n            // const bounds = object.getGeometryBounds();\n            var bounds = object.geometry.contentBounds;\n            var width = (bounds && bounds.halfExtents[0] * 2) || 0;\n            var height = (bounds && bounds.halfExtents[1] * 2) || 0;\n            tx = -(anchorX * width);\n            ty = -(anchorY * height);\n        }\n        // apply clip shape's RTS\n        if (matrix) {\n            glMatrix.mat4.copy(this.tmpMat4, object.getLocalTransform());\n            this.vec3a[0] = tx;\n            this.vec3a[1] = ty;\n            this.vec3a[2] = 0;\n            glMatrix.mat4.translate(this.tmpMat4, this.tmpMat4, this.vec3a);\n            glMatrix.mat4.multiply(this.tmpMat4, matrix, this.tmpMat4);\n            glMatrix.mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);\n        }\n        else {\n            // apply RTS transformation in world space\n            glMatrix.mat4.copy(this.tmpMat4, object.getWorldTransform());\n            this.vec3a[0] = tx;\n            this.vec3a[1] = ty;\n            this.vec3a[2] = 0;\n            glMatrix.mat4.translate(this.tmpMat4, this.tmpMat4, this.vec3a);\n            glMatrix.mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);\n        }\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n        context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);\n    };\n    CanvasRendererPlugin.prototype.safeMergeAABB = function () {\n        var aabbs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            aabbs[_i] = arguments[_i];\n        }\n        var merged = new gLite.AABB();\n        aabbs.forEach(function (aabb) {\n            merged.add(aabb);\n        });\n        return merged;\n    };\n    CanvasRendererPlugin.tag = 'CanvasRenderer';\n    return CanvasRendererPlugin;\n}());\n\nvar DefaultRenderer = /** @class */ (function () {\n    function DefaultRenderer(imagePool) {\n        this.imagePool = imagePool;\n    }\n    DefaultRenderer.prototype.render = function (context, parsedStyle, object, canvasContext, plugin, runtime) {\n        var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, opacity = parsedStyle.opacity, fillOpacity = parsedStyle.fillOpacity, stroke = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity, lineWidth = parsedStyle.lineWidth, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;\n        var hasFill = !util.isNil(fill) && !fill.isNone;\n        var hasStroke = !util.isNil(stroke) && !stroke.isNone && lineWidth > 0;\n        var isFillTransparent = fill.alpha === 0;\n        var hasFilter = !!(filter && filter.length);\n        var hasShadow = !util.isNil(shadowColor) && shadowBlur > 0;\n        var nodeName = object.nodeName;\n        var isInnerShadow = shadowType === 'inner';\n        var shouldDrawShadowWithStroke = hasStroke &&\n            hasShadow &&\n            (nodeName === gLite.Shape.PATH ||\n                nodeName === gLite.Shape.LINE ||\n                nodeName === gLite.Shape.POLYLINE ||\n                isFillTransparent ||\n                isInnerShadow);\n        if (hasFill) {\n            context.globalAlpha = opacity * fillOpacity;\n            if (!shouldDrawShadowWithStroke) {\n                setShadowAndFilter(object, context, hasShadow);\n            }\n            this.fill(context, object, fill, fillRule, canvasContext, plugin, runtime);\n            if (!shouldDrawShadowWithStroke) {\n                this.clearShadowAndFilter(context, hasFilter, hasShadow);\n            }\n        }\n        if (hasStroke) {\n            context.globalAlpha = opacity * strokeOpacity;\n            context.lineWidth = lineWidth;\n            if (!util.isNil(miterLimit)) {\n                context.miterLimit = miterLimit;\n            }\n            if (!util.isNil(lineCap)) {\n                context.lineCap = lineCap;\n            }\n            if (!util.isNil(lineJoin)) {\n                context.lineJoin = lineJoin;\n            }\n            if (shouldDrawShadowWithStroke) {\n                if (isInnerShadow) {\n                    context.globalCompositeOperation = 'source-atop';\n                }\n                setShadowAndFilter(object, context, true);\n                if (isInnerShadow) {\n                    this.stroke(context, object, stroke, canvasContext, plugin, runtime);\n                    context.globalCompositeOperation = 'source-over';\n                    this.clearShadowAndFilter(context, hasFilter, true);\n                }\n            }\n            this.stroke(context, object, stroke, canvasContext, plugin, runtime);\n        }\n    };\n    DefaultRenderer.prototype.clearShadowAndFilter = function (context, hasFilter, hasShadow) {\n        if (hasShadow) {\n            context.shadowColor = 'transparent';\n            context.shadowBlur = 0;\n        }\n        if (hasFilter) {\n            // save drop-shadow filter\n            var oldFilter = context.filter;\n            if (!util.isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {\n                context.filter =\n                    oldFilter.replace(/drop-shadow\\([^)]*\\)/, '').trim() || 'none';\n            }\n        }\n    };\n    DefaultRenderer.prototype.fill = function (context, object, fill, fillRule, canvasContext, plugin, runtime) {\n        var _this = this;\n        if (Array.isArray(fill)) {\n            fill.forEach(function (gradient) {\n                context.fillStyle = _this.getColor(gradient, object, context);\n                fillRule ? context.fill(fillRule) : context.fill();\n            });\n        }\n        else {\n            if (gLite.isPattern(fill)) {\n                context.fillStyle = this.getPattern(fill, object, context, canvasContext, plugin, runtime);\n            }\n            fillRule ? context.fill(fillRule) : context.fill();\n        }\n    };\n    DefaultRenderer.prototype.stroke = function (context, object, stroke, canvasContext, plugin, runtime) {\n        var _this = this;\n        if (Array.isArray(stroke)) {\n            stroke.forEach(function (gradient) {\n                context.strokeStyle = _this.getColor(gradient, object, context);\n                context.stroke();\n            });\n        }\n        else {\n            if (gLite.isPattern(stroke)) {\n                context.strokeStyle = this.getPattern(stroke, object, context, canvasContext, plugin, runtime);\n            }\n            context.stroke();\n        }\n    };\n    DefaultRenderer.prototype.getPattern = function (pattern, object, context, canvasContext, plugin, runtime) {\n        var $offscreenCanvas;\n        var dpr;\n        if (pattern.image.nodeName === 'rect') {\n            var _a = pattern.image.parsedStyle, width = _a.width, height = _a.height;\n            dpr = canvasContext.contextService.getDPR();\n            var offscreenCanvas = canvasContext.config.offscreenCanvas;\n            $offscreenCanvas = runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n            $offscreenCanvas.width = width * dpr;\n            $offscreenCanvas.height = height * dpr;\n            var offscreenCanvasContext_1 = runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);\n            var restoreStack_1 = [];\n            // offscreenCanvasContext.scale(1 / dpr, 1 / dpr);\n            pattern.image.forEach(function (object) {\n                plugin.renderDisplayObject(object, offscreenCanvasContext_1, canvasContext, restoreStack_1, runtime);\n            });\n            restoreStack_1.forEach(function () {\n                offscreenCanvasContext_1.restore();\n            });\n        }\n        var canvasPattern = this.imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, function () {\n            // set dirty rectangle flag\n            object.renderable.dirty = true;\n            canvasContext.renderingService.dirtify();\n        });\n        return canvasPattern;\n    };\n    DefaultRenderer.prototype.getColor = function (parsedColor, object, context) {\n        var color;\n        if (parsedColor.type === gLite.GradientType.LinearGradient ||\n            parsedColor.type === gLite.GradientType.RadialGradient) {\n            var bounds = object.getGeometryBounds();\n            var width = (bounds && bounds.halfExtents[0] * 2) || 1;\n            var height = (bounds && bounds.halfExtents[1] * 2) || 1;\n            color = this.imagePool.getOrCreateGradient(tslib.__assign(tslib.__assign({ type: parsedColor.type }, parsedColor.value), { width: width, height: height }), context);\n        }\n        return color;\n    };\n    return DefaultRenderer;\n}());\n/**\n * apply before fill and stroke but only once\n */\nfunction setShadowAndFilter(object, context, hasShadow) {\n    var _a = object.parsedStyle, filter = _a.filter, shadowColor = _a.shadowColor, shadowBlur = _a.shadowBlur, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY;\n    if (filter && filter.length) {\n        // use raw filter string\n        context.filter = object.style.filter;\n    }\n    if (hasShadow) {\n        context.shadowColor = shadowColor.toString();\n        context.shadowBlur = shadowBlur || 0;\n        context.shadowOffsetX = shadowOffsetX || 0;\n        context.shadowOffsetY = shadowOffsetY || 0;\n    }\n}\n\nvar ImageRenderer = /** @class */ (function () {\n    function ImageRenderer(imagePool) {\n        this.imagePool = imagePool;\n    }\n    ImageRenderer.prototype.render = function (context, parsedStyle, object) {\n        var width = parsedStyle.width, height = parsedStyle.height, img = parsedStyle.img, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;\n        var image;\n        var iw = width;\n        var ih = height;\n        if (util.isString(img)) {\n            // image has been loaded in `mounted` hook\n            image = this.imagePool.getImageSync(img);\n        }\n        else {\n            iw || (iw = img.width);\n            ih || (ih = img.height);\n            image = img;\n        }\n        if (image) {\n            var hasShadow = !util.isNil(shadowColor) && shadowBlur > 0;\n            setShadowAndFilter(object, context, hasShadow);\n            // node-canvas will throw the following err:\n            // Error: Image given has not completed loading\n            try {\n                context.drawImage(image, 0, 0, iw, ih);\n            }\n            catch (e) { }\n        }\n    };\n    return ImageRenderer;\n}());\n\nvar TextRenderer = /** @class */ (function () {\n    function TextRenderer() {\n    }\n    TextRenderer.prototype.render = function (context, parsedStyle, object, canvasContext, plugin, runtime) {\n        var _a = parsedStyle, lineWidth = _a.lineWidth, textAlign = _a.textAlign, textBaseline = _a.textBaseline, lineJoin = _a.lineJoin, miterLimit = _a.miterLimit, letterSpacing = _a.letterSpacing, stroke = _a.stroke, fill = _a.fill, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, opacity = _a.opacity, metrics = _a.metrics, dx = _a.dx, dy = _a.dy, shadowColor = _a.shadowColor, shadowBlur = _a.shadowBlur;\n        var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;\n        context.font = font;\n        context.lineWidth = lineWidth;\n        context.textAlign = textAlign === 'middle' ? 'center' : textAlign;\n        var formattedTextBaseline = textBaseline;\n        if (\n        // formattedTextBaseline === 'bottom' ||\n        !runtime.enableCSSParsing &&\n            formattedTextBaseline === 'alphabetic') {\n            formattedTextBaseline = 'bottom';\n        }\n        context.lineJoin = lineJoin;\n        if (!util.isNil(miterLimit)) {\n            context.miterLimit = miterLimit;\n        }\n        var linePositionY = 0;\n        // handle vertical text baseline\n        if (textBaseline === 'middle') {\n            linePositionY = -height / 2 - lineHeight / 2;\n        }\n        else if (textBaseline === 'bottom' ||\n            textBaseline === 'alphabetic' ||\n            textBaseline === 'ideographic') {\n            linePositionY = -height;\n        }\n        else if (textBaseline === 'top' || textBaseline === 'hanging') {\n            linePositionY = -lineHeight;\n        }\n        // account for dx & dy\n        var offsetX = dx || 0;\n        linePositionY += dy || 0;\n        if (lines.length === 1) {\n            if (formattedTextBaseline === 'bottom') {\n                formattedTextBaseline = 'middle';\n                linePositionY -= 0.5 * height;\n            }\n            else if (formattedTextBaseline === 'top') {\n                formattedTextBaseline = 'middle';\n                linePositionY += 0.5 * height;\n            }\n        }\n        context.textBaseline = formattedTextBaseline;\n        var hasShadow = !util.isNil(shadowColor) && shadowBlur > 0;\n        setShadowAndFilter(object, context, hasShadow);\n        // draw lines line by line\n        for (var i = 0; i < lines.length; i++) {\n            var linePositionX = lineWidth / 2 + offsetX;\n            linePositionY += lineHeight;\n            // no need to re-position X, cause we already set text align\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign\n            if (!util.isNil(stroke) && !stroke.isNone && lineWidth) {\n                this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity, true);\n            }\n            if (!util.isNil(fill)) {\n                this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity);\n            }\n        }\n    };\n    TextRenderer.prototype.drawLetterSpacing = function (context, text, lineMetrics, textAlign, x, y, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {\n        if (isStroke === void 0) { isStroke = false; }\n        // letterSpacing of 0 means normal, render all texts directly\n        if (letterSpacing === 0) {\n            if (isStroke) {\n                this.strokeText(context, text, x, y, strokeOpacity);\n            }\n            else {\n                this.fillText(context, text, x, y, fillOpacity, opacity);\n            }\n            return;\n        }\n        // draw text using left align\n        var currentTextAlign = context.textAlign;\n        context.textAlign = 'left';\n        var currentPosition = x;\n        if (textAlign === 'center' || textAlign === 'middle') {\n            currentPosition = x - lineMetrics.width / 2;\n        }\n        else if (textAlign === 'right' || textAlign === 'end') {\n            currentPosition = x - lineMetrics.width;\n        }\n        var stringArray = Array.from(text);\n        var previousWidth = context.measureText(text).width;\n        var currentWidth = 0;\n        for (var i = 0; i < stringArray.length; ++i) {\n            var currentChar = stringArray[i];\n            if (isStroke) {\n                this.strokeText(context, currentChar, currentPosition, y, strokeOpacity);\n            }\n            else {\n                this.fillText(context, currentChar, currentPosition, y, fillOpacity, opacity);\n            }\n            currentWidth = context.measureText(text.substring(i + 1)).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n        context.textAlign = currentTextAlign;\n    };\n    TextRenderer.prototype.fillText = function (context, text, x, y, fillOpacity, opacity) {\n        var currentGlobalAlpha;\n        var applyOpacity = !util.isNil(fillOpacity) && fillOpacity !== 1;\n        if (applyOpacity) {\n            currentGlobalAlpha = context.globalAlpha;\n            context.globalAlpha = fillOpacity * opacity;\n        }\n        context.fillText(text, x, y);\n        if (applyOpacity) {\n            context.globalAlpha = currentGlobalAlpha;\n        }\n    };\n    TextRenderer.prototype.strokeText = function (context, text, x, y, strokeOpacity) {\n        var currentGlobalAlpha;\n        var applyOpacity = !util.isNil(strokeOpacity) && strokeOpacity !== 1;\n        if (applyOpacity) {\n            currentGlobalAlpha = context.globalAlpha;\n            context.globalAlpha = strokeOpacity;\n        }\n        context.strokeText(text, x, y);\n        if (applyOpacity) {\n            context.globalAlpha = currentGlobalAlpha;\n        }\n    };\n    return TextRenderer;\n}());\n\nvar RectRenderer = /** @class */ (function (_super) {\n    tslib.__extends(RectRenderer, _super);\n    function RectRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return RectRenderer;\n}(DefaultRenderer));\n\nvar CircleRenderer = /** @class */ (function (_super) {\n    tslib.__extends(CircleRenderer, _super);\n    function CircleRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return CircleRenderer;\n}(DefaultRenderer));\n\nvar EllipseRenderer = /** @class */ (function (_super) {\n    tslib.__extends(EllipseRenderer, _super);\n    function EllipseRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return EllipseRenderer;\n}(DefaultRenderer));\n\nvar LineRenderer = /** @class */ (function (_super) {\n    tslib.__extends(LineRenderer, _super);\n    function LineRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LineRenderer;\n}(DefaultRenderer));\n\nvar PolylineRenderer = /** @class */ (function (_super) {\n    tslib.__extends(PolylineRenderer, _super);\n    function PolylineRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PolylineRenderer;\n}(DefaultRenderer));\n\nvar PolygonRenderer = /** @class */ (function (_super) {\n    tslib.__extends(PolygonRenderer, _super);\n    function PolygonRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PolygonRenderer;\n}(DefaultRenderer));\n\nvar PathRenderer = /** @class */ (function (_super) {\n    tslib.__extends(PathRenderer, _super);\n    function PathRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PathRenderer;\n}(DefaultRenderer));\n\nvar Plugin = /** @class */ (function (_super) {\n    tslib.__extends(Plugin, _super);\n    function Plugin(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.options = options;\n        _this.name = 'canvas-renderer';\n        return _this;\n    }\n    Plugin.prototype.init = function () {\n        var _a;\n        var canvasRendererPluginOptions = tslib.__assign({ dirtyObjectNumThreshold: 500, dirtyObjectRatioThreshold: 0.8 }, this.options);\n        // @ts-ignore\n        var imagePool = this.context.imagePool;\n        var defaultRenderer = new DefaultRenderer(imagePool);\n        var defaultStyleRendererFactory = (_a = {},\n            _a[gLite.Shape.CIRCLE] = defaultRenderer,\n            _a[gLite.Shape.ELLIPSE] = defaultRenderer,\n            _a[gLite.Shape.RECT] = defaultRenderer,\n            _a[gLite.Shape.IMAGE] = new ImageRenderer(imagePool),\n            _a[gLite.Shape.TEXT] = new TextRenderer(),\n            _a[gLite.Shape.LINE] = defaultRenderer,\n            _a[gLite.Shape.POLYLINE] = defaultRenderer,\n            _a[gLite.Shape.POLYGON] = defaultRenderer,\n            _a[gLite.Shape.PATH] = defaultRenderer,\n            _a[gLite.Shape.GROUP] = undefined,\n            _a[gLite.Shape.HTML] = undefined,\n            _a[gLite.Shape.MESH] = undefined,\n            _a);\n        this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;\n        this.context.styleRendererFactory = defaultStyleRendererFactory;\n        this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));\n    };\n    Plugin.prototype.destroy = function () {\n        this.removeAllRenderingPlugins();\n        delete this.context.defaultStyleRendererFactory;\n        delete this.context.styleRendererFactory;\n    };\n    return Plugin;\n}(gLite.AbstractRendererPlugin));\n\nexports.CircleRenderer = CircleRenderer;\nexports.EllipseRenderer = EllipseRenderer;\nexports.ImageRenderer = ImageRenderer;\nexports.LineRenderer = LineRenderer;\nexports.PathRenderer = PathRenderer;\nexports.Plugin = Plugin;\nexports.PolygonRenderer = PolygonRenderer;\nexports.PolylineRenderer = PolylineRenderer;\nexports.RectRenderer = RectRenderer;\nexports.TextRenderer = TextRenderer;\n//# sourceMappingURL=index.js.map\n"]}