{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar gLite = require('@antv/g-lite');\nvar tslib = require('tslib');\nvar util = require('@antv/util');\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationPlaybackEvent\n */\n// @ts-ignore\nvar AnimationEvent = /** @class */ (function (_super) {\n    tslib.__extends(AnimationEvent, _super);\n    function AnimationEvent(manager, target, currentTime, timelineTime) {\n        var _this = _super.call(this, manager) || this;\n        _this.currentTime = currentTime;\n        _this.timelineTime = timelineTime;\n        // @ts-ignore\n        _this.target = target;\n        _this.type = 'finish';\n        _this.bubbles = false;\n        // @ts-ignore\n        _this.currentTarget = target;\n        _this.defaultPrevented = false;\n        _this.eventPhase = _this.AT_TARGET;\n        _this.timeStamp = Date.now();\n        _this.currentTime = currentTime;\n        _this.timelineTime = timelineTime;\n        return _this;\n    }\n    return AnimationEvent;\n}(gLite.FederatedEvent));\n\nvar sequenceNumber = 0;\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/Animation\n */\nvar Animation = /** @class */ (function () {\n    function Animation(effect, timeline) {\n        var _a;\n        this.currentTimePending = false;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/playState\n         */\n        // playState: AnimationPlayState;\n        this._idle = true;\n        this._paused = false;\n        this._finishedFlag = true;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/currentTime\n         */\n        this._currentTime = 0;\n        this._playbackRate = 1;\n        this._inTimeline = true;\n        this.effect = effect;\n        effect.animation = this;\n        this.timeline = timeline;\n        this.id = \"\".concat(sequenceNumber++);\n        this._inEffect = !!this.effect.update(0);\n        this._totalDuration = Number((_a = this.effect) === null || _a === void 0 ? void 0 : _a.getComputedTiming().endTime);\n        this._holdTime = 0;\n        this._paused = false;\n        this.oldPlayState = 'idle';\n        this.updatePromises();\n    }\n    Object.defineProperty(Animation.prototype, \"pending\", {\n        // animation: InternalAnimation | null;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending\n         */\n        get: function () {\n            return ((this._startTime === null && !this._paused && this.playbackRate !== 0) ||\n                this.currentTimePending);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"playState\", {\n        get: function () {\n            if (this._idle)\n                return 'idle';\n            if (this._isFinished)\n                return 'finished';\n            if (this._paused)\n                return 'paused';\n            return 'running';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"ready\", {\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready\n         * @example\n          animation.pause();\n          animation.ready.then(function() {\n            // Displays 'running'\n            alert(animation.playState);\n          });\n          animation.play();\n         */\n        get: function () {\n            var _this = this;\n            if (!this.readyPromise) {\n                if (this.timeline.animationsWithPromises.indexOf(this) === -1) {\n                    this.timeline.animationsWithPromises.push(this);\n                }\n                this.readyPromise = new Promise(function (resolve, reject) {\n                    _this.resolveReadyPromise = function () {\n                        resolve(_this);\n                    };\n                    _this.rejectReadyPromise = function () {\n                        reject(new Error());\n                    };\n                });\n                if (!this.pending) {\n                    this.resolveReadyPromise();\n                }\n            }\n            return this.readyPromise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"finished\", {\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished\n         * @example\n          Promise.all(\n            elem.getAnimations().map(\n              function(animation) {\n                return animation.finished\n              }\n            )\n          ).then(\n            function() {\n              return elem.remove();\n            }\n          );\n         */\n        get: function () {\n            var _this = this;\n            if (!this.finishedPromise) {\n                if (this.timeline.animationsWithPromises.indexOf(this) === -1) {\n                    this.timeline.animationsWithPromises.push(this);\n                }\n                this.finishedPromise = new Promise(function (resolve, reject) {\n                    _this.resolveFinishedPromise = function () {\n                        resolve(_this);\n                    };\n                    _this.rejectFinishedPromise = function () {\n                        reject(new Error());\n                    };\n                });\n                if (this.playState === 'finished') {\n                    this.resolveFinishedPromise();\n                }\n            }\n            return this.finishedPromise;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"currentTime\", {\n        get: function () {\n            this.updatePromises();\n            return this._idle || this.currentTimePending ? null : this._currentTime;\n        },\n        set: function (newTime) {\n            var _a;\n            newTime = Number(newTime);\n            if (isNaN(newTime))\n                return;\n            this.timeline.restart();\n            if (!this._paused && this._startTime !== null) {\n                this._startTime =\n                    Number((_a = this.timeline) === null || _a === void 0 ? void 0 : _a.currentTime) - newTime / this.playbackRate;\n            }\n            this.currentTimePending = false;\n            if (this._currentTime === newTime) {\n                return;\n            }\n            if (this._idle) {\n                this._idle = false;\n                this._paused = true;\n            }\n            this.tickCurrentTime(newTime, true);\n            this.timeline.applyDirtiedAnimation(this);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"startTime\", {\n        get: function () {\n            return this._startTime;\n        },\n        set: function (newTime) {\n            if (newTime !== null) {\n                this.updatePromises();\n                newTime = Number(newTime);\n                if (isNaN(newTime))\n                    return;\n                if (this._paused || this._idle)\n                    return;\n                this._startTime = newTime;\n                this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) *\n                    this.playbackRate);\n                this.timeline.applyDirtiedAnimation(this);\n                this.updatePromises();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"playbackRate\", {\n        get: function () {\n            return this._playbackRate;\n        },\n        set: function (value) {\n            if (value === this._playbackRate) {\n                return;\n            }\n            this.updatePromises();\n            var oldCurrentTime = this.currentTime;\n            this._playbackRate = value;\n            this.startTime = null;\n            if (this.playState !== 'paused' && this.playState !== 'idle') {\n                this._finishedFlag = false;\n                this._idle = false;\n                this.ensureAlive();\n                this.timeline.applyDirtiedAnimation(this);\n            }\n            if (oldCurrentTime !== null) {\n                this.currentTime = oldCurrentTime;\n            }\n            this.updatePromises();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"_isFinished\", {\n        get: function () {\n            return (!this._idle &&\n                ((this._playbackRate > 0 &&\n                    Number(this._currentTime) >= this._totalDuration) ||\n                    (this._playbackRate < 0 && Number(this._currentTime) <= 0)));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"totalDuration\", {\n        get: function () {\n            return this._totalDuration;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"_needsTick\", {\n        get: function () {\n            return this.pending || this.playState === 'running' || !this._finishedFlag;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * state machine,\n     * resolve/reject ready/finished Promise according to current state\n     */\n    Animation.prototype.updatePromises = function () {\n        var oldPlayState = this.oldPlayState;\n        var newPlayState = this.pending ? 'pending' : this.playState;\n        if (this.readyPromise && newPlayState !== oldPlayState) {\n            if (newPlayState === 'idle') {\n                this.rejectReadyPromise();\n                this.readyPromise = undefined;\n            }\n            else if (oldPlayState === 'pending') {\n                this.resolveReadyPromise();\n            }\n            else if (newPlayState === 'pending') {\n                this.readyPromise = undefined;\n            }\n        }\n        if (this.finishedPromise && newPlayState !== oldPlayState) {\n            if (newPlayState === 'idle') {\n                this.rejectFinishedPromise();\n                this.finishedPromise = undefined;\n            }\n            else if (newPlayState === 'finished') {\n                this.resolveFinishedPromise();\n            }\n            else if (oldPlayState === 'finished') {\n                this.finishedPromise = undefined;\n            }\n        }\n        this.oldPlayState = newPlayState;\n        return this.readyPromise || this.finishedPromise;\n    };\n    Animation.prototype.play = function () {\n        this.updatePromises();\n        this._paused = false;\n        if (this._isFinished || this._idle) {\n            this.rewind();\n            this._startTime = null;\n        }\n        this._finishedFlag = false;\n        this._idle = false;\n        this.ensureAlive();\n        this.timeline.applyDirtiedAnimation(this);\n        if (this.timeline.animations.indexOf(this) === -1) {\n            this.timeline.animations.push(this);\n        }\n        this.updatePromises();\n    };\n    Animation.prototype.pause = function () {\n        this.updatePromises();\n        if (this.currentTime) {\n            this._holdTime = this.currentTime;\n        }\n        if (!this._isFinished && !this._paused && !this._idle) {\n            this.currentTimePending = true;\n        }\n        else if (this._idle) {\n            this.rewind();\n            this._idle = false;\n        }\n        this._startTime = null;\n        this._paused = true;\n        this.updatePromises();\n    };\n    Animation.prototype.finish = function () {\n        this.updatePromises();\n        if (this._idle)\n            return;\n        this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;\n        this._startTime = this._totalDuration - this.currentTime;\n        this.currentTimePending = false;\n        this.timeline.applyDirtiedAnimation(this);\n        this.updatePromises();\n    };\n    Animation.prototype.cancel = function () {\n        var _this = this;\n        this.updatePromises();\n        if (!this._inEffect)\n            return;\n        this._inEffect = false;\n        this._idle = true;\n        this._paused = false;\n        this._finishedFlag = true;\n        this._currentTime = 0;\n        this._startTime = null;\n        this.effect.update(null);\n        // effects are invalid after cancellation as the animation state\n        // needs to un-apply.\n        this.timeline.applyDirtiedAnimation(this);\n        this.updatePromises();\n        /**\n         * 1. Reject the current finished promise with a DOMException named \"AbortError\".\n         * 2. Let current finished promise be a new promise\n         * @see https://w3c.github.io/csswg-drafts/web-animations-1/#canceling-an-animation-section\n         */\n        // if (this.finishedPromise) {\n        //   this.rejectFinishedPromise();\n        //   this.finishedPromise = undefined;\n        // }\n        if (this.oncancel) {\n            var event_1 = new AnimationEvent(null, this, this.currentTime, null);\n            setTimeout(function () {\n                _this.oncancel(event_1);\n            });\n        }\n    };\n    Animation.prototype.reverse = function () {\n        this.updatePromises();\n        var oldCurrentTime = this.currentTime;\n        this.playbackRate *= -1;\n        this.play();\n        if (oldCurrentTime !== null) {\n            this.currentTime = oldCurrentTime;\n        }\n        this.updatePromises();\n    };\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate\n     */\n    Animation.prototype.updatePlaybackRate = function (playbackRate) {\n        this.playbackRate = playbackRate;\n    };\n    Animation.prototype.targetAnimations = function () {\n        var _a;\n        var target = (_a = this.effect) === null || _a === void 0 ? void 0 : _a.target;\n        return target.getAnimations();\n    };\n    Animation.prototype.markTarget = function () {\n        var animations = this.targetAnimations();\n        if (animations.indexOf(this) === -1) {\n            animations.push(this);\n        }\n    };\n    Animation.prototype.unmarkTarget = function () {\n        var animations = this.targetAnimations();\n        var index = animations.indexOf(this);\n        if (index !== -1) {\n            animations.splice(index, 1);\n        }\n    };\n    Animation.prototype.tick = function (timelineTime, isAnimationFrame) {\n        if (!this._idle && !this._paused) {\n            if (this._startTime === null) {\n                if (isAnimationFrame) {\n                    this.startTime = timelineTime - this._currentTime / this.playbackRate;\n                }\n            }\n            else if (!this._isFinished) {\n                this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);\n            }\n        }\n        if (isAnimationFrame) {\n            this.currentTimePending = false;\n            this.fireEvents(timelineTime);\n        }\n    };\n    Animation.prototype.rewind = function () {\n        if (this.playbackRate >= 0) {\n            this.currentTime = 0;\n        }\n        else if (this._totalDuration < Infinity) {\n            this.currentTime = this._totalDuration;\n        }\n        else {\n            throw new Error('Unable to rewind negative playback rate animation with infinite duration');\n        }\n    };\n    Animation.prototype.persist = function () {\n        throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n    };\n    Animation.prototype.addEventListener = function (type, listener, options) {\n        throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n    };\n    Animation.prototype.removeEventListener = function (type, listener, options) {\n        throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n    };\n    Animation.prototype.dispatchEvent = function (event) {\n        throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n    };\n    // replaceState: AnimationReplaceState;\n    Animation.prototype.commitStyles = function () {\n        throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);\n    };\n    Animation.prototype.ensureAlive = function () {\n        var _a, _b;\n        // If an animation is playing backwards and is not fill backwards/both\n        // then it should go out of effect when it reaches the start of its\n        // active interval (currentTime === 0).\n        if (this.playbackRate < 0 && this.currentTime === 0) {\n            this._inEffect = !!((_a = this.effect) === null || _a === void 0 ? void 0 : _a.update(-1));\n        }\n        else {\n            this._inEffect = !!((_b = this.effect) === null || _b === void 0 ? void 0 : _b.update(this.currentTime));\n        }\n        if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {\n            this._inTimeline = true;\n            this.timeline.animations.push(this);\n        }\n    };\n    Animation.prototype.tickCurrentTime = function (newTime, ignoreLimit) {\n        if (newTime !== this._currentTime) {\n            this._currentTime = newTime;\n            if (this._isFinished && !ignoreLimit) {\n                this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;\n            }\n            this.ensureAlive();\n        }\n    };\n    Animation.prototype.fireEvents = function (baseTime) {\n        var _this = this;\n        if (this._isFinished) {\n            if (!this._finishedFlag) {\n                if (this.onfinish) {\n                    var event_2 = new AnimationEvent(null, this, this.currentTime, baseTime);\n                    setTimeout(function () {\n                        if (_this.onfinish) {\n                            _this.onfinish(event_2);\n                        }\n                    });\n                }\n                this._finishedFlag = true;\n            }\n        }\n        else {\n            if (this.onframe && this.playState === 'running') {\n                var event_3 = new AnimationEvent(null, this, this.currentTime, baseTime);\n                this.onframe(event_3);\n            }\n            this._finishedFlag = false;\n        }\n    };\n    return Animation;\n}());\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\nvar A = function (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; };\nvar B = function (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; };\nvar C = function (aA1) { return 3.0 * aA1; };\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nvar calcBezier = function (aT, aA1, aA2) {\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n};\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nvar getSlope = function (aT, aA1, aA2) {\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n};\nvar binarySubdivide = function (aX, aA, aB, mX1, mX2) {\n    var currentX, currentT, i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0)\n            aB = currentT;\n        else\n            aA = currentT;\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n};\nvar newtonRaphsonIterate = function (aX, aGuessT, mX1, mX2) {\n    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0)\n            return aGuessT;\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n};\nvar bezier = function (mX1, mY1, mX2, mY2) {\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))\n        throw new Error('bezier x values must be in [0, 1] range');\n    if (mX1 === mY1 && mX2 === mY2)\n        return function (t) { return t; };\n    // Precompute samples table\n    var sampleValues = float32ArraySupported\n        ? new Float32Array(kSplineTableSize)\n        : new Array(kSplineTableSize);\n    for (var i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    var getTForX = function (aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)\n            intervalStart += kSampleStepSize;\n        --currentSample;\n        // Interpolate to provide an initial guess for t\n        var dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE)\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        else if (initialSlope === 0.0)\n            return guessForT;\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    };\n    return function (t) {\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n        if (t === 0 || t === 1)\n            return t;\n        return calcBezier(getTForX(t), mY1, mY2);\n    };\n};\n\nvar convertToDash = function (str) {\n    str = str.replace(/([A-Z])/g, function (letter) { return \"-\".concat(letter.toLowerCase()); });\n    // Remove first dash\n    return str.charAt(0) === '-' ? str.substring(1) : str;\n};\n/**\n  Easing Functions from anime.js, they are tried and true, so, its better to use them instead of other alternatives\n*/\nvar Quad = function (t) { return Math.pow(t, 2); };\nvar Cubic = function (t) { return Math.pow(t, 3); };\nvar Quart = function (t) { return Math.pow(t, 4); };\nvar Quint = function (t) { return Math.pow(t, 5); };\nvar Expo = function (t) { return Math.pow(t, 6); };\nvar Sine = function (t) { return 1 - Math.cos((t * Math.PI) / 2); };\nvar Circ = function (t) { return 1 - Math.sqrt(1 - t * t); };\nvar Back = function (t) { return t * t * (3 * t - 2); };\nvar Bounce = function (t) {\n    var pow2, b = 4;\n    while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) { }\n    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);\n};\nvar Elastic = function (t, params) {\n    if (params === void 0) { params = []; }\n    var _a = tslib.__read(params, 2), _b = _a[0], amplitude = _b === void 0 ? 1 : _b, _c = _a[1], period = _c === void 0 ? 0.5 : _c;\n    var a = util.clamp(Number(amplitude), 1, 10);\n    var p = util.clamp(Number(period), 0.1, 2);\n    if (t === 0 || t === 1)\n        return t;\n    return (-a *\n        Math.pow(2, 10 * (t - 1)) *\n        Math.sin(((t - 1 - (p / (Math.PI * 2)) * Math.asin(1 / a)) * (Math.PI * 2)) / p));\n};\nvar Spring = function (t, params, duration) {\n    if (params === void 0) { params = []; }\n    var _a = tslib.__read(params, 4), _b = _a[0], mass = _b === void 0 ? 1 : _b, _c = _a[1], stiffness = _c === void 0 ? 100 : _c, _d = _a[2], damping = _d === void 0 ? 10 : _d, _e = _a[3], velocity = _e === void 0 ? 0 : _e;\n    mass = util.clamp(mass, 0.1, 1000);\n    stiffness = util.clamp(stiffness, 0.1, 1000);\n    damping = util.clamp(damping, 0.1, 1000);\n    velocity = util.clamp(velocity, 0.1, 1000);\n    var w0 = Math.sqrt(stiffness / mass);\n    var zeta = damping / (2 * Math.sqrt(stiffness * mass));\n    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;\n    var a = 1;\n    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;\n    var progress = duration ? (duration * t) / 1000 : t;\n    if (zeta < 1) {\n        progress =\n            Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));\n    }\n    else {\n        progress = (a + b * progress) * Math.exp(-progress * w0);\n    }\n    if (t === 0 || t === 1)\n        return t;\n    return 1 - progress;\n};\n/**\n * Cache the durations at set easing parameters\n */\n// export const EasingDurationCache: Map<string | TypeEasingFunction, number> = new Map();\n/**\n * The threshold for an infinite loop\n */\n// const INTINITE_LOOP_LIMIT = 10000;\n/** Convert easing parameters to Array of numbers, e.g. \"spring(2, 500)\" to [2, 500] */\n// export const parseEasingParameters = (str: string) => {\n//   const match = /(\\(|\\s)([^)]+)\\)?/.exec(str);\n//   return match\n//     ? match[2].split(',').map((value) => {\n//         const num = parseFloat(value);\n//         return !Number.isNaN(num) ? num : value.trim();\n//       })\n//     : [];\n// };\n/**\n * The spring easing function will only look smooth at certain durations, with certain parameters.\n * This functions returns the optimal duration to create a smooth springy animation based on physics\n *\n * Note: it can also be used to determine the optimal duration of other types of easing function, but be careful of 'in-'\n * easing functions, because of the nature of the function it can sometimes create an infinite loop, I suggest only using\n * `getEasingDuration` for `spring`, specifically 'out-spring' and 'spring'\n */\n// export const getEasingDuration = (easing: string | TypeEasingFunction = 'spring') => {\n//   if (EasingDurationCache.has(easing)) return EasingDurationCache.get(easing);\n//   // eslint-disable-next-line @typescript-eslint/no-use-before-define\n//   const easingFunction = typeof easing == 'function' ? easing : getEasingFunction(easing as string);\n//   const params = typeof easing == 'function' ? [] : parseEasingParameters(easing);\n//   const frame = 1 / 6;\n//   let elapsed = 0;\n//   let rest = 0;\n//   let count = 0;\n//   while (++count < INTINITE_LOOP_LIMIT) {\n//     elapsed += frame;\n//     if (easingFunction(elapsed, params, undefined) === 1) {\n//       rest++;\n//       if (rest >= 16) break;\n//     } else {\n//       rest = 0;\n//     }\n//   }\n//   const duration = elapsed * frame * 1000;\n//   EasingDurationCache.set(easing, duration);\n//   return duration;\n// };\n/**\n  These Easing Functions are based off of the Sozi Project's easing functions\n  https://github.com/sozi-projects/Sozi/blob/d72e44ebd580dc7579d1e177406ad41e632f961d/src/js/player/Timing.js\n*/\nvar Steps = function (t, params) {\n    if (params === void 0) { params = []; }\n    var _a = tslib.__read(params, 2), _b = _a[0], steps = _b === void 0 ? 10 : _b, type = _a[1];\n    var trunc = type == 'start' ? Math.ceil : Math.floor;\n    return trunc(util.clamp(t, 0, 1) * steps) / steps;\n};\n// @ts-ignore\nvar Bezier = function (t, params) {\n    if (params === void 0) { params = []; }\n    var _a = tslib.__read(params, 4), mX1 = _a[0], mY1 = _a[1], mX2 = _a[2], mY2 = _a[3];\n    return bezier(mX1, mY1, mX2, mY2)(t);\n};\n/** The default `ease-in` easing function */\nvar easein = bezier(0.42, 0.0, 1.0, 1.0);\n/** Converts easing functions to their `out`counter parts */\nvar EaseOut = function (ease) {\n    return function (t, params, duration) {\n        if (params === void 0) { params = []; }\n        return 1 - ease(1 - t, params, duration);\n    };\n};\n/** Converts easing functions to their `in-out` counter parts */\nvar EaseInOut = function (ease) {\n    return function (t, params, duration) {\n        if (params === void 0) { params = []; }\n        return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;\n    };\n};\n/** Converts easing functions to their `out-in` counter parts */\nvar EaseOutIn = function (ease) {\n    return function (t, params, duration) {\n        if (params === void 0) { params = []; }\n        return t < 0.5\n            ? (1 - ease(1 - t * 2, params, duration)) / 2\n            : (ease(t * 2 - 1, params, duration) + 1) / 2;\n    };\n};\nvar EasingFunctions = {\n    steps: Steps,\n    'step-start': function (t) { return Steps(t, [1, 'start']); },\n    'step-end': function (t) { return Steps(t, [1, 'end']); },\n    linear: function (t) { return t; },\n    'cubic-bezier': Bezier,\n    ease: function (t) { return Bezier(t, [0.25, 0.1, 0.25, 1.0]); },\n    in: easein,\n    out: EaseOut(easein),\n    'in-out': EaseInOut(easein),\n    'out-in': EaseOutIn(easein),\n    'in-quad': Quad,\n    'out-quad': EaseOut(Quad),\n    'in-out-quad': EaseInOut(Quad),\n    'out-in-quad': EaseOutIn(Quad),\n    'in-cubic': Cubic,\n    'out-cubic': EaseOut(Cubic),\n    'in-out-cubic': EaseInOut(Cubic),\n    'out-in-cubic': EaseOutIn(Cubic),\n    'in-quart': Quart,\n    'out-quart': EaseOut(Quart),\n    'in-out-quart': EaseInOut(Quart),\n    'out-in-quart': EaseOutIn(Quart),\n    'in-quint': Quint,\n    'out-quint': EaseOut(Quint),\n    'in-out-quint': EaseInOut(Quint),\n    'out-in-quint': EaseOutIn(Quint),\n    'in-expo': Expo,\n    'out-expo': EaseOut(Expo),\n    'in-out-expo': EaseInOut(Expo),\n    'out-in-expo': EaseOutIn(Expo),\n    'in-sine': Sine,\n    'out-sine': EaseOut(Sine),\n    'in-out-sine': EaseInOut(Sine),\n    'out-in-sine': EaseOutIn(Sine),\n    'in-circ': Circ,\n    'out-circ': EaseOut(Circ),\n    'in-out-circ': EaseInOut(Circ),\n    'out-in-circ': EaseOutIn(Circ),\n    'in-back': Back,\n    'out-back': EaseOut(Back),\n    'in-out-back': EaseInOut(Back),\n    'out-in-back': EaseOutIn(Back),\n    'in-bounce': Bounce,\n    'out-bounce': EaseOut(Bounce),\n    'in-out-bounce': EaseInOut(Bounce),\n    'out-in-bounce': EaseOutIn(Bounce),\n    'in-elastic': Elastic,\n    'out-elastic': EaseOut(Elastic),\n    'in-out-elastic': EaseInOut(Elastic),\n    'out-in-elastic': EaseOutIn(Elastic),\n    spring: Spring,\n    'spring-in': Spring,\n    'spring-out': EaseOut(Spring),\n    'spring-in-out': EaseInOut(Spring),\n    'spring-out-in': EaseOutIn(Spring),\n};\n/**\n * Convert string easing to their proper form\n */\nvar complexEasingSyntax = function (ease) {\n    return convertToDash(ease)\n        .replace(/^ease-/, '') // Remove the \"ease-\" keyword\n        .replace(/(\\(|\\s).+/, '') // Remove the function brackets and parameters\n        .toLowerCase()\n        .trim();\n};\n/** Re-maps a number from one range to another. Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. */\nvar getEasingFunction = function (ease) {\n    return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;\n};\n// /**\n//  * Allows you to register new easing functions\n//  */\n// export const registerEasingFunction = (key: string, fn: TypeEasingFunction) => {\n//   Object.assign(EasingFunctions, {\n//     [key]: fn,\n//   });\n// };\n// /**\n//  * Allows you to register multiple new easing functions\n//  */\n// export const registerEasingFunctions = (...obj: typeof EasingFunctions[]) => {\n//   Object.assign(EasingFunctions, ...obj);\n// };\n\nvar linear = function (x) {\n    return x;\n};\nvar Start = 1;\nvar Middle = 0.5;\nvar End = 0;\nfunction step(count, pos) {\n    return function (x) {\n        if (x >= 1) {\n            return 1;\n        }\n        var stepSize = 1 / count;\n        x += pos * stepSize;\n        return x - (x % stepSize);\n    };\n}\nvar numberString = '\\\\s*(-?\\\\d+\\\\.?\\\\d*|-?\\\\.\\\\d+)\\\\s*';\nvar cubicBezierRe = new RegExp('cubic-bezier\\\\(' +\n    numberString +\n    ',' +\n    numberString +\n    ',' +\n    numberString +\n    ',' +\n    numberString +\n    '\\\\)');\nvar step1Re = /steps\\(\\s*(\\d+)\\s*\\)/;\nvar step2Re = /steps\\(\\s*(\\d+)\\s*,\\s*(start|middle|end)\\s*\\)/;\nfunction parseEasingFunction(normalizedEasing) {\n    var cubicData = cubicBezierRe.exec(normalizedEasing);\n    if (cubicData) {\n        // @ts-ignore\n        return bezier.apply(void 0, tslib.__spreadArray([], tslib.__read(cubicData.slice(1).map(Number)), false));\n    }\n    var step1Data = step1Re.exec(normalizedEasing);\n    if (step1Data) {\n        return step(Number(step1Data[1]), End);\n    }\n    var step2Data = step2Re.exec(normalizedEasing);\n    if (step2Data) {\n        // @ts-ignore\n        return step(Number(step2Data[1]), { start: Start, middle: Middle, end: End }[step2Data[2]]);\n    }\n    return getEasingFunction(normalizedEasing);\n}\nfunction calculateActiveDuration(timing) {\n    // @ts-ignore\n    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));\n}\nfunction repeatedDuration(timing) {\n    var _a;\n    // https://drafts.csswg.org/web-animations/#calculating-the-active-duration\n    if (timing.duration === 0 || timing.iterations === 0) {\n        return 0;\n    }\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration#value\n    // if (timing.duration === 'auto') {\n    //   timing.duration = 0;\n    // }\n    return (timing.duration === 'auto' ? 0 : Number(timing.duration)) * ((_a = timing.iterations) !== null && _a !== void 0 ? _a : 1);\n}\nvar PhaseNone = 0;\nvar PhaseBefore = 1;\nvar PhaseAfter = 2;\nvar PhaseActive = 3;\nfunction calculatePhase(activeDuration, localTime, timing) {\n    // https://drafts.csswg.org/web-animations/#animation-effect-phases-and-states\n    if (localTime === null) {\n        return PhaseNone;\n    }\n    var endTime = timing.endTime;\n    if (localTime < Math.min(timing.delay, endTime)) {\n        return PhaseBefore;\n    }\n    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {\n        return PhaseAfter;\n    }\n    return PhaseActive;\n}\nfunction calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-active-time\n    switch (phase) {\n        case PhaseBefore:\n            if (fillMode === 'backwards' || fillMode === 'both')\n                return 0;\n            return null;\n        case PhaseActive:\n            return localTime - delay;\n        case PhaseAfter:\n            if (fillMode === 'forwards' || fillMode === 'both')\n                return activeDuration;\n            return null;\n        case PhaseNone:\n            return null;\n    }\n}\nfunction calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-overall-progress\n    var overallProgress = iterationStart;\n    if (iterationDuration === 0) {\n        if (phase !== PhaseBefore) {\n            overallProgress += iterations;\n        }\n    }\n    else {\n        overallProgress += activeTime / iterationDuration;\n    }\n    return overallProgress;\n}\nfunction calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-simple-iteration-progress\n    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;\n    if (simpleIterationProgress === 0 &&\n        phase === PhaseAfter &&\n        iterations !== 0 &&\n        (activeTime !== 0 || iterationDuration === 0)) {\n        simpleIterationProgress = 1;\n    }\n    return simpleIterationProgress;\n}\nfunction calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-current-iteration\n    if (phase === PhaseAfter && iterations === Infinity) {\n        return Infinity;\n    }\n    if (simpleIterationProgress === 1) {\n        return Math.floor(overallProgress) - 1;\n    }\n    return Math.floor(overallProgress);\n}\nfunction calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {\n    // https://drafts.csswg.org/web-animations/#calculating-the-directed-progress\n    var currentDirection = playbackDirection;\n    if (playbackDirection !== 'normal' && playbackDirection !== 'reverse') {\n        var d = currentIteration;\n        if (playbackDirection === 'alternate-reverse') {\n            d += 1;\n        }\n        currentDirection = 'normal';\n        if (d !== Infinity && d % 2 !== 0) {\n            currentDirection = 'reverse';\n        }\n    }\n    if (currentDirection === 'normal') {\n        return simpleIterationProgress;\n    }\n    return 1 - simpleIterationProgress;\n}\nfunction calculateIterationProgress(activeDuration, localTime, timing) {\n    var phase = calculatePhase(activeDuration, localTime, timing);\n    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);\n    if (activeTime === null)\n        return null;\n    var duration = timing.duration === 'auto' ? 0 : timing.duration;\n    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);\n    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);\n    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);\n    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);\n    timing.currentIteration = currentIteration;\n    timing.progress = directedProgress;\n    // https://drafts.csswg.org/web-animations/#calculating-the-transformed-progress\n    // https://drafts.csswg.org/web-animations/#calculating-the-iteration-progress\n    return timing.easingFunction(directedProgress);\n}\n\nfunction convertEffectInput(keyframes, timing, target) {\n    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);\n    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);\n    return function (target, fraction) {\n        if (fraction !== null) {\n            interpolations\n                .filter(function (interpolation) {\n                return (fraction >= interpolation.applyFrom &&\n                    fraction < interpolation.applyTo);\n            })\n                .forEach(function (interpolation) {\n                var offsetFraction = fraction - interpolation.startOffset;\n                var localDuration = interpolation.endOffset - interpolation.startOffset;\n                var scaledLocalTime = localDuration === 0\n                    ? 0\n                    : interpolation.easingFunction(offsetFraction / localDuration);\n                // apply updated attribute\n                target.setAttribute(interpolation.property, interpolation.interpolation(scaledLocalTime), false, false);\n                // if (interpolation.property === 'visibility') {\n                //   console.log(\n                //     scaledLocalTime,\n                //     interpolation.interpolation(scaledLocalTime),\n                //   );\n                // }\n            });\n        }\n        else {\n            for (var property in propertySpecificKeyframeGroups)\n                if (isNotReservedWord(property)) {\n                    // clear attribute\n                    target.setAttribute(property, null);\n                }\n        }\n    };\n}\nfunction isNotReservedWord(member) {\n    return (member !== 'offset' &&\n        member !== 'easing' &&\n        member !== 'composite' &&\n        member !== 'computedOffset');\n}\nfunction makePropertySpecificKeyframeGroups(keyframes, timing) {\n    var propertySpecificKeyframeGroups = {};\n    for (var i = 0; i < keyframes.length; i++) {\n        for (var member in keyframes[i]) {\n            if (isNotReservedWord(member)) {\n                var propertySpecificKeyframe = {\n                    offset: keyframes[i].offset,\n                    computedOffset: keyframes[i].computedOffset,\n                    easing: keyframes[i].easing,\n                    easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,\n                    value: keyframes[i][member],\n                };\n                propertySpecificKeyframeGroups[member] =\n                    propertySpecificKeyframeGroups[member] || [];\n                propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);\n            }\n        }\n    }\n    return propertySpecificKeyframeGroups;\n}\nfunction makeInterpolations(propertySpecificKeyframeGroups, target) {\n    var interpolations = [];\n    for (var groupName in propertySpecificKeyframeGroups) {\n        var keyframes = propertySpecificKeyframeGroups[groupName];\n        for (var i = 0; i < keyframes.length - 1; i++) {\n            var startIndex = i;\n            var endIndex = i + 1;\n            var startOffset = keyframes[startIndex].computedOffset;\n            var endOffset = keyframes[endIndex].computedOffset;\n            var applyFrom = startOffset;\n            var applyTo = endOffset;\n            if (i === 0) {\n                applyFrom = -Infinity;\n                if (endOffset === 0) {\n                    endIndex = startIndex;\n                }\n            }\n            if (i === keyframes.length - 2) {\n                applyTo = Infinity;\n                if (startOffset === 1) {\n                    startIndex = endIndex;\n                }\n            }\n            interpolations.push({\n                applyFrom: applyFrom,\n                applyTo: applyTo,\n                startOffset: keyframes[startIndex].computedOffset,\n                endOffset: keyframes[endIndex].computedOffset,\n                easingFunction: keyframes[startIndex].easingFunction,\n                property: groupName,\n                interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target),\n            });\n        }\n    }\n    interpolations.sort(function (leftInterpolation, rightInterpolation) {\n        return leftInterpolation.startOffset - rightInterpolation.startOffset;\n    });\n    return interpolations;\n}\nvar InterpolationFactory = function (from, to, \n// eslint-disable-next-line @typescript-eslint/ban-types\nconvertToString) {\n    return function (f) {\n        var interpolated = interpolate(from, to, f);\n        return !gLite.runtime.enableCSSParsing && util.isNumber(interpolated)\n            ? interpolated\n            : convertToString(interpolated);\n    };\n};\nfunction propertyInterpolation(property, left, right, target) {\n    var metadata = gLite.propertyMetadataCache[property];\n    // discrete step\n    // if (property === 'visibility') {\n    //   return function (t: number) {\n    //     if (t === 0) return left;\n    //     if (t === 1) return right;\n    //     debugger;\n    //     return t < 0.5 ? left : right;\n    //   };\n    // }\n    if (metadata && metadata.syntax && metadata.int) {\n        var propertyHandler = gLite.runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);\n        if (propertyHandler) {\n            var usedLeft = void 0;\n            var usedRight = void 0;\n            if (gLite.runtime.enableCSSParsing) {\n                var computedLeft = gLite.runtime.styleValueRegistry.parseProperty(property, left, target, false);\n                var computedRight = gLite.runtime.styleValueRegistry.parseProperty(property, right, target, false);\n                usedLeft = gLite.runtime.styleValueRegistry.computeProperty(property, computedLeft, target, false);\n                usedRight = gLite.runtime.styleValueRegistry.computeProperty(property, computedRight, target, false);\n            }\n            else {\n                var parser = propertyHandler.parserWithCSSDisabled;\n                usedLeft = parser ? parser(left, target) : left;\n                usedRight = parser ? parser(right, target) : right;\n            }\n            // merger [left, right, n2string()]\n            var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);\n            if (interpolationArgs) {\n                var interp_1 = InterpolationFactory.apply(void 0, tslib.__spreadArray([], tslib.__read(interpolationArgs), false));\n                return function (t) {\n                    if (t === 0)\n                        return left;\n                    if (t === 1)\n                        return right;\n                    return interp_1(t);\n                };\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return InterpolationFactory(false, true, function (bool) {\n        return bool ? right : left;\n    });\n}\n/**\n * interpolate with number, boolean, number[], boolean[]\n */\nfunction interpolate(from, to, f) {\n    if (typeof from === 'number' && typeof to === 'number') {\n        return from * (1 - f) + to * f;\n    }\n    if ((typeof from === 'boolean' && typeof to === 'boolean') ||\n        (typeof from === 'string' && typeof to === 'string') // skip string, eg. path ['M', 10, 10]\n    ) {\n        return f < 0.5 ? from : to;\n    }\n    if (Array.isArray(from) && Array.isArray(to)) {\n        // interpolate arrays/matrix\n        var fromLength = from.length;\n        var toLength = to.length;\n        var length_1 = Math.max(fromLength, toLength);\n        var r = [];\n        for (var i = 0; i < length_1; i++) {\n            r.push(interpolate(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));\n        }\n        return r;\n    }\n    throw new Error('Mismatched interpolation arguments ' + from + ':' + to);\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming\n */\nvar AnimationEffectTiming = /** @class */ (function () {\n    function AnimationEffectTiming() {\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/delay\n         */\n        this.delay = 0;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/direction\n         */\n        this.direction = 'normal';\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration\n         */\n        this.duration = 'auto';\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing\n         */\n        this._easing = 'linear';\n        this.easingFunction = linear;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay\n         */\n        this.endDelay = 0;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill\n         */\n        this.fill = 'auto';\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterationStart\n         */\n        this.iterationStart = 0;\n        /**\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterations\n         */\n        this.iterations = 1;\n        this.currentIteration = null;\n        this.progress = null;\n    }\n    Object.defineProperty(AnimationEffectTiming.prototype, \"easing\", {\n        get: function () {\n            return this._easing;\n        },\n        set: function (value) {\n            this.easingFunction = parseEasingFunction(value);\n            this._easing = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return AnimationEffectTiming;\n}());\n\n/**\n * @example\n  {\n    translateY: [200, 300],\n    scale: [1, 10],\n  }\n\n * groups' length can be different, the following config should generate 3 frames:\n  @example\n  {\n    translateY: [200, 300, 400],\n    scale: [1, 10],\n  }\n */\nfunction convertToArrayForm(effectInput) {\n    var normalizedEffectInput = [];\n    for (var property in effectInput) {\n        // skip reserved props\n        if (property in ['easing', 'offset', 'composite']) {\n            continue;\n        }\n        // @ts-ignore\n        var values = effectInput[property];\n        if (!Array.isArray(values)) {\n            values = [values];\n        }\n        var numKeyframes = values.length;\n        for (var i = 0; i < numKeyframes; i++) {\n            if (!normalizedEffectInput[i]) {\n                var keyframe = {};\n                if ('offset' in effectInput) {\n                    keyframe.offset = Number(effectInput.offset);\n                }\n                if ('easing' in effectInput) {\n                    // @ts-ignore\n                    keyframe.easing = effectInput.easing;\n                }\n                if ('composite' in effectInput) {\n                    // @ts-ignore\n                    keyframe.composite = effectInput.composite;\n                }\n                normalizedEffectInput[i] = keyframe;\n            }\n            if (values[i] !== undefined && values[i] !== null) {\n                normalizedEffectInput[i][property] = values[i];\n            }\n        }\n    }\n    normalizedEffectInput.sort(function (a, b) {\n        return (a.computedOffset || 0) - (b.computedOffset || 0);\n    });\n    return normalizedEffectInput;\n}\nfunction normalizeKeyframes(effectInput, timing) {\n    if (effectInput === null) {\n        return [];\n    }\n    if (!Array.isArray(effectInput)) {\n        effectInput = convertToArrayForm(effectInput);\n    }\n    var keyframes = effectInput.map(function (originalKeyframe) {\n        var keyframe = {};\n        if (timing === null || timing === void 0 ? void 0 : timing.composite) {\n            // This will be auto if the composite operation specified on the effect is being used.\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats\n            keyframe.composite = 'auto';\n        }\n        for (var member in originalKeyframe) {\n            var memberValue = originalKeyframe[member];\n            if (member === 'offset') {\n                if (memberValue !== null) {\n                    memberValue = Number(memberValue);\n                    if (!isFinite(memberValue))\n                        throw new Error('Keyframe offsets must be numbers.');\n                    if (memberValue < 0 || memberValue > 1)\n                        throw new Error('Keyframe offsets must be between 0 and 1.');\n                    keyframe.computedOffset = memberValue;\n                }\n            }\n            else if (member === 'composite') {\n                // TODO: Support add & accumulate in KeyframeEffect.composite\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/composite\n                if (['replace', 'add', 'accumulate', 'auto'].indexOf(memberValue) === -1) {\n                    throw new Error(\"\".concat(memberValue, \" compositing is not supported\"));\n                }\n            }\n            else ;\n            // assign to keyframe, no need to parse shorthand value\n            keyframe[member] = memberValue;\n        }\n        if (keyframe.offset === undefined) {\n            keyframe.offset = null;\n        }\n        if (keyframe.easing === undefined) {\n            // override with timing.easing\n            keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || 'linear';\n        }\n        if (keyframe.composite === undefined) {\n            keyframe.composite = 'auto';\n        }\n        return keyframe;\n    });\n    var everyFrameHasOffset = true;\n    var previousOffset = -Infinity;\n    for (var i = 0; i < keyframes.length; i++) {\n        var offset = keyframes[i].offset;\n        if (!util.isNil(offset)) {\n            if (offset < previousOffset) {\n                throw new TypeError('Keyframes are not loosely sorted by offset. Sort or specify offsets.');\n            }\n            previousOffset = offset;\n        }\n        else {\n            everyFrameHasOffset = false;\n        }\n    }\n    keyframes = keyframes.filter(function (keyframe) {\n        return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;\n    });\n    function spaceKeyframes() {\n        var _a, _b;\n        var length = keyframes.length;\n        keyframes[length - 1].computedOffset = Number((_a = keyframes[length - 1].offset) !== null && _a !== void 0 ? _a : 1);\n        if (length > 1) {\n            keyframes[0].computedOffset = Number((_b = keyframes[0].offset) !== null && _b !== void 0 ? _b : 0);\n        }\n        var previousIndex = 0;\n        var previousOffset = Number(keyframes[0].computedOffset);\n        for (var i = 1; i < length; i++) {\n            var offset = keyframes[i].computedOffset;\n            if (!util.isNil(offset) && !util.isNil(previousOffset)) {\n                for (var j = 1; j < i - previousIndex; j++)\n                    keyframes[previousIndex + j].computedOffset =\n                        previousOffset + ((Number(offset) - previousOffset) * j) / (i - previousIndex);\n                previousIndex = i;\n                previousOffset = Number(offset);\n            }\n        }\n    }\n    if (!everyFrameHasOffset)\n        spaceKeyframes();\n    return keyframes;\n}\n\nvar fills = 'backwards|forwards|both|none'.split('|');\nvar directions = 'reverse|alternate|alternate-reverse'.split('|');\nfunction makeTiming(timingInput, forGroup) {\n    var timing = new AnimationEffectTiming();\n    if (forGroup) {\n        timing.fill = 'both';\n        timing.duration = 'auto';\n    }\n    if (typeof timingInput === 'number' && !isNaN(timingInput)) {\n        timing.duration = timingInput;\n    }\n    else if (timingInput !== undefined) {\n        Object.keys(timingInput).forEach(function (property) {\n            if (timingInput[property] !== undefined &&\n                timingInput[property] !== null &&\n                timingInput[property] !== 'auto') {\n                if (typeof timing[property] === 'number' || property === 'duration') {\n                    if (typeof timingInput[property] !== 'number' ||\n                        isNaN(timingInput[property])) {\n                        return;\n                    }\n                }\n                if (property === 'fill' &&\n                    fills.indexOf(timingInput[property]) === -1) {\n                    return;\n                }\n                if (property === 'direction' &&\n                    directions.indexOf(timingInput[property]) === -1) {\n                    return;\n                }\n                // @ts-ignore\n                timing[property] = timingInput[property];\n            }\n        });\n    }\n    return timing;\n}\nfunction normalizeTimingInput(timingInput, forGroup) {\n    timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : { duration: 'auto' });\n    return makeTiming(timingInput, forGroup);\n}\nfunction numericTimingToObject(timingInput) {\n    if (typeof timingInput === 'number') {\n        if (isNaN(timingInput)) {\n            timingInput = { duration: 'auto' };\n        }\n        else {\n            timingInput = { duration: timingInput };\n        }\n    }\n    return timingInput;\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect\n * @example\n  const circleDownKeyframes = new KeyframeEffect(\n    circle, // element to animate\n    [\n      { transform: 'translateY(0)' }, // keyframe\n      { transform: 'translateY(100)' } // keyframe\n    ],\n    { duration: 3000, fill: 'forwards' } // keyframe options\n  );\n *\n */\nvar KeyframeEffect = /** @class */ (function () {\n    function KeyframeEffect(target, effectInput, timingInput) {\n        var _this = this;\n        this.composite = 'replace';\n        this.iterationComposite = 'replace';\n        this.target = target;\n        this.timing = normalizeTimingInput(timingInput, false);\n        this.timing.effect = this;\n        this.timing.activeDuration = calculateActiveDuration(this.timing);\n        this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);\n        this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);\n        this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);\n        // 不支持 proxy 时降级成 this.timing\n        var Proxy = gLite.runtime.globalThis.Proxy;\n        this.computedTiming = Proxy\n            ? new Proxy(this.timing, {\n                get: function (target, prop) {\n                    if (prop === 'duration') {\n                        return target.duration === 'auto' ? 0 : target.duration;\n                    }\n                    else if (prop === 'fill') {\n                        return target.fill === 'auto' ? 'none' : target.fill;\n                    }\n                    else if (prop === 'localTime') {\n                        return (_this.animation && _this.animation.currentTime) || null;\n                    }\n                    else if (prop === 'currentIteration') {\n                        if (!_this.animation || _this.animation.playState !== 'running') {\n                            return null;\n                        }\n                        return target.currentIteration || 0;\n                    }\n                    else if (prop === 'progress') {\n                        if (!_this.animation || _this.animation.playState !== 'running') {\n                            return null;\n                        }\n                        return target.progress || 0;\n                    }\n                    return target[prop];\n                },\n                set: function () {\n                    return true;\n                },\n            })\n            : this.timing;\n    }\n    KeyframeEffect.prototype.applyInterpolations = function () {\n        this.interpolations(this.target, Number(this.timeFraction));\n    };\n    KeyframeEffect.prototype.update = function (localTime) {\n        if (localTime === null) {\n            return false;\n        }\n        this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);\n        return this.timeFraction !== null;\n    };\n    KeyframeEffect.prototype.getKeyframes = function () {\n        return this.normalizedKeyframes;\n    };\n    KeyframeEffect.prototype.setKeyframes = function (keyframes) {\n        this.normalizedKeyframes = normalizeKeyframes(keyframes);\n    };\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming\n     */\n    KeyframeEffect.prototype.getComputedTiming = function () {\n        return this.computedTiming;\n    };\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming\n     */\n    KeyframeEffect.prototype.getTiming = function () {\n        return this.timing;\n    };\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming\n     */\n    KeyframeEffect.prototype.updateTiming = function (timing) {\n        var _this = this;\n        Object.keys(timing || {}).forEach(function (name) {\n            _this.timing[name] = timing[name];\n        });\n    };\n    return KeyframeEffect;\n}());\n\nfunction compareAnimations(leftAnimation, rightAnimation) {\n    return Number(leftAnimation.id) - Number(rightAnimation.id);\n}\n/**\n * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/web-animations-js/index.d.ts\n */\nvar AnimationTimeline = /** @class */ (function () {\n    function AnimationTimeline(document) {\n        var _this = this;\n        this.document = document;\n        /**\n         * all active animations\n         */\n        this.animations = [];\n        this.ticking = false;\n        this.timelineTicking = false;\n        this.hasRestartedThisFrame = false;\n        this.animationsWithPromises = [];\n        this.inTick = false;\n        this.pendingEffects = [];\n        this.currentTime = null;\n        this.rafId = 0;\n        this.rafCallbacks = [];\n        this.webAnimationsNextTick = function (t) {\n            _this.currentTime = t;\n            _this.discardAnimations();\n            if (_this.animations.length === 0) {\n                _this.timelineTicking = false;\n            }\n            else {\n                _this.requestAnimationFrame(_this.webAnimationsNextTick);\n            }\n        };\n        this.processRafCallbacks = function (t) {\n            var processing = _this.rafCallbacks;\n            _this.rafCallbacks = [];\n            if (t < Number(_this.currentTime))\n                t = Number(_this.currentTime);\n            _this.animations.sort(compareAnimations);\n            _this.animations = _this.tick(t, true, _this.animations)[0];\n            processing.forEach(function (entry) {\n                entry[1](t);\n            });\n            _this.applyPendingEffects();\n        };\n    }\n    AnimationTimeline.prototype.getAnimations = function () {\n        this.discardAnimations();\n        return this.animations.slice();\n    };\n    AnimationTimeline.prototype.isTicking = function () {\n        return this.inTick;\n    };\n    AnimationTimeline.prototype.play = function (target, keyframes, options) {\n        var effect = new KeyframeEffect(target, keyframes, options);\n        var animation = new Animation(effect, this);\n        this.animations.push(animation);\n        this.restartWebAnimationsNextTick();\n        animation.updatePromises();\n        animation.play();\n        animation.updatePromises();\n        return animation;\n    };\n    // RAF is supposed to be the last script to occur before frame rendering but not\n    // all browsers behave like this. This function is for synchonously updating an\n    // animation's effects whenever its state is mutated by script to work around\n    // incorrect script execution ordering by the browser.\n    AnimationTimeline.prototype.applyDirtiedAnimation = function (animation) {\n        var _this = this;\n        if (this.inTick) {\n            return;\n        }\n        // update active animations in displayobject\n        animation.markTarget();\n        var animations = animation.targetAnimations();\n        animations.sort(compareAnimations);\n        // clear inactive animations\n        var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];\n        inactiveAnimations.forEach(function (animation) {\n            var index = _this.animations.indexOf(animation);\n            if (index !== -1) {\n                _this.animations.splice(index, 1);\n            }\n        });\n        this.applyPendingEffects();\n    };\n    AnimationTimeline.prototype.restart = function () {\n        if (!this.ticking) {\n            this.ticking = true;\n            this.requestAnimationFrame(function () { });\n            this.hasRestartedThisFrame = true;\n        }\n        return this.hasRestartedThisFrame;\n    };\n    AnimationTimeline.prototype.destroy = function () {\n        this.document.defaultView.cancelAnimationFrame(this.frameId);\n    };\n    AnimationTimeline.prototype.applyPendingEffects = function () {\n        this.pendingEffects.forEach(function (effect) {\n            effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();\n        });\n        this.pendingEffects = [];\n    };\n    AnimationTimeline.prototype.updateAnimationsPromises = function () {\n        this.animationsWithPromises = this.animationsWithPromises.filter(function (animation) {\n            return animation.updatePromises();\n        });\n    };\n    AnimationTimeline.prototype.discardAnimations = function () {\n        this.updateAnimationsPromises();\n        this.animations = this.animations.filter(function (animation) {\n            return animation.playState !== 'finished' && animation.playState !== 'idle';\n        });\n    };\n    AnimationTimeline.prototype.restartWebAnimationsNextTick = function () {\n        if (!this.timelineTicking) {\n            this.timelineTicking = true;\n            this.requestAnimationFrame(this.webAnimationsNextTick);\n        }\n    };\n    AnimationTimeline.prototype.rAF = function (f) {\n        var id = this.rafId++;\n        if (this.rafCallbacks.length === 0) {\n            this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);\n        }\n        this.rafCallbacks.push([id, f]);\n        return id;\n    };\n    AnimationTimeline.prototype.requestAnimationFrame = function (f) {\n        var _this = this;\n        return this.rAF(function (x) {\n            _this.updateAnimationsPromises();\n            f(x);\n            _this.updateAnimationsPromises();\n        });\n    };\n    AnimationTimeline.prototype.tick = function (t, isAnimationFrame, updatingAnimations) {\n        var _a, _b;\n        var _this = this;\n        this.inTick = true;\n        this.hasRestartedThisFrame = false;\n        this.currentTime = t;\n        this.ticking = false;\n        var newPendingClears = [];\n        var newPendingEffects = [];\n        var activeAnimations = [];\n        var inactiveAnimations = [];\n        updatingAnimations.forEach(function (animation) {\n            animation.tick(t, isAnimationFrame);\n            if (!animation._inEffect) {\n                newPendingClears.push(animation.effect);\n                animation.unmarkTarget();\n            }\n            else {\n                newPendingEffects.push(animation.effect);\n                animation.markTarget();\n            }\n            if (animation._needsTick)\n                _this.ticking = true;\n            var alive = animation._inEffect || animation._needsTick;\n            animation._inTimeline = alive;\n            if (alive) {\n                activeAnimations.push(animation);\n            }\n            else {\n                inactiveAnimations.push(animation);\n            }\n        });\n        (_a = this.pendingEffects).push.apply(_a, tslib.__spreadArray([], tslib.__read(newPendingClears), false));\n        (_b = this.pendingEffects).push.apply(_b, tslib.__spreadArray([], tslib.__read(newPendingEffects), false));\n        if (this.ticking)\n            this.requestAnimationFrame(function () { });\n        this.inTick = false;\n        return [activeAnimations, inactiveAnimations];\n    };\n    return AnimationTimeline;\n}());\n\ngLite.runtime.EasingFunction = parseEasingFunction;\ngLite.runtime.AnimationTimeline = AnimationTimeline;\n\nexports.Animation = Animation;\nexports.AnimationEvent = AnimationEvent;\nexports.AnimationTimeline = AnimationTimeline;\nexports.EasingFunctions = EasingFunctions;\nexports.KeyframeEffect = KeyframeEffect;\nexports.compareAnimations = compareAnimations;\nexports.makeTiming = makeTiming;\nexports.normalizeKeyframes = normalizeKeyframes;\nexports.normalizeTimingInput = normalizeTimingInput;\nexports.numericTimingToObject = numericTimingToObject;\n//# sourceMappingURL=index.js.map\n"]}