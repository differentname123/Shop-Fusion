{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\nvar util = require('@antv/util');\nvar gDeviceApi = require('@antv/g-device-api');\nvar glMatrix = require('gl-matrix');\nvar EventEmitter = require('eventemitter3');\nvar earcut = require('earcut');\nvar gMath = require('@antv/g-math');\n\nvar Renderable3D = /** @class */ (function () {\n    function Renderable3D() {\n        this.drawcalls = [];\n    }\n    Renderable3D.tag = 'c-renderable-3d';\n    return Renderable3D;\n}());\n\nvar LightPool = /** @class */ (function () {\n    function LightPool() {\n        /**\n         * lights\n         */\n        this.lights = [];\n    }\n    LightPool.prototype.addLight = function (light) {\n        this.lights.push(light);\n        this.sortLights();\n    };\n    LightPool.prototype.removeLight = function (light) {\n        var i = this.lights.indexOf(light);\n        this.lights.splice(i, 1);\n        this.sortLights();\n    };\n    LightPool.prototype.addFog = function (fog) {\n        this.fog = fog;\n    };\n    LightPool.prototype.removeFog = function (fog) {\n        this.fog = null;\n    };\n    LightPool.prototype.getFog = function () {\n        return this.fog;\n    };\n    LightPool.prototype.getAllLights = function () {\n        return this.lights;\n    };\n    /**\n     * USE_LIGHT\n     * NUM_AMBIENT_LIGHTS\n     * NUM_DIR_LIGHTS\n     */\n    LightPool.prototype.getDefines = function () {\n        var defines = {\n            USE_LIGHT: !!this.lights.length,\n        };\n        this.lights.forEach(function (light) {\n            if (!defines[light.define]) {\n                defines[light.define] = 0;\n            }\n            defines[light.define]++;\n        });\n        return defines;\n    };\n    LightPool.prototype.sortLights = function () {\n        this.lights.sort(function (a, b) { return a.order - b.order; });\n    };\n    return LightPool;\n}());\n\nvar Mesh = /** @class */ (function (_super) {\n    tslib.__extends(Mesh, _super);\n    function Mesh(_a) {\n        var _this = this;\n        var style = _a.style, rest = tslib.__rest(_a, [\"style\"]);\n        _this = _super.call(this, tslib.__assign({ type: gLite.Shape.MESH, style: tslib.__assign({ x: '', y: '', z: '', lineWidth: 0, anchor: [0.5, 0.5, 0.5] }, style) }, rest)) || this;\n        _this.cullable.enable = false;\n        _this.style.geometry.meshes.push(_this);\n        _this.style.material.meshes.push(_this);\n        return _this;\n    }\n    // getVertexBufferData(bufferIndex: number) {\n    //   return this.style.geometry.vertexBuffers[bufferIndex];\n    // }\n    // setVertexBufferData(descriptor: {\n    //   bufferIndex: number;\n    //   byteOffset: number;\n    //   data: ArrayBufferView;\n    // }) {}\n    Mesh.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        // detach from geometry\n        var meshes = this.style.geometry.meshes;\n        var index = meshes.indexOf(this);\n        meshes.splice(index, 1);\n        // detach from material\n        meshes = this.style.material.meshes;\n        index = meshes.indexOf(this);\n        meshes.splice(index, 1);\n    };\n    return Mesh;\n}(gLite.DisplayObject));\n\nvar MeshUpdater = /** @class */ (function () {\n    function MeshUpdater() {\n    }\n    MeshUpdater.prototype.update = function (parsedStyle) {\n        var geometry = parsedStyle.geometry;\n        var aabb = geometry.computeBoundingBox();\n        var max = aabb.getMax();\n        var min = aabb.getMin();\n        var width = max[0] - min[0];\n        var height = max[1] - min[1];\n        var depth = max[2] - min[2];\n        return {\n            width: width,\n            height: height,\n            depth: depth,\n        };\n    };\n    return MeshUpdater;\n}());\n\nvar PickingIdGenerator = /** @class */ (function () {\n    function PickingIdGenerator() {\n        this.counter = 0;\n        this.id2DisplayObjectMap = {};\n    }\n    PickingIdGenerator.prototype.getId = function (displayObject) {\n        var id = this.counter++;\n        this.id2DisplayObjectMap[id] = displayObject;\n        return id;\n    };\n    PickingIdGenerator.prototype.getById = function (id) {\n        return this.id2DisplayObjectMap[id];\n    };\n    PickingIdGenerator.prototype.deleteById = function (id) {\n        delete this.id2DisplayObjectMap[id];\n    };\n    PickingIdGenerator.prototype.reset = function () {\n        this.counter = 0;\n        this.id2DisplayObjectMap = {};\n    };\n    PickingIdGenerator.prototype.decodePickingColor = function (color) {\n        var _a = tslib.__read(color, 3), i1 = _a[0], i2 = _a[1], i3 = _a[2];\n        var index = i1 + i2 * 256 + i3 * 65536 - 1;\n        return index;\n    };\n    PickingIdGenerator.prototype.encodePickingColor = function (featureIdx) {\n        return [\n            (featureIdx + 1) & 255,\n            ((featureIdx + 1) >> 8) & 255,\n            (((featureIdx + 1) >> 8) >> 8) & 255,\n        ];\n    };\n    return PickingIdGenerator;\n}());\n\nvar DeviceProgram = /** @class */ (function () {\n    function DeviceProgram() {\n        this.name = '(unnamed)';\n        // Compiled program.\n        this.preprocessedVert = '';\n        this.preprocessedFrag = '';\n        // Inputs.\n        this.both = '';\n        this.vert = '';\n        this.frag = '';\n        this.defines = {};\n    }\n    DeviceProgram.prototype.definesChanged = function () {\n        this.preprocessedVert = '';\n        this.preprocessedFrag = '';\n    };\n    DeviceProgram.prototype.setDefineString = function (name, v) {\n        if (v !== null) {\n            if (this.defines[name] === v)\n                return false;\n            this.defines[name] = v;\n        }\n        else {\n            if (util.isNil(this.defines[name]))\n                return false;\n            delete this.defines[name];\n        }\n        this.definesChanged();\n        return true;\n    };\n    DeviceProgram.prototype.setDefineBool = function (name, v) {\n        return this.setDefineString(name, v ? '1' : null);\n    };\n    DeviceProgram.prototype.getDefineString = function (name) {\n        return gDeviceApi.nullify(this.defines[name]);\n    };\n    DeviceProgram.prototype.getDefineBool = function (name) {\n        var str = this.getDefineString(name);\n        if (str !== null)\n            gDeviceApi.assert(str === '1');\n        return str !== null;\n    };\n    return DeviceProgram;\n}());\n\n// This is a very basic linear allocator. We allocate offsets in-order.\nvar DynamicUniformBuffer = /** @class */ (function () {\n    function DynamicUniformBuffer(device) {\n        /**\n         * Word count, 4 bytes per word\n         */\n        this.currentBufferWordSize = -1;\n        this.currentWordOffset = 0;\n        this.buffer = null;\n        this.shadowBufferF32 = null;\n        this.shadowBufferU8 = null;\n        this.device = device;\n        var limits = device.queryLimits();\n        this.uniformBufferWordAlignment = limits.uniformBufferWordAlignment;\n        this.uniformBufferMaxPageWordSize = limits.uniformBufferMaxPageWordSize;\n    }\n    DynamicUniformBuffer.prototype.isSupportedUBO = function () {\n        // UBO not supported in WebGL1\n        return this.device.queryVendorInfo().platformString !== 'WebGL1';\n    };\n    DynamicUniformBuffer.prototype.findPageIndex = function (wordOffset) {\n        return (wordOffset / this.uniformBufferMaxPageWordSize) | 0;\n    };\n    DynamicUniformBuffer.prototype.allocateChunk = function (wordCount) {\n        wordCount = gDeviceApi.alignNonPowerOfTwo(wordCount, this.uniformBufferWordAlignment);\n        gDeviceApi.assert(wordCount < this.uniformBufferMaxPageWordSize);\n        var wordOffset = this.currentWordOffset;\n        // If we straddle the page, then put it at the start of the next one.\n        if (this.findPageIndex(wordOffset) !==\n            this.findPageIndex(wordOffset + wordCount - 1))\n            wordOffset = gDeviceApi.alignNonPowerOfTwo(wordOffset, this.uniformBufferMaxPageWordSize);\n        this.currentWordOffset = wordOffset + wordCount;\n        this.ensureShadowBuffer(wordOffset, wordCount);\n        return wordOffset;\n    };\n    DynamicUniformBuffer.prototype.ensureShadowBuffer = function (wordOffset, wordCount) {\n        if (this.shadowBufferU8 === null || this.shadowBufferF32 === null) {\n            var newWordCount = gDeviceApi.alignNonPowerOfTwo(this.currentWordOffset, this.uniformBufferMaxPageWordSize);\n            this.shadowBufferU8 = new Uint8Array(newWordCount * 4);\n            this.shadowBufferF32 = new Float32Array(this.shadowBufferU8.buffer);\n        }\n        else if (wordOffset + wordCount >= this.shadowBufferF32.length) {\n            gDeviceApi.assert(wordOffset < this.currentWordOffset &&\n                wordOffset + wordCount <= this.currentWordOffset);\n            // Grow logarithmically, aligned to page size.\n            var newWordCount = gDeviceApi.alignNonPowerOfTwo(Math.max(this.currentWordOffset, this.shadowBufferF32.length * 2), this.uniformBufferMaxPageWordSize);\n            var newBuffer = new Uint8Array(newWordCount * 4);\n            newBuffer.set(this.shadowBufferU8, 0);\n            this.shadowBufferU8 = newBuffer;\n            this.shadowBufferF32 = new Float32Array(this.shadowBufferU8.buffer);\n            if (!(this.currentWordOffset <= newWordCount))\n                throw new Error(\"Assert fail: this.currentWordOffset [\".concat(this.currentWordOffset, \"] <= newWordCount [\").concat(newWordCount, \"]\"));\n        }\n    };\n    /**\n     * Return the CPU data buffer used internally. Fill this in to submit data to the CPU. Write to\n     * it with the offset that was returned from {@see allocateChunk}.\n     */\n    DynamicUniformBuffer.prototype.mapBufferF32 = function () {\n        return gDeviceApi.assertExists(this.shadowBufferF32);\n    };\n    DynamicUniformBuffer.prototype.prepareToRender = function () {\n        if (this.shadowBufferF32 === null) {\n            return;\n        }\n        var shadowBufferF32 = gDeviceApi.assertExists(this.shadowBufferF32);\n        if (shadowBufferF32.length !== this.currentBufferWordSize) {\n            this.currentBufferWordSize = shadowBufferF32.length;\n            if (this.buffer !== null) {\n                this.buffer.destroy();\n            }\n            this.buffer = this.device.createBuffer({\n                // in bytes length\n                viewOrSize: this.currentBufferWordSize * 4,\n                usage: gDeviceApi.BufferUsage.UNIFORM,\n                hint: gDeviceApi.BufferFrequencyHint.DYNAMIC,\n            });\n        }\n        var wordCount = gDeviceApi.alignNonPowerOfTwo(this.currentWordOffset, this.uniformBufferMaxPageWordSize);\n        if (!(wordCount <= this.currentBufferWordSize))\n            throw new Error(\"Assert fail: wordCount [\".concat(wordCount, \"] (\").concat(this.currentWordOffset, \" aligned \").concat(this.uniformBufferMaxPageWordSize, \") <= this.currentBufferWordSize [\").concat(this.currentBufferWordSize, \"]\"));\n        if (this.isSupportedUBO()) {\n            var buffer = gDeviceApi.assertExists(this.buffer);\n            buffer.setSubData(0, this.shadowBufferU8, 0, wordCount * 4);\n        }\n        // Reset the offset for next frame.\n        this.currentWordOffset = 0;\n    };\n    DynamicUniformBuffer.prototype.destroy = function () {\n        if (this.buffer !== null)\n            this.buffer.destroy();\n        this.shadowBufferF32 = null;\n        this.shadowBufferU8 = null;\n    };\n    return DynamicUniformBuffer;\n}());\n\n// Jenkins One-at-a-Time hash from http://www.burtleburtle.net/bob/hash/doobs.html\nfunction hashCodeNumberUpdate(hash, v) {\n    hash += v;\n    hash += hash << 10;\n    hash += hash >>> 6;\n    return hash >>> 0;\n}\nfunction hashCodeNumberFinish(hash) {\n    hash += hash << 3;\n    hash ^= hash >>> 11;\n    hash += hash << 15;\n    return hash >>> 0;\n}\n// Pass this as a hash function to use a one-bucket HashMap (equivalent to linear search in an array),\n// which can be efficient for small numbers of items.\nfunction nullHashFunc(k) {\n    return 0;\n}\nvar HashBucket = /** @class */ (function () {\n    function HashBucket() {\n        this.keys = [];\n        this.values = [];\n    }\n    return HashBucket;\n}());\nvar HashMap = /** @class */ (function () {\n    function HashMap(keyEqualFunc, keyHashFunc) {\n        this.keyEqualFunc = keyEqualFunc;\n        this.keyHashFunc = keyHashFunc;\n        this.buckets = new Map();\n    }\n    HashMap.prototype.findBucketIndex = function (bucket, k) {\n        for (var i = 0; i < bucket.keys.length; i++)\n            if (this.keyEqualFunc(k, bucket.keys[i]))\n                return i;\n        return -1;\n    };\n    HashMap.prototype.findBucket = function (k) {\n        var bw = this.keyHashFunc(k);\n        return this.buckets.get(bw);\n    };\n    HashMap.prototype.get = function (k) {\n        var bucket = this.findBucket(k);\n        if (bucket === undefined)\n            return null;\n        var bi = this.findBucketIndex(bucket, k);\n        if (bi < 0)\n            return null;\n        return bucket.values[bi];\n    };\n    HashMap.prototype.add = function (k, v) {\n        var bw = this.keyHashFunc(k);\n        if (this.buckets.get(bw) === undefined)\n            this.buckets.set(bw, new HashBucket());\n        var bucket = this.buckets.get(bw);\n        bucket.keys.push(k);\n        bucket.values.push(v);\n    };\n    HashMap.prototype.delete = function (k) {\n        var bucket = this.findBucket(k);\n        if (bucket === undefined)\n            return;\n        var bi = this.findBucketIndex(bucket, k);\n        if (bi === -1)\n            return;\n        bucket.keys.splice(bi, 1);\n        bucket.values.splice(bi, 1);\n    };\n    HashMap.prototype.clear = function () {\n        this.buckets.clear();\n    };\n    HashMap.prototype.size = function () {\n        var e_1, _a;\n        var acc = 0;\n        try {\n            for (var _b = tslib.__values(this.buckets.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var bucket = _c.value;\n                acc += bucket.values.length;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return acc;\n    };\n    HashMap.prototype.values = function () {\n        var _a, _b, bucket, j, e_2_1;\n        var e_2, _c;\n        return tslib.__generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    _d.trys.push([0, 7, 8, 9]);\n                    _a = tslib.__values(this.buckets.values()), _b = _a.next();\n                    _d.label = 1;\n                case 1:\n                    if (!!_b.done) return [3 /*break*/, 6];\n                    bucket = _b.value;\n                    j = bucket.values.length - 1;\n                    _d.label = 2;\n                case 2:\n                    if (!(j >= 0)) return [3 /*break*/, 5];\n                    return [4 /*yield*/, bucket.values[j]];\n                case 3:\n                    _d.sent();\n                    _d.label = 4;\n                case 4:\n                    j--;\n                    return [3 /*break*/, 2];\n                case 5:\n                    _b = _a.next();\n                    return [3 /*break*/, 1];\n                case 6: return [3 /*break*/, 9];\n                case 7:\n                    e_2_1 = _d.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3 /*break*/, 9];\n                case 8:\n                    try {\n                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                    return [7 /*endfinally*/];\n                case 9: return [2 /*return*/];\n            }\n        });\n    };\n    return HashMap;\n}());\n\nfunction preprocessProgramObj_GLSL(device, obj) {\n    var defines = obj.defines !== undefined ? obj.defines : null;\n    var vert = obj.both !== undefined ? obj.both + obj.vert : obj.vert;\n    var frag = obj.both !== undefined ? obj.both + obj.frag : obj.frag;\n    return gDeviceApi.preprocessProgram_GLSL(device.queryVendorInfo(), vert, frag, defines);\n}\nfunction programDescriptorSimpleEquals(a, b) {\n    gDeviceApi.assert(a.preprocessedVert !== '' && b.preprocessedVert !== '');\n    gDeviceApi.assert(a.preprocessedFrag !== '' && b.preprocessedFrag !== '');\n    return (a.preprocessedVert === b.preprocessedVert &&\n        a.preprocessedFrag === b.preprocessedFrag);\n}\nfunction programDescriptorSimpleCopy(a) {\n    var preprocessedVert = a.preprocessedVert;\n    var preprocessedFrag = a.preprocessedFrag;\n    var vert = a.vert;\n    var frag = a.frag;\n    return { preprocessedVert: preprocessedVert, preprocessedFrag: preprocessedFrag, vert: vert, frag: frag };\n}\nfunction blendStateHash(hash, a) {\n    hash = hashCodeNumberUpdate(hash, a.blendMode);\n    hash = hashCodeNumberUpdate(hash, a.blendSrcFactor);\n    hash = hashCodeNumberUpdate(hash, a.blendDstFactor);\n    return hash;\n}\nfunction attachmentStateHash(hash, a) {\n    hash = blendStateHash(hash, a.rgbBlendState);\n    hash = blendStateHash(hash, a.alphaBlendState);\n    hash = hashCodeNumberUpdate(hash, a.channelWriteMask);\n    return hash;\n}\nfunction colorHash(hash, a) {\n    hash = hashCodeNumberUpdate(hash, (a.r << 24) | (a.g << 16) | (a.b << 8) | a.a);\n    return hash;\n}\nfunction megaStateDescriptorHash(hash, a) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    for (var i = 0; i < a.attachmentsState.length; i++)\n        hash = attachmentStateHash(hash, a.attachmentsState[i]);\n    hash = colorHash(hash, a.blendConstant);\n    hash = hashCodeNumberUpdate(hash, a.depthCompare);\n    hash = hashCodeNumberUpdate(hash, a.depthWrite ? 1 : 0);\n    hash = hashCodeNumberUpdate(hash, (_a = a.stencilFront) === null || _a === void 0 ? void 0 : _a.compare);\n    hash = hashCodeNumberUpdate(hash, (_b = a.stencilFront) === null || _b === void 0 ? void 0 : _b.passOp);\n    hash = hashCodeNumberUpdate(hash, (_c = a.stencilFront) === null || _c === void 0 ? void 0 : _c.failOp);\n    hash = hashCodeNumberUpdate(hash, (_d = a.stencilFront) === null || _d === void 0 ? void 0 : _d.depthFailOp);\n    hash = hashCodeNumberUpdate(hash, (_e = a.stencilBack) === null || _e === void 0 ? void 0 : _e.compare);\n    hash = hashCodeNumberUpdate(hash, (_f = a.stencilBack) === null || _f === void 0 ? void 0 : _f.passOp);\n    hash = hashCodeNumberUpdate(hash, (_g = a.stencilBack) === null || _g === void 0 ? void 0 : _g.failOp);\n    hash = hashCodeNumberUpdate(hash, (_h = a.stencilBack) === null || _h === void 0 ? void 0 : _h.depthFailOp);\n    hash = hashCodeNumberUpdate(hash, a.stencilWrite ? 1 : 0);\n    hash = hashCodeNumberUpdate(hash, a.cullMode);\n    hash = hashCodeNumberUpdate(hash, a.frontFace ? 1 : 0);\n    hash = hashCodeNumberUpdate(hash, a.polygonOffset ? 1 : 0);\n    return hash;\n}\nfunction renderPipelineDescriptorHash(a) {\n    var hash = 0;\n    hash = hashCodeNumberUpdate(hash, a.program.id);\n    if (a.inputLayout !== null)\n        hash = hashCodeNumberUpdate(hash, a.inputLayout.id);\n    hash = megaStateDescriptorHash(hash, a.megaStateDescriptor);\n    for (var i = 0; i < a.colorAttachmentFormats.length; i++)\n        hash = hashCodeNumberUpdate(hash, a.colorAttachmentFormats[i] || 0);\n    hash = hashCodeNumberUpdate(hash, a.depthStencilAttachmentFormat || 0);\n    return hashCodeNumberFinish(hash);\n}\nfunction bindingsDescriptorHash(a) {\n    var hash = 0;\n    for (var i = 0; i < a.samplerBindings.length; i++) {\n        var binding = a.samplerBindings[i];\n        if (binding !== null && binding.texture !== null)\n            hash = hashCodeNumberUpdate(hash, binding.texture.id);\n    }\n    for (var i = 0; i < a.uniformBufferBindings.length; i++) {\n        var binding = a.uniformBufferBindings[i];\n        if (binding !== null && binding.buffer !== null) {\n            hash = hashCodeNumberUpdate(hash, binding.buffer.id);\n            hash = hashCodeNumberUpdate(hash, binding.binding);\n            hash = hashCodeNumberUpdate(hash, binding.offset);\n            hash = hashCodeNumberUpdate(hash, binding.size);\n        }\n    }\n    return hashCodeNumberFinish(hash);\n}\nvar RenderCache = /** @class */ (function () {\n    function RenderCache(device) {\n        this.bindingsCache = new HashMap(gDeviceApi.bindingsDescriptorEquals, bindingsDescriptorHash);\n        this.renderPipelinesCache = new HashMap(gDeviceApi.renderPipelineDescriptorEquals, renderPipelineDescriptorHash);\n        this.inputLayoutsCache = new HashMap(gDeviceApi.inputLayoutDescriptorEquals, nullHashFunc);\n        this.programCache = new HashMap(programDescriptorSimpleEquals, nullHashFunc);\n        this.samplerCache = new HashMap(gDeviceApi.samplerDescriptorEquals, nullHashFunc);\n        this.device = device;\n    }\n    RenderCache.prototype.createBindings = function (descriptor) {\n        var bindings = this.bindingsCache.get(descriptor);\n        if (bindings === null) {\n            var descriptorCopy = gDeviceApi.bindingsDescriptorCopy(descriptor);\n            descriptorCopy.uniformBufferBindings =\n                descriptorCopy.uniformBufferBindings.filter(function (_a) {\n                    var size = _a.size;\n                    return size > 0;\n                });\n            bindings = this.device.createBindings(descriptorCopy);\n            this.bindingsCache.add(descriptorCopy, bindings);\n        }\n        return bindings;\n    };\n    RenderCache.prototype.createRenderPipeline = function (descriptor) {\n        var renderPipeline = this.renderPipelinesCache.get(descriptor);\n        if (renderPipeline === null) {\n            var descriptorCopy = gDeviceApi.renderPipelineDescriptorCopy(descriptor);\n            descriptorCopy.colorAttachmentFormats =\n                descriptorCopy.colorAttachmentFormats.filter(function (f) { return f; });\n            renderPipeline = this.device.createRenderPipeline(descriptorCopy);\n            this.renderPipelinesCache.add(descriptorCopy, renderPipeline);\n        }\n        return renderPipeline;\n    };\n    RenderCache.prototype.createInputLayout = function (descriptor) {\n        // remove hollows\n        descriptor.vertexBufferDescriptors =\n            descriptor.vertexBufferDescriptors.filter(function (d) { return !!d; });\n        var inputLayout = this.inputLayoutsCache.get(descriptor);\n        if (inputLayout === null) {\n            var descriptorCopy = gDeviceApi.inputLayoutDescriptorCopy(descriptor);\n            inputLayout = this.device.createInputLayout(descriptorCopy);\n            this.inputLayoutsCache.add(descriptorCopy, inputLayout);\n        }\n        return inputLayout;\n    };\n    RenderCache.prototype.createProgramSimple = function (deviceProgram) {\n        var vert = deviceProgram.vert, frag = deviceProgram.frag, preprocessedFrag = deviceProgram.preprocessedFrag, preprocessedVert = deviceProgram.preprocessedVert;\n        var program = null;\n        if (preprocessedVert && preprocessedFrag) {\n            program = this.programCache.get({\n                vert: vert,\n                frag: frag,\n                preprocessedFrag: preprocessedFrag,\n                preprocessedVert: preprocessedVert,\n            });\n        }\n        if (program === null) {\n            var _a = preprocessProgramObj_GLSL(this.device, deviceProgram), preprocessedVert_1 = _a.preprocessedVert, preprocessedFrag_1 = _a.preprocessedFrag;\n            deviceProgram.preprocessedVert = preprocessedVert_1;\n            deviceProgram.preprocessedFrag = preprocessedFrag_1;\n            var descriptorCopy = programDescriptorSimpleCopy(deviceProgram);\n            program = this.device['createProgramSimple']({\n                vertex: {\n                    glsl: preprocessedVert_1,\n                },\n                fragment: {\n                    glsl: preprocessedFrag_1,\n                },\n            }, vert);\n            this.programCache.add(descriptorCopy, program);\n        }\n        return program;\n    };\n    RenderCache.prototype.createSampler = function (descriptor) {\n        var sampler = this.samplerCache.get(descriptor);\n        if (sampler === null) {\n            sampler = this.device.createSampler(descriptor);\n            this.samplerCache.add(descriptor, sampler);\n        }\n        return sampler;\n    };\n    RenderCache.prototype.destroy = function () {\n        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;\n        try {\n            for (var _f = tslib.__values(this.bindingsCache.values()), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var bindings = _g.value;\n                bindings.destroy();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        try {\n            for (var _h = tslib.__values(this.renderPipelinesCache.values()), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var renderPipeline = _j.value;\n                renderPipeline.destroy();\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        try {\n            for (var _k = tslib.__values(this.inputLayoutsCache.values()), _l = _k.next(); !_l.done; _l = _k.next()) {\n                var inputLayout = _l.value;\n                inputLayout.destroy();\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_l && !_l.done && (_c = _k.return)) _c.call(_k);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        try {\n            for (var _m = tslib.__values(this.programCache.values()), _o = _m.next(); !_o.done; _o = _m.next()) {\n                var program = _o.value;\n                program.destroy();\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        try {\n            for (var _p = tslib.__values(this.samplerCache.values()), _q = _p.next(); !_q.done; _q = _p.next()) {\n                var sampler = _q.value;\n                sampler.destroy();\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        this.bindingsCache.clear();\n        this.renderPipelinesCache.clear();\n        this.inputLayoutsCache.clear();\n        this.programCache.clear();\n        this.samplerCache.clear();\n    };\n    return RenderCache;\n}());\n\nexports.ToneMapping = void 0;\n(function (ToneMapping) {\n    ToneMapping[\"NONE\"] = \"none\";\n    ToneMapping[\"LINEAR\"] = \"LinearToneMapping\";\n    ToneMapping[\"REINHARD\"] = \"ReinhardToneMapping\";\n    ToneMapping[\"CINEON\"] = \"OptimizedCineonToneMapping\";\n    ToneMapping[\"ACES_FILMIC\"] = \"ACESFilmicToneMapping\";\n    ToneMapping[\"CUSTOM\"] = \"CustomToneMapping\";\n})(exports.ToneMapping || (exports.ToneMapping = {}));\n\nexports.RGAttachmentSlot = void 0;\n(function (RGAttachmentSlot) {\n    RGAttachmentSlot[RGAttachmentSlot[\"Color0\"] = 0] = \"Color0\";\n    RGAttachmentSlot[RGAttachmentSlot[\"Color1\"] = 1] = \"Color1\";\n    RGAttachmentSlot[RGAttachmentSlot[\"Color2\"] = 2] = \"Color2\";\n    RGAttachmentSlot[RGAttachmentSlot[\"Color3\"] = 3] = \"Color3\";\n    RGAttachmentSlot[RGAttachmentSlot[\"ColorMax\"] = 3] = \"ColorMax\";\n    RGAttachmentSlot[RGAttachmentSlot[\"DepthStencil\"] = 4] = \"DepthStencil\";\n})(exports.RGAttachmentSlot || (exports.RGAttachmentSlot = {}));\n\nvar RenderGraphPass = /** @class */ (function () {\n    function RenderGraphPass() {\n        // RenderTargetAttachmentSlot => renderTargetID\n        this.renderTargetIDs = [];\n        this.renderTargetLevels = [];\n        // RenderTargetAttachmentSlot => resolveTextureID\n        this.resolveTextureOutputIDs = [];\n        // RenderTargetAttachmentSlot => Texture\n        this.resolveTextureOutputExternalTextures = [];\n        this.resolveTextureOutputExternalTextureLevel = [];\n        // List of resolveTextureIDs that we have a reference to.\n        this.resolveTextureInputIDs = [];\n        // RGAttachmentSlot => refcount.\n        this.renderTargetExtraRefs = [];\n        this.resolveTextureInputTextures = [];\n        this.renderTargets = [];\n        // Execution state computed by scheduling.\n        this.descriptor = {\n            colorAttachment: [],\n            colorAttachmentLevel: [],\n            colorResolveTo: [],\n            colorResolveToLevel: [],\n            colorStore: [],\n            depthStencilAttachment: null,\n            depthStencilResolveTo: null,\n            depthStencilStore: true,\n            colorClearColor: ['load'],\n            depthClearValue: 'load',\n            stencilClearValue: 'load',\n            occlusionQueryPool: null,\n        };\n        this.viewportX = 0;\n        this.viewportY = 0;\n        this.viewportW = 1;\n        this.viewportH = 1;\n        // Execution callback from user.\n        this.execFunc = null;\n        this.postFunc = null;\n        this.debugThumbnails = [];\n    }\n    RenderGraphPass.prototype.setDebugName = function (debugName) {\n        this.debugName = debugName;\n    };\n    RenderGraphPass.prototype.pushDebugThumbnail = function (attachmentSlot) {\n        this.debugThumbnails[attachmentSlot] = true;\n    };\n    RenderGraphPass.prototype.setViewport = function (x, y, w, h) {\n        this.viewportX = x;\n        this.viewportY = y;\n        this.viewportW = w;\n        this.viewportH = h;\n    };\n    RenderGraphPass.prototype.attachRenderTargetID = function (attachmentSlot, renderTargetID, level) {\n        if (level === void 0) { level = 0; }\n        gDeviceApi.assert(this.renderTargetIDs[attachmentSlot] === undefined);\n        this.renderTargetIDs[attachmentSlot] = renderTargetID;\n        this.renderTargetLevels[attachmentSlot] = level;\n    };\n    RenderGraphPass.prototype.attachResolveTexture = function (resolveTextureID) {\n        this.resolveTextureInputIDs.push(resolveTextureID);\n    };\n    RenderGraphPass.prototype.attachOcclusionQueryPool = function (queryPool) {\n        this.descriptor.occlusionQueryPool = queryPool;\n    };\n    RenderGraphPass.prototype.exec = function (func) {\n        gDeviceApi.assert(this.execFunc === null);\n        this.execFunc = func;\n    };\n    RenderGraphPass.prototype.post = function (func) {\n        gDeviceApi.assert(this.postFunc === null);\n        this.postFunc = func;\n    };\n    RenderGraphPass.prototype.addExtraRef = function (slot) {\n        this.renderTargetExtraRefs[slot] = true;\n    };\n    return RenderGraphPass;\n}());\n\nvar RGRenderTarget = /** @class */ (function () {\n    function RGRenderTarget(device, desc) {\n        this.dimension = gDeviceApi.TextureDimension.TEXTURE_2D;\n        this.depthOrArrayLayers = 1;\n        this.mipLevelCount = 1;\n        this.width = 0;\n        this.height = 0;\n        this.sampleCount = 0;\n        this.usage = gDeviceApi.TextureUsage.RENDER_TARGET;\n        this.needsClear = true;\n        this.texture = null;\n        this.age = 0;\n        this.format = desc.format;\n        this.width = desc.width;\n        this.height = desc.height;\n        this.sampleCount = desc.sampleCount;\n        gDeviceApi.assert(this.sampleCount >= 1);\n        if (this.sampleCount > 1) {\n            // MSAA render targets must be backed by attachments.\n            this.attachment = device.createRenderTarget(this);\n        }\n        else {\n            // Single-sampled textures can be backed by regular textures.\n            this.texture = device.createTexture(this);\n            this.attachment = device.createRenderTargetFromTexture(this.texture);\n        }\n    }\n    RGRenderTarget.prototype.setDebugName = function (device, debugName) {\n        this.debugName = debugName;\n        if (this.texture !== null) {\n            device.setResourceName(this.texture, this.debugName);\n        }\n        device.setResourceName(this.attachment, this.debugName);\n    };\n    RGRenderTarget.prototype.matchesDescription = function (desc) {\n        return (this.format === desc.format &&\n            this.width === desc.width &&\n            this.height === desc.height &&\n            this.sampleCount === desc.sampleCount);\n    };\n    RGRenderTarget.prototype.reset = function (desc) {\n        gDeviceApi.assert(this.matchesDescription(desc));\n        this.age = 0;\n    };\n    RGRenderTarget.prototype.destroy = function () {\n        this.attachment.destroy();\n    };\n    return RGRenderTarget;\n}());\n\n// Whenever we need to resolve a multi-sampled render target to a single-sampled texture,\n// we record an extra single-sampled texture here.\nvar SingleSampledTexture = /** @class */ (function () {\n    function SingleSampledTexture(device, desc) {\n        this.dimension = gDeviceApi.TextureDimension.TEXTURE_2D;\n        this.depthOrArrayLayers = 1;\n        this.mipLevelCount = 1;\n        this.usage = gDeviceApi.TextureUsage.RENDER_TARGET;\n        this.width = 0;\n        this.height = 0;\n        this.age = 0;\n        this.format = desc.format;\n        this.width = desc.width;\n        this.height = desc.height;\n        this.texture = device.createTexture(this);\n    }\n    SingleSampledTexture.prototype.matchesDescription = function (desc) {\n        return (this.format === desc.format &&\n            this.width === desc.width &&\n            this.height === desc.height);\n    };\n    SingleSampledTexture.prototype.reset = function (desc) {\n        gDeviceApi.assert(this.matchesDescription(desc));\n        this.age = 0;\n    };\n    SingleSampledTexture.prototype.destroy = function () {\n        this.texture.destroy();\n    };\n    return SingleSampledTexture;\n}());\n\nvar GraphImpl = /** @class */ (function () {\n    function GraphImpl() {\n        // [Symbol.species]?: 'RGGraph';\n        // Used for determining scheduling.\n        this.renderTargetDescriptions = [];\n        this.resolveTextureRenderTargetIDs = [];\n        this.passes = [];\n        // Debugging.\n        this.renderTargetDebugNames = [];\n    }\n    return GraphImpl;\n}());\nvar RenderGraph = /** @class */ (function () {\n    function RenderGraph(device) {\n        // For scope callbacks.\n        this.currentPass = null;\n        //#region Resource Creation & Caching\n        this.renderTargetDeadPool = [];\n        this.singleSampledTextureDeadPool = [];\n        //#endregion\n        //#region Graph Builder\n        this.currentGraph = null;\n        //#endregion\n        //#region Scheduling\n        this.renderTargetOutputCount = [];\n        this.renderTargetResolveCount = [];\n        this.resolveTextureUseCount = [];\n        this.renderTargetAliveForID = [];\n        this.singleSampledTextureForResolveTextureID = [];\n        this.device = device;\n    }\n    RenderGraph.prototype.acquireRenderTargetForDescription = function (desc) {\n        for (var i = 0; i < this.renderTargetDeadPool.length; i++) {\n            var freeRenderTarget = this.renderTargetDeadPool[i];\n            if (freeRenderTarget.matchesDescription(desc)) {\n                // Pop it off the list.\n                freeRenderTarget.reset(desc);\n                this.renderTargetDeadPool.splice(i--, 1);\n                return freeRenderTarget;\n            }\n        }\n        // Allocate a new render target.\n        return new RGRenderTarget(this.device, desc);\n    };\n    RenderGraph.prototype.acquireSingleSampledTextureForDescription = function (desc) {\n        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++) {\n            var freeSingleSampledTexture = this.singleSampledTextureDeadPool[i];\n            if (freeSingleSampledTexture.matchesDescription(desc)) {\n                // Pop it off the list.\n                freeSingleSampledTexture.reset(desc);\n                this.singleSampledTextureDeadPool.splice(i--, 1);\n                return freeSingleSampledTexture;\n            }\n        }\n        // Allocate a new resolve texture.\n        return new SingleSampledTexture(this.device, desc);\n    };\n    RenderGraph.prototype.beginGraphBuilder = function () {\n        gDeviceApi.assert(this.currentGraph === null);\n        this.currentGraph = new GraphImpl();\n    };\n    RenderGraph.prototype.pushPass = function (setupFunc) {\n        var pass = new RenderGraphPass();\n        setupFunc(pass);\n        this.currentGraph.passes.push(pass);\n    };\n    RenderGraph.prototype.createRenderTargetID = function (desc, debugName) {\n        this.currentGraph.renderTargetDebugNames.push(debugName);\n        return this.currentGraph.renderTargetDescriptions.push(desc) - 1;\n    };\n    RenderGraph.prototype.createResolveTextureID = function (renderTargetID) {\n        return (this.currentGraph.resolveTextureRenderTargetIDs.push(renderTargetID) - 1);\n    };\n    /**\n     *  RT  RGPass\n     */\n    RenderGraph.prototype.findMostRecentPassThatAttachedRenderTarget = function (renderTargetID) {\n        for (var i = this.currentGraph.passes.length - 1; i >= 0; i--) {\n            var pass = this.currentGraph.passes[i];\n            if (pass.renderTargetIDs.includes(renderTargetID))\n                return pass;\n        }\n        return null;\n    };\n    RenderGraph.prototype.resolveRenderTargetPassAttachmentSlot = function (pass, attachmentSlot) {\n        var renderPass = pass;\n        if (renderPass.resolveTextureOutputIDs[attachmentSlot] === undefined) {\n            var renderTargetID = renderPass.renderTargetIDs[attachmentSlot];\n            var resolveTextureID = this.createResolveTextureID(renderTargetID);\n            renderPass.resolveTextureOutputIDs[attachmentSlot] = resolveTextureID;\n        }\n        return renderPass.resolveTextureOutputIDs[attachmentSlot];\n    };\n    RenderGraph.prototype.findPassForResolveRenderTarget = function (renderTargetID) {\n        // Find the last pass that rendered to this render target, and resolve it now.\n        // If you wanted a previous snapshot copy of it, you should have created a separate,\n        // intermediate pass to copy that out. Perhaps we should have a helper for that use case?\n        // If there was no pass that wrote to this RT, well there's no point in resolving it, is there?\n        var renderPass = gDeviceApi.assertExists(this.findMostRecentPassThatAttachedRenderTarget(renderTargetID));\n        // Check which attachment we're in. This could possibly be explicit from the user, but it's\n        // easy enough to find...\n        var attachmentSlot = renderPass.renderTargetIDs.indexOf(renderTargetID);\n        // Check that the pass isn't resolving its attachment to another texture. Can't do both!\n        gDeviceApi.assert(renderPass.resolveTextureOutputExternalTextures[attachmentSlot] ===\n            undefined);\n        return renderPass;\n    };\n    RenderGraph.prototype.resolveRenderTarget = function (renderTargetID) {\n        var renderPass = this.findPassForResolveRenderTarget(renderTargetID);\n        var attachmentSlot = renderPass.renderTargetIDs.indexOf(renderTargetID);\n        return this.resolveRenderTargetPassAttachmentSlot(renderPass, attachmentSlot);\n    };\n    RenderGraph.prototype.resolveRenderTargetToExternalTexture = function (renderTargetID, texture, level) {\n        if (level === void 0) { level = 0; }\n        var renderPass = this.findPassForResolveRenderTarget(renderTargetID);\n        var attachmentSlot = renderPass.renderTargetIDs.indexOf(renderTargetID);\n        // We shouldn't be resolving to a resolve texture ID in this case.\n        gDeviceApi.assert(renderPass.resolveTextureOutputIDs[attachmentSlot] === undefined);\n        renderPass.resolveTextureOutputExternalTextures[attachmentSlot] = texture;\n        renderPass.resolveTextureOutputExternalTextureLevel[attachmentSlot] = level;\n    };\n    RenderGraph.prototype.getRenderTargetDescription = function (renderTargetID) {\n        return gDeviceApi.assertExists(this.currentGraph.renderTargetDescriptions[renderTargetID]);\n    };\n    RenderGraph.prototype.scheduleAddUseCount = function (graph, pass) {\n        for (var slot = 0; slot < pass.renderTargetIDs.length; slot++) {\n            var renderTargetID = pass.renderTargetIDs[slot];\n            if (renderTargetID === undefined)\n                continue;\n            this.renderTargetOutputCount[renderTargetID]++;\n            if (pass.renderTargetExtraRefs[slot])\n                this.renderTargetOutputCount[renderTargetID]++;\n        }\n        for (var i = 0; i < pass.resolveTextureInputIDs.length; i++) {\n            var resolveTextureID = pass.resolveTextureInputIDs[i];\n            if (resolveTextureID === undefined)\n                continue;\n            this.resolveTextureUseCount[resolveTextureID]++;\n            var renderTargetID = graph.resolveTextureRenderTargetIDs[resolveTextureID];\n            this.renderTargetResolveCount[renderTargetID]++;\n        }\n    };\n    RenderGraph.prototype.acquireRenderTargetForID = function (graph, renderTargetID) {\n        if (renderTargetID === undefined)\n            return null;\n        gDeviceApi.assert(this.renderTargetOutputCount[renderTargetID] > 0);\n        if (!this.renderTargetAliveForID[renderTargetID]) {\n            var desc = graph.renderTargetDescriptions[renderTargetID];\n            var newRenderTarget = this.acquireRenderTargetForDescription(desc);\n            newRenderTarget.setDebugName(this.device, graph.renderTargetDebugNames[renderTargetID]);\n            this.renderTargetAliveForID[renderTargetID] = newRenderTarget;\n        }\n        return this.renderTargetAliveForID[renderTargetID];\n    };\n    RenderGraph.prototype.releaseRenderTargetForID = function (renderTargetID, forOutput) {\n        if (renderTargetID === undefined)\n            return null;\n        var renderTarget = gDeviceApi.assertExists(this.renderTargetAliveForID[renderTargetID]);\n        if (forOutput) {\n            gDeviceApi.assert(this.renderTargetOutputCount[renderTargetID] > 0);\n            this.renderTargetOutputCount[renderTargetID]--;\n        }\n        else {\n            gDeviceApi.assert(this.renderTargetResolveCount[renderTargetID] > 0);\n            this.renderTargetResolveCount[renderTargetID]--;\n        }\n        if (this.renderTargetOutputCount[renderTargetID] === 0 &&\n            this.renderTargetResolveCount[renderTargetID] === 0) {\n            // This was the last reference to this RT -- steal it from the alive list, and put it back into the pool.\n            renderTarget.needsClear = true;\n            delete this.renderTargetAliveForID[renderTargetID];\n            this.renderTargetDeadPool.push(renderTarget);\n        }\n        return renderTarget;\n    };\n    RenderGraph.prototype.acquireResolveTextureInputTextureForID = function (graph, resolveTextureID) {\n        var renderTargetID = graph.resolveTextureRenderTargetIDs[resolveTextureID];\n        gDeviceApi.assert(this.resolveTextureUseCount[resolveTextureID] > 0);\n        this.resolveTextureUseCount[resolveTextureID]--;\n        var renderTarget = gDeviceApi.assertExists(this.releaseRenderTargetForID(renderTargetID, false));\n        if (this.singleSampledTextureForResolveTextureID[resolveTextureID] !==\n            undefined) {\n            // The resolved texture belonging to this RT is backed by our own single-sampled texture.\n            var singleSampledTexture = this.singleSampledTextureForResolveTextureID[resolveTextureID];\n            if (this.resolveTextureUseCount[resolveTextureID] === 0) {\n                // Release this single-sampled texture back to the pool, if this is the last use of it.\n                this.singleSampledTextureDeadPool.push(singleSampledTexture);\n            }\n            return singleSampledTexture.texture;\n        }\n        else {\n            // The resolved texture belonging to this RT is backed by our render target.\n            return gDeviceApi.assertExists(renderTarget.texture);\n        }\n    };\n    RenderGraph.prototype.determineResolveParam = function (graph, pass, slot) {\n        var renderTargetID = pass.renderTargetIDs[slot];\n        var resolveTextureOutputID = pass.resolveTextureOutputIDs[slot];\n        var externalTexture = pass.resolveTextureOutputExternalTextures[slot];\n        // We should have either an output ID or an external texture, not both.\n        var hasResolveTextureOutputID = resolveTextureOutputID !== undefined;\n        var hasExternalTexture = externalTexture !== undefined;\n        gDeviceApi.assert(!(hasResolveTextureOutputID && hasExternalTexture));\n        var resolveTo = null;\n        var store = false;\n        var level = 0;\n        if (this.renderTargetOutputCount[renderTargetID] > 1) {\n            // A future pass is going to render to this RT, we need to store the results.\n            store = true;\n        }\n        if (hasResolveTextureOutputID) {\n            gDeviceApi.assert(graph.resolveTextureRenderTargetIDs[resolveTextureOutputID] ===\n                renderTargetID);\n            gDeviceApi.assert(this.resolveTextureUseCount[resolveTextureOutputID] > 0);\n            gDeviceApi.assert(this.renderTargetOutputCount[renderTargetID] > 0);\n            var renderTarget = gDeviceApi.assertExists(this.renderTargetAliveForID[renderTargetID]);\n            // If we're the last user of this RT, then we don't need to resolve -- the texture itself will be enough.\n            // Note that this isn't exactly an exactly correct algorithm. If we have pass A writing to RenderTargetA,\n            // pass B resolving RenderTargetA to ResolveTextureA, and pass C writing to RenderTargetA, then we don't\n            // strictly need to copy, but in order to determine that at the time of pass A, we'd need a much fancier\n            // schedule than just tracking refcounts...\n            if (renderTarget.texture !== null &&\n                this.renderTargetOutputCount[renderTargetID] === 1) {\n                resolveTo = null;\n                store = true;\n            }\n            else {\n                if (!this.singleSampledTextureForResolveTextureID[resolveTextureOutputID]) {\n                    var desc = gDeviceApi.assertExists(graph.renderTargetDescriptions[renderTargetID]);\n                    this.singleSampledTextureForResolveTextureID[resolveTextureOutputID] =\n                        this.acquireSingleSampledTextureForDescription(desc);\n                    this.device.setResourceName(this.singleSampledTextureForResolveTextureID[resolveTextureOutputID]\n                        .texture, renderTarget.debugName + \" (Resolve \".concat(resolveTextureOutputID, \")\"));\n                }\n                resolveTo =\n                    this.singleSampledTextureForResolveTextureID[resolveTextureOutputID]\n                        .texture;\n            }\n        }\n        else if (hasExternalTexture) {\n            resolveTo = externalTexture;\n            level = pass.resolveTextureOutputExternalTextureLevel[slot];\n        }\n        else {\n            resolveTo = null;\n        }\n        return { resolveTo: resolveTo, store: store, level: level };\n    };\n    RenderGraph.prototype.schedulePass = function (graph, pass) {\n        var depthStencilRenderTargetID = pass.renderTargetIDs[exports.RGAttachmentSlot.DepthStencil];\n        for (var slot = exports.RGAttachmentSlot.Color0; slot <= exports.RGAttachmentSlot.ColorMax; slot++) {\n            var colorRenderTargetID = pass.renderTargetIDs[slot];\n            var colorRenderTarget = this.acquireRenderTargetForID(graph, colorRenderTargetID);\n            pass.renderTargets[slot] = colorRenderTarget;\n            pass.descriptor.colorAttachment[slot] =\n                colorRenderTarget !== null ? colorRenderTarget.attachment : null;\n            pass.descriptor.colorAttachmentLevel[slot] =\n                pass.renderTargetLevels[slot];\n            var _a = this.determineResolveParam(graph, pass, slot), resolveTo_1 = _a.resolveTo, store_1 = _a.store, level = _a.level;\n            pass.descriptor.colorResolveTo[slot] = resolveTo_1;\n            pass.descriptor.colorResolveToLevel[slot] = level;\n            pass.descriptor.colorStore[slot] = store_1;\n            pass.descriptor.colorClearColor[slot] =\n                colorRenderTarget !== null && colorRenderTarget.needsClear\n                    ? graph.renderTargetDescriptions[colorRenderTargetID].colorClearColor\n                    : 'load';\n        }\n        var depthStencilRenderTarget = this.acquireRenderTargetForID(graph, depthStencilRenderTargetID);\n        pass.renderTargets[exports.RGAttachmentSlot.DepthStencil] =\n            depthStencilRenderTarget;\n        pass.descriptor.depthStencilAttachment =\n            depthStencilRenderTarget !== null\n                ? depthStencilRenderTarget.attachment\n                : null;\n        var _b = this.determineResolveParam(graph, pass, exports.RGAttachmentSlot.DepthStencil), resolveTo = _b.resolveTo, store = _b.store;\n        pass.descriptor.depthStencilResolveTo = resolveTo;\n        pass.descriptor.depthStencilStore = store;\n        pass.descriptor.depthClearValue =\n            depthStencilRenderTarget !== null && depthStencilRenderTarget.needsClear\n                ? graph.renderTargetDescriptions[depthStencilRenderTargetID]\n                    .depthClearValue\n                : 'load';\n        pass.descriptor.stencilClearValue =\n            depthStencilRenderTarget !== null && depthStencilRenderTarget.needsClear\n                ? graph.renderTargetDescriptions[depthStencilRenderTargetID]\n                    .stencilClearValue\n                : 'load';\n        var rtWidth = 0;\n        var rtHeight = 0;\n        var rtSampleCount = 0;\n        for (var i = 0; i < pass.renderTargets.length; i++) {\n            var renderTarget = pass.renderTargets[i];\n            if (!renderTarget)\n                continue;\n            var width = renderTarget.width >>> pass.renderTargetLevels[i];\n            var height = renderTarget.height >>> pass.renderTargetLevels[i];\n            if (rtWidth === 0) {\n                rtWidth = width;\n                rtHeight = height;\n                rtSampleCount = renderTarget.sampleCount;\n            }\n            gDeviceApi.assert(width === rtWidth);\n            gDeviceApi.assert(height === rtHeight);\n            gDeviceApi.assert(renderTarget.sampleCount === rtSampleCount);\n            renderTarget.needsClear = false;\n        }\n        if (rtWidth > 0 && rtHeight > 0) {\n            pass.viewportX *= rtWidth;\n            pass.viewportY *= rtHeight;\n            pass.viewportW *= rtWidth;\n            pass.viewportH *= rtHeight;\n        }\n        for (var i = 0; i < pass.resolveTextureInputIDs.length; i++) {\n            var resolveTextureID = pass.resolveTextureInputIDs[i];\n            pass.resolveTextureInputTextures[i] =\n                this.acquireResolveTextureInputTextureForID(graph, resolveTextureID);\n        }\n        for (var i = 0; i < pass.renderTargetIDs.length; i++)\n            this.releaseRenderTargetForID(pass.renderTargetIDs[i], true);\n        for (var slot = 0; slot < pass.renderTargetExtraRefs.length; slot++)\n            if (pass.renderTargetExtraRefs[slot])\n                this.releaseRenderTargetForID(pass.renderTargetIDs[slot], true);\n    };\n    RenderGraph.prototype.scheduleGraph = function (graph) {\n        gDeviceApi.assert(this.renderTargetOutputCount.length === 0);\n        gDeviceApi.assert(this.renderTargetResolveCount.length === 0);\n        gDeviceApi.assert(this.resolveTextureUseCount.length === 0);\n        // Go through and increment the age of everything in our dead pools to mark that it's old.\n        for (var i = 0; i < this.renderTargetDeadPool.length; i++)\n            this.renderTargetDeadPool[i].age++;\n        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++)\n            this.singleSampledTextureDeadPool[i].age++;\n        // Schedule our resources -- first, count up all uses of resources, then hand them out.\n        // Initialize our accumulators.\n        gDeviceApi.fillArray(this.renderTargetOutputCount, graph.renderTargetDescriptions.length, 0);\n        gDeviceApi.fillArray(this.renderTargetResolveCount, graph.renderTargetDescriptions.length, 0);\n        gDeviceApi.fillArray(this.resolveTextureUseCount, graph.resolveTextureRenderTargetIDs.length, 0);\n        // Count.\n        for (var i = 0; i < graph.passes.length; i++)\n            this.scheduleAddUseCount(graph, graph.passes[i]);\n        // Now hand out resources.\n        for (var i = 0; i < graph.passes.length; i++)\n            this.schedulePass(graph, graph.passes[i]);\n        // Double-check that all resources were handed out.\n        for (var i = 0; i < this.renderTargetOutputCount.length; i++)\n            gDeviceApi.assert(this.renderTargetOutputCount[i] === 0);\n        for (var i = 0; i < this.renderTargetResolveCount.length; i++)\n            gDeviceApi.assert(this.renderTargetResolveCount[i] === 0);\n        for (var i = 0; i < this.resolveTextureUseCount.length; i++)\n            gDeviceApi.assert(this.resolveTextureUseCount[i] === 0);\n        for (var i = 0; i < this.renderTargetAliveForID.length; i++)\n            gDeviceApi.assert(this.renderTargetAliveForID[i] === undefined);\n        // Now go through and kill anything that's over our age threshold (hasn't been used in a bit)\n        var ageThreshold = 1;\n        for (var i = 0; i < this.renderTargetDeadPool.length; i++) {\n            if (this.renderTargetDeadPool[i].age >= ageThreshold) {\n                this.renderTargetDeadPool[i].destroy();\n                this.renderTargetDeadPool.splice(i--, 1);\n            }\n        }\n        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++) {\n            if (this.singleSampledTextureDeadPool[i].age >= ageThreshold) {\n                this.singleSampledTextureDeadPool[i].destroy();\n                this.singleSampledTextureDeadPool.splice(i--, 1);\n            }\n        }\n        // Clear out our transient scheduling state.\n        this.renderTargetResolveCount.length = 0;\n        this.renderTargetOutputCount.length = 0;\n        this.resolveTextureUseCount.length = 0;\n    };\n    //#endregion\n    //#region Execution\n    RenderGraph.prototype.execPass = function (pass) {\n        gDeviceApi.assert(this.currentPass === null);\n        this.currentPass = pass;\n        var renderPass = this.device.createRenderPass(pass.descriptor);\n        renderPass.pushDebugGroup(pass.debugName);\n        renderPass.setViewport(pass.viewportX, pass.viewportY, pass.viewportW, pass.viewportH);\n        if (pass.execFunc !== null)\n            pass.execFunc(renderPass, this);\n        renderPass.popDebugGroup();\n        this.device.submitPass(renderPass);\n        if (pass.postFunc !== null)\n            pass.postFunc(this);\n        this.currentPass = null;\n    };\n    RenderGraph.prototype.execGraph = function (graph) {\n        var _this = this;\n        this.scheduleGraph(graph);\n        this.device.beginFrame();\n        graph.passes.forEach(function (pass) {\n            _this.execPass(pass);\n        });\n        this.device.endFrame();\n        // Clear our transient scope state.\n        this.singleSampledTextureForResolveTextureID.length = 0;\n    };\n    RenderGraph.prototype.execute = function () {\n        var graph = gDeviceApi.assertExists(this.currentGraph);\n        this.execGraph(graph);\n        this.currentGraph = null;\n    };\n    RenderGraph.prototype.getDebug = function () {\n        return this;\n    };\n    //#endregion\n    //#region GfxrGraphBuilderDebug\n    RenderGraph.prototype.getPasses = function () {\n        return this.currentGraph.passes;\n    };\n    RenderGraph.prototype.getPassDebugThumbnails = function (pass) {\n        return pass.debugThumbnails;\n    };\n    RenderGraph.prototype.getPassRenderTargetID = function (pass, slot) {\n        return pass.renderTargetIDs[slot];\n    };\n    RenderGraph.prototype.getRenderTargetIDDebugName = function (renderTargetID) {\n        return this.currentGraph.renderTargetDebugNames[renderTargetID];\n    };\n    //#endregion\n    //#region GfxrPassScope\n    RenderGraph.prototype.getResolveTextureForID = function (resolveTextureID) {\n        var currentGraphPass = this.currentPass;\n        var i = currentGraphPass.resolveTextureInputIDs.indexOf(resolveTextureID);\n        gDeviceApi.assert(i >= 0);\n        return gDeviceApi.assertExists(currentGraphPass.resolveTextureInputTextures[i]);\n    };\n    RenderGraph.prototype.getRenderTargetAttachment = function (slot) {\n        var currentGraphPass = this.currentPass;\n        var renderTarget = currentGraphPass.renderTargets[slot];\n        if (!renderTarget)\n            return null;\n        return renderTarget.attachment;\n    };\n    RenderGraph.prototype.getRenderTargetTexture = function (slot) {\n        var currentGraphPass = this.currentPass;\n        var renderTarget = currentGraphPass.renderTargets[slot];\n        if (!renderTarget)\n            return null;\n        return renderTarget.texture;\n    };\n    //#endregion\n    RenderGraph.prototype.newGraphBuilder = function () {\n        this.beginGraphBuilder();\n        return this;\n    };\n    RenderGraph.prototype.destroy = function () {\n        // At the time this is called, we shouldn't have anything alive.\n        for (var i = 0; i < this.renderTargetAliveForID.length; i++)\n            gDeviceApi.assert(this.renderTargetAliveForID[i] === undefined);\n        for (var i = 0; i < this.singleSampledTextureForResolveTextureID.length; i++)\n            gDeviceApi.assert(this.singleSampledTextureForResolveTextureID[i] === undefined);\n        for (var i = 0; i < this.renderTargetDeadPool.length; i++)\n            this.renderTargetDeadPool[i].destroy();\n        for (var i = 0; i < this.singleSampledTextureDeadPool.length; i++)\n            this.singleSampledTextureDeadPool[i].destroy();\n    };\n    return RenderGraph;\n}());\n\n// Suggested values for the \"layer\" of makeSortKey. These are rough groups, and you can define your own\n// ordering within the rough groups (e.g. you might use BACKGROUND + 1, or BACKGROUND + 2).\n// TRANSLUCENT is meant to be used as a bitflag. It's special as it changes the behavior of the generic sort key\n// functions like makeSortKey and setSortKeyDepth.\nexports.RendererLayer = void 0;\n(function (RendererLayer) {\n    RendererLayer[RendererLayer[\"BACKGROUND\"] = 0] = \"BACKGROUND\";\n    RendererLayer[RendererLayer[\"ALPHA_TEST\"] = 16] = \"ALPHA_TEST\";\n    RendererLayer[RendererLayer[\"OPAQUE\"] = 32] = \"OPAQUE\";\n    RendererLayer[RendererLayer[\"TRANSLUCENT\"] = 128] = \"TRANSLUCENT\";\n})(exports.RendererLayer || (exports.RendererLayer = {}));\nvar MAX_DEPTH = 0x10000;\nvar DEPTH_BITS = 16;\nfunction makeDepthKey(depth, flipDepth, maxDepth) {\n    if (maxDepth === void 0) { maxDepth = MAX_DEPTH; }\n    // Input depth here is: 0 is the closest to the camera, positive values are further away. Negative values (behind camera) are clamped to 0.\n    // normalizedDepth: 0.0 is closest to camera, 1.0 is farthest from camera.\n    // These values are flipped if flipDepth is set.\n    var normalizedDepth = util.clamp(depth, 0, maxDepth) / maxDepth;\n    if (flipDepth)\n        normalizedDepth = 1.0 - normalizedDepth;\n    var depthKey = normalizedDepth * ((1 << DEPTH_BITS) - 1);\n    return depthKey & 0xffff;\n}\n// Common sort key kinds.\n// Indexed:     TLLLLLLL IIIIIIII IIIIIIII IIIIIIII\n// Opaque:      0LLLLLLL PPPPPPPP PPPPPPPP DDDDDDDD\n// Translucent: 1LLLLLLL DDDDDDDD DDDDDDDD BBBBBBBB\nfunction getSortKeyLayer(sortKey) {\n    return (sortKey >>> 24) & 0xff;\n}\nfunction setSortKeyLayer(sortKey, layer) {\n    return ((sortKey & 0x00ffffff) | ((layer & 0xff) << 24)) >>> 0;\n}\nfunction setSortKeyProgramKey(sortKey, programKey) {\n    var isTransparent = !!((sortKey >>> 31) & 1);\n    if (isTransparent)\n        return sortKey;\n    else\n        return ((sortKey & 0xff0000ff) | ((programKey & 0xffff) << 8)) >>> 0;\n}\nfunction setSortKeyBias(sortKey, bias) {\n    var isTransparent = !!((sortKey >>> 31) & 1);\n    if (isTransparent)\n        return ((sortKey & 0xffffff00) | (bias & 0xff)) >>> 0;\n    else\n        return sortKey;\n}\nfunction makeSortKeyOpaque(layer, programKey) {\n    return setSortKeyLayer(setSortKeyProgramKey(0, programKey), layer);\n}\nfunction setSortKeyOpaqueDepth(sortKey, depthKey) {\n    gDeviceApi.assert(depthKey >= 0);\n    return ((sortKey & 0xffffff00) | ((depthKey >>> 8) & 0xff)) >>> 0;\n}\nfunction makeSortKeyTranslucent(layer) {\n    return setSortKeyLayer(0, layer);\n}\nfunction setSortKeyTranslucentDepth(sortKey, depthKey) {\n    gDeviceApi.assert(depthKey >= 0);\n    return ((sortKey & 0xff0000ff) | (depthKey << 8)) >>> 0;\n}\nfunction makeSortKey(layer, programKey) {\n    if (programKey === void 0) { programKey = 0; }\n    if (layer & exports.RendererLayer.TRANSLUCENT)\n        return makeSortKeyTranslucent(layer);\n    else\n        return makeSortKeyOpaque(layer, programKey);\n}\nfunction setSortKeyDepthKey(sortKey, depthKey) {\n    var isTranslucent = !!((sortKey >>> 31) & 1);\n    return isTranslucent\n        ? setSortKeyTranslucentDepth(sortKey, depthKey)\n        : setSortKeyOpaqueDepth(sortKey, depthKey);\n}\nfunction setSortKeyDepth(sortKey, depth, maxDepth) {\n    if (maxDepth === void 0) { maxDepth = MAX_DEPTH; }\n    var isTranslucent = !!((sortKey >>> 31) & 1);\n    var depthKey = makeDepthKey(depth, isTranslucent, maxDepth);\n    return isTranslucent\n        ? setSortKeyTranslucentDepth(sortKey, depthKey)\n        : setSortKeyOpaqueDepth(sortKey, depthKey);\n}\nfunction getSortKeyDepth(sortKey) {\n    var isTranslucent = !!((sortKey >>> 31) & 1);\n    if (isTranslucent)\n        return (sortKey >>> 8) & 0xffff;\n    else {\n        return ((sortKey >>> 8) & 0xfffc) | (sortKey & 0x03);\n    }\n}\n\nvar mtxOpenGLFromD3D = glMatrix.mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, -1, 1);\n// Converts a projection matrix from D3D-style Z range [0, 1] to OpenGL-style Z range [-1, 1]\nfunction projectionMatrixOpenGLFromD3D(m) {\n    glMatrix.mat4.mul(m, mtxOpenGLFromD3D, m);\n}\nvar mtxD3DFromOpenGL = glMatrix.mat4.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);\n// Converts a projection matrix from OpenGL-style Z range [-1, 1] to D3D-style Z range [0, 1]\nfunction projectionMatrixD3DFromOpenGL(m) {\n    glMatrix.mat4.mul(m, mtxD3DFromOpenGL, m);\n}\n/**\n * Convert a projection matrix {@param m} between differing clip spaces.\n *\n * There are two kinds of clip-space conventions in active use in graphics APIs, differing in the\n * range of the Z axis: OpenGL (and thus GL ES and WebGL) use a Z range of [-1, 1] which matches\n * the X and Y axis ranges. Direct3D, Vulkan, Metal, and WebGPU all use a Z range of [0, 1], which\n * differs from the X and Y axis ranges, but makes sense from the perspective of a camera: a camera\n * can see to the left and right of it, above and below it, but only in front and not behind it.\n *\n * The [0, 1] convention for Z range also has better characteristics for \"reversed depth\". Since\n * floating point numbers have higher precision around 0 than around 1. We then get to choose where\n * to put the extra precise bits: close to the near plane, or close to the far plane.\n *\n * With OpenGL's [-1, 1] convention, both -1 and 1 have similar amounts of precision, so we don't\n * get to make the same choice, and our higher precision around 0 is stuck in the middle of the\n * scene, which doesn't particularly help.\n *\n * The gl-matrix library has two different kinds of entry points: {@method mat4.perpsective} will\n * generate a matrix with a [-1, 1] clip space, corresponding to {@see ClipSpaceNearZ.NegativeOne},\n * but {@method mat4.perspectiveZO} will generate a matrix with a [0, 1] clip space, corresponding\n * to {@see ClipSpaceNearZ.Zero}.\n *\n * This function does nothing if {@param dst} and {@param src} are the same.\n */\nfunction projectionMatrixConvertClipSpaceNearZ(m, dst, src) {\n    if (dst === src)\n        return;\n    if (dst === gDeviceApi.ClipSpaceNearZ.NEGATIVE_ONE)\n        projectionMatrixOpenGLFromD3D(m);\n    else if (dst === gDeviceApi.ClipSpaceNearZ.ZERO)\n        projectionMatrixD3DFromOpenGL(m);\n}\n\nfunction fillVec3v(d, offs, v, v3) {\n    if (v3 === void 0) { v3 = 0; }\n    d[offs + 0] = v[0];\n    d[offs + 1] = v[1];\n    d[offs + 2] = v[2];\n    d[offs + 3] = v3;\n    return 4;\n}\nfunction fillVec4(d, offs, v0, v1, v2, v3) {\n    if (v1 === void 0) { v1 = 0; }\n    if (v2 === void 0) { v2 = 0; }\n    if (v3 === void 0) { v3 = 0; }\n    d[offs + 0] = v0;\n    d[offs + 1] = v1;\n    d[offs + 2] = v2;\n    d[offs + 3] = v3;\n    return 4;\n}\nfunction fillVec4v(d, offs, v) {\n    d[offs + 0] = v[0];\n    d[offs + 1] = v[1];\n    d[offs + 2] = v[2];\n    d[offs + 3] = v[3];\n    return 4;\n}\nfunction fillColor(d, offs, c, a) {\n    if (a === void 0) { a = c.a; }\n    d[offs + 0] = c.r;\n    d[offs + 1] = c.g;\n    d[offs + 2] = c.b;\n    d[offs + 3] = a;\n    return 4;\n}\n// All of our matrices are row-major.\nfunction fillMatrix4x4(d, offs, m) {\n    // d[offs + 0] = m[0];\n    // d[offs + 1] = m[4];\n    // d[offs + 2] = m[8];\n    // d[offs + 3] = m[12];\n    // d[offs + 4] = m[1];\n    // d[offs + 5] = m[5];\n    // d[offs + 6] = m[9];\n    // d[offs + 7] = m[13];\n    // d[offs + 8] = m[2];\n    // d[offs + 9] = m[6];\n    // d[offs + 10] = m[10];\n    // d[offs + 11] = m[14];\n    // d[offs + 12] = m[3];\n    // d[offs + 13] = m[7];\n    // d[offs + 14] = m[11];\n    // d[offs + 15] = m[15];\n    d[offs + 0] = m[0];\n    d[offs + 1] = m[1];\n    d[offs + 2] = m[2];\n    d[offs + 3] = m[3];\n    d[offs + 4] = m[4];\n    d[offs + 5] = m[5];\n    d[offs + 6] = m[6];\n    d[offs + 7] = m[7];\n    d[offs + 8] = m[8];\n    d[offs + 9] = m[9];\n    d[offs + 10] = m[10];\n    d[offs + 11] = m[11];\n    d[offs + 12] = m[12];\n    d[offs + 13] = m[13];\n    d[offs + 14] = m[14];\n    d[offs + 15] = m[15];\n    return 4 * 4;\n}\n// export function fillMatrix4x3(d: Float32Array, offs: number, m: ReadonlyMat4): number {\n//   d[offs + 0] = m[0];\n//   d[offs + 1] = m[4];\n//   d[offs + 2] = m[8];\n//   d[offs + 3] = m[12];\n//   d[offs + 4] = m[1];\n//   d[offs + 5] = m[5];\n//   d[offs + 6] = m[9];\n//   d[offs + 7] = m[13];\n//   d[offs + 8] = m[2];\n//   d[offs + 9] = m[6];\n//   d[offs + 10] = m[10];\n//   d[offs + 11] = m[14];\n//   return 4 * 3;\n// }\n// export function fillMatrix3x2(d: Float32Array, offs: number, m: ReadonlyMat2d): number {\n//   // 3x2 matrices are actually sent across as 4x2.\n//   const ma = m[0],\n//     mb = m[1];\n//   const mc = m[2],\n//     md = m[3];\n//   const mx = m[4],\n//     my = m[5];\n//   d[offs + 0] = ma;\n//   d[offs + 1] = mc;\n//   d[offs + 2] = mx;\n//   d[offs + 3] = 0;\n//   d[offs + 4] = mb;\n//   d[offs + 5] = md;\n//   d[offs + 6] = my;\n//   d[offs + 7] = 0;\n//   return 4 * 2;\n// }\n// export function fillMatrix4x2(d: Float32Array, offs: number, m: ReadonlyMat4): number {\n//   // The bottom two rows are basically just ignored in a 4x2.\n//   d[offs + 0] = m[0];\n//   d[offs + 1] = m[4];\n//   d[offs + 2] = m[8];\n//   d[offs + 3] = m[12];\n//   d[offs + 4] = m[1];\n//   d[offs + 5] = m[5];\n//   d[offs + 6] = m[9];\n//   d[offs + 7] = m[13];\n//   return 4 * 2;\n// }\n\nexports.RenderInstFlags = void 0;\n(function (RenderInstFlags) {\n    RenderInstFlags[RenderInstFlags[\"None\"] = 0] = \"None\";\n    RenderInstFlags[RenderInstFlags[\"Indexed\"] = 1] = \"Indexed\";\n    RenderInstFlags[RenderInstFlags[\"AllowSkippingIfPipelineNotReady\"] = 2] = \"AllowSkippingIfPipelineNotReady\";\n    // Mostly for error checking.\n    RenderInstFlags[RenderInstFlags[\"Template\"] = 4] = \"Template\";\n    RenderInstFlags[RenderInstFlags[\"Draw\"] = 8] = \"Draw\";\n    // Which flags are inherited from templates...\n    RenderInstFlags[RenderInstFlags[\"InheritedFlags\"] = 3] = \"InheritedFlags\";\n})(exports.RenderInstFlags || (exports.RenderInstFlags = {}));\nvar RenderInst = /** @class */ (function () {\n    function RenderInst() {\n        this.sortKey = 0;\n        // Debugging pointer for whomever wants it...\n        this.debug = null;\n        this.uniforms = [];\n        this.bindingDescriptors = gDeviceApi.nArray(1, function () { return ({\n            bindingLayout: null,\n            samplerBindings: [],\n            uniformBufferBindings: [],\n        }); });\n        this.dynamicUniformBufferByteOffsets = gDeviceApi.nArray(4, function () { return 0; });\n        this.flags = 0;\n        this.vertexBuffers = null;\n        this.indexBuffer = null;\n        this.drawStart = 0;\n        this.drawCount = 0;\n        this.drawInstanceCount = 0;\n        this.renderPipelineDescriptor = {\n            inputLayout: null,\n            megaStateDescriptor: gDeviceApi.copyMegaState(gDeviceApi.defaultMegaState),\n            program: null,\n            topology: gDeviceApi.PrimitiveTopology.TRIANGLES,\n            colorAttachmentFormats: [],\n            depthStencilAttachmentFormat: null,\n            sampleCount: 1,\n        };\n        this.reset();\n    }\n    /**\n     * Resets a render inst to be boring, so it can re-enter the pool.\n     * Normally, you should not need to call this.\n     */\n    RenderInst.prototype.reset = function () {\n        this.sortKey = 0;\n        this.flags = exports.RenderInstFlags.AllowSkippingIfPipelineNotReady;\n        this.vertexBuffers = null;\n        this.indexBuffer = null;\n        this.renderPipelineDescriptor.inputLayout = null;\n    };\n    /**\n     * Copies the fields from another render inst {@param o} to this render inst.\n     * Normally, you should not need to call this.\n     */\n    RenderInst.prototype.setFromTemplate = function (o) {\n        var _a, _b;\n        gDeviceApi.setMegaStateFlags(this.renderPipelineDescriptor.megaStateDescriptor, o.renderPipelineDescriptor.megaStateDescriptor);\n        this.renderPipelineDescriptor.program = o.renderPipelineDescriptor.program;\n        this.renderPipelineDescriptor.inputLayout =\n            o.renderPipelineDescriptor.inputLayout;\n        this.renderPipelineDescriptor.topology =\n            o.renderPipelineDescriptor.topology;\n        this.renderPipelineDescriptor.colorAttachmentFormats.length = Math.max(this.renderPipelineDescriptor.colorAttachmentFormats.length, o.renderPipelineDescriptor.colorAttachmentFormats.length);\n        for (var i = 0; i < o.renderPipelineDescriptor.colorAttachmentFormats.length; i++)\n            this.renderPipelineDescriptor.colorAttachmentFormats[i] =\n                o.renderPipelineDescriptor.colorAttachmentFormats[i];\n        this.renderPipelineDescriptor.depthStencilAttachmentFormat =\n            o.renderPipelineDescriptor.depthStencilAttachmentFormat;\n        this.renderPipelineDescriptor.sampleCount =\n            o.renderPipelineDescriptor.sampleCount;\n        this.uniformBuffer = o.uniformBuffer;\n        this.uniforms = tslib.__spreadArray([], tslib.__read(o.uniforms), false);\n        this.drawCount = o.drawCount;\n        this.drawStart = o.drawStart;\n        this.drawInstanceCount = o.drawInstanceCount;\n        this.vertexBuffers = o.vertexBuffers;\n        this.indexBuffer = o.indexBuffer;\n        this.flags =\n            (this.flags & ~exports.RenderInstFlags.InheritedFlags) |\n                (o.flags & exports.RenderInstFlags.InheritedFlags);\n        this.sortKey = o.sortKey;\n        var tbd = this.bindingDescriptors[0], obd = o.bindingDescriptors[0];\n        this.setBindingLayout({\n            numSamplers: (_a = obd.samplerBindings) === null || _a === void 0 ? void 0 : _a.length,\n            numUniformBuffers: (_b = obd.uniformBufferBindings) === null || _b === void 0 ? void 0 : _b.length,\n        });\n        for (var i = 0; i <\n            Math.min(tbd.uniformBufferBindings.length, obd.uniformBufferBindings.length); i++)\n            tbd.uniformBufferBindings[i].size =\n                o.bindingDescriptors[0].uniformBufferBindings[i].size;\n        this.setSamplerBindingsFromTextureMappings(obd.samplerBindings);\n        for (var i = 0; i < o.dynamicUniformBufferByteOffsets.length; i++)\n            this.dynamicUniformBufferByteOffsets[i] =\n                o.dynamicUniformBufferByteOffsets[i];\n    };\n    RenderInst.prototype.validate = function () {\n        var _a;\n        // Validate uniform buffer bindings.\n        for (var i = 0; i < this.bindingDescriptors.length; i++) {\n            var bd = this.bindingDescriptors[i];\n            for (var j = 0; j < ((_a = bd.uniformBufferBindings) === null || _a === void 0 ? void 0 : _a.length); j++)\n                gDeviceApi.assert(bd.uniformBufferBindings[j].size > 0);\n        }\n        gDeviceApi.assert(this.drawCount > 0);\n    };\n    /**\n     * Set the {@see Program} that this render inst will render with. This is part of the automatic\n     * pipeline building facilities. At render time, a pipeline will be automatically and constructed from\n     * the pipeline parameters.\n     */\n    RenderInst.prototype.setProgram = function (program) {\n        this.renderPipelineDescriptor.program = program;\n    };\n    /**\n     * Set the {@see MegaStateDescriptor} that this render inst will render with. This is part of the automatic\n     * pipeline building facilities. At render time, a pipeline will be automatically and constructed from\n     * the pipeline parameters.\n     */\n    RenderInst.prototype.setMegaStateFlags = function (r) {\n        gDeviceApi.setMegaStateFlags(this.renderPipelineDescriptor.megaStateDescriptor, r);\n        return this.renderPipelineDescriptor.megaStateDescriptor;\n    };\n    /**\n     * Retrieve the {@see MegaStateDescriptor} property bag that this will render with. This is similar to\n     * {@see setMegaStateFlags} but allows you to set fields directly on the internal property bag, rather than\n     * merge them. This can be slightly more efficient.\n     */\n    RenderInst.prototype.getMegaStateFlags = function () {\n        return this.renderPipelineDescriptor.megaStateDescriptor;\n    };\n    /**\n     * Sets the vertex input configuration to be used by this render instance.\n     * The {@see InputLayout} is used to construct the pipeline as part of the automatic pipeline building\n     * facilities, while the {@see VertexBufferDescriptor} and {@see IndexBufferDescriptor} is used for the render.\n     */\n    RenderInst.prototype.setVertexInput = function (inputLayout, vertexBuffers, indexBuffer) {\n        this.vertexBuffers = vertexBuffers;\n        this.indexBuffer = indexBuffer;\n        this.renderPipelineDescriptor.inputLayout = inputLayout;\n    };\n    RenderInst.prototype.setBindingLayout = function (bindingLayout) {\n        gDeviceApi.assert(bindingLayout.numUniformBuffers <\n            this.dynamicUniformBufferByteOffsets.length);\n        for (var i = this.bindingDescriptors[0].uniformBufferBindings.length; i < bindingLayout.numUniformBuffers; i++)\n            this.bindingDescriptors[0].uniformBufferBindings.push({\n                binding: i,\n                buffer: null,\n                size: 0,\n            });\n        for (var i = this.bindingDescriptors[0].samplerBindings.length; i < bindingLayout.numSamplers; i++)\n            this.bindingDescriptors[0].samplerBindings.push({\n                sampler: null,\n                texture: null,\n            });\n    };\n    RenderInst.prototype.drawIndexes = function (indexCount, indexStart) {\n        if (indexStart === void 0) { indexStart = 0; }\n        this.flags = gDeviceApi.setBitFlagEnabled(this.flags, exports.RenderInstFlags.Indexed, true);\n        this.drawCount = indexCount;\n        this.drawStart = indexStart;\n        this.drawInstanceCount = 1;\n    };\n    RenderInst.prototype.drawIndexesInstanced = function (indexCount, instanceCount, indexStart) {\n        if (indexStart === void 0) { indexStart = 0; }\n        this.flags = gDeviceApi.setBitFlagEnabled(this.flags, exports.RenderInstFlags.Indexed, true);\n        this.drawCount = indexCount;\n        this.drawStart = indexStart;\n        this.drawInstanceCount = instanceCount;\n    };\n    RenderInst.prototype.drawPrimitives = function (primitiveCount, primitiveStart) {\n        if (primitiveStart === void 0) { primitiveStart = 0; }\n        this.flags = gDeviceApi.setBitFlagEnabled(this.flags, exports.RenderInstFlags.Indexed, false);\n        this.drawCount = primitiveCount;\n        this.drawStart = primitiveStart;\n        this.drawInstanceCount = 1;\n    };\n    /**\n     * account for WebGL1\n     */\n    RenderInst.prototype.setUniforms = function (bufferIndex, uniforms) {\n        if (uniforms.length === 0) {\n            return;\n        }\n        // use later in WebGL1\n        this.uniforms[bufferIndex] = uniforms;\n        // calc buffer size\n        var offset = 0;\n        var uboBuffer = [];\n        uniforms.forEach(function (uniform) {\n            var value = uniform.value;\n            // number | number[] | Float32Array\n            if (util.isNumber(value) ||\n                Array.isArray(value) ||\n                value instanceof Float32Array) {\n                var array = util.isNumber(value) ? [value] : value;\n                var formatByteSize = array.length > 4 ? 4 : array.length;\n                // std140 UBO layout\n                var emptySpace_1 = 4 - (offset % 4);\n                if (emptySpace_1 !== 4) {\n                    if (emptySpace_1 >= formatByteSize) ;\n                    else {\n                        offset += emptySpace_1;\n                        for (var j = 0; j < emptySpace_1; j++) {\n                            uboBuffer.push(0); // padding\n                        }\n                    }\n                }\n                offset += array.length;\n                uboBuffer.push.apply(uboBuffer, tslib.__spreadArray([], tslib.__read(array), false));\n            }\n        });\n        // padding\n        var emptySpace = 4 - (uboBuffer.length % 4);\n        if (emptySpace !== 4) {\n            for (var j = 0; j < emptySpace; j++) {\n                uboBuffer.push(0);\n            }\n        }\n        // upload UBO\n        var offs = this.allocateUniformBuffer(bufferIndex, uboBuffer.length);\n        var d = this.mapUniformBufferF32(bufferIndex);\n        for (var i = 0; i < uboBuffer.length; i += 4) {\n            offs += fillVec4(d, offs, uboBuffer[i], uboBuffer[i + 1], uboBuffer[i + 2], uboBuffer[i + 3]);\n        }\n    };\n    RenderInst.prototype.setUniformBuffer = function (uniformBuffer) {\n        this.uniformBuffer = uniformBuffer;\n    };\n    /**\n     * Allocates {@param wordCount} words from the uniform buffer and assigns it to the buffer\n     * slot at index {@param bufferIndex}. As a convenience, this also directly returns the same\n     * offset into the uniform buffer, in words, that would be returned by a subsequent call to\n     * {@see getUniformBufferOffset}.\n     */\n    RenderInst.prototype.allocateUniformBuffer = function (bufferIndex, wordCount) {\n        var _a;\n        gDeviceApi.assert(((_a = this.bindingDescriptors[0].uniformBufferBindings) === null || _a === void 0 ? void 0 : _a.length) <\n            this.dynamicUniformBufferByteOffsets.length);\n        this.dynamicUniformBufferByteOffsets[bufferIndex] =\n            this.uniformBuffer.allocateChunk(wordCount) << 2;\n        var dst = this.bindingDescriptors[0].uniformBufferBindings[bufferIndex];\n        dst.size = wordCount << 2;\n        return this.getUniformBufferOffset(bufferIndex);\n    };\n    /**\n     * Returns the offset into the uniform buffer, in words, that is assigned to the buffer slot\n     * at index {@param bufferIndex}, to be used with e.g. {@see mapUniformBufferF32}.\n     */\n    RenderInst.prototype.getUniformBufferOffset = function (bufferIndex) {\n        var wordOffset = this.dynamicUniformBufferByteOffsets[bufferIndex] >>> 2;\n        return wordOffset;\n    };\n    /**\n     * This is a convenience wrapper for {@see RenderDynamicUniformBuffer.mapBufferF32}, but uses\n     * the values previously assigned for the uniform buffer slot at index {@param bufferIndex}.\n     * Like {@see RenderDynamicUniformBuffer.mapBufferF32}, this does not return a slice for the\n     * buffer; you need to write to it with the correct uniform buffer offset; this will usually be\n     * returned by {@see allocateUniformBuffer}.\n     */\n    RenderInst.prototype.mapUniformBufferF32 = function (bufferIndex) {\n        return this.uniformBuffer.mapBufferF32();\n    };\n    /**\n     * Retrieve the {@see RenderDynamicUniformBuffer} that this render inst will use to allocate.\n     */\n    RenderInst.prototype.getUniformBuffer = function () {\n        return this.uniformBuffer;\n    };\n    /**\n     * Sets the {@param SamplerBinding}s in use by this render instance.\n     *\n     * Note that {@see RenderInst} has a method of doing late binding, intended to solve cases where live render\n     * targets are used, which can have difficult control flow consequences for users. Pass a string instead of a\n     * SamplerBinding to record that it can be resolved later, and use {@see RenderInst.resolveLateSamplerBinding}\n     * or equivalent to fill it in later.\n     */\n    RenderInst.prototype.setSamplerBindingsFromTextureMappings = function (mappings) {\n        mappings = mappings.filter(function (m) { return m; });\n        for (var i = 0; i < this.bindingDescriptors[0].samplerBindings.length; i++) {\n            var dst = this.bindingDescriptors[0].samplerBindings[i];\n            var binding = mappings[i];\n            if (binding === undefined || binding === null) {\n                dst.texture = null;\n                dst.sampler = null;\n                continue;\n            }\n            dst.texture = binding.texture;\n            dst.sampler = binding.sampler;\n        }\n    };\n    /**\n     * Sets whether this render inst should be skipped if the render pipeline isn't ready.\n     *\n     * Some draws of objects can be skipped if the pipelines aren't ready. Others are more\n     * crucial to draw, and so this can be set to force for the pipeline to become available.\n     *\n     * By default, this is true.\n     */\n    RenderInst.prototype.setAllowSkippingIfPipelineNotReady = function (v) {\n        this.flags = gDeviceApi.setBitFlagEnabled(this.flags, exports.RenderInstFlags.AllowSkippingIfPipelineNotReady, v);\n    };\n    RenderInst.prototype.setAttachmentFormatsFromRenderPass = function (device, passRenderer) {\n        var passDescriptor = device.queryRenderPass(passRenderer);\n        var sampleCount = -1;\n        for (var i = 0; i < passDescriptor.colorAttachment.length; i++) {\n            var colorAttachmentDescriptor = passDescriptor.colorAttachment[i] !== null\n                ? device.queryRenderTarget(passDescriptor.colorAttachment[i])\n                : null;\n            this.renderPipelineDescriptor.colorAttachmentFormats[i] =\n                colorAttachmentDescriptor !== null\n                    ? colorAttachmentDescriptor.format\n                    : null;\n            if (colorAttachmentDescriptor !== null) {\n                if (sampleCount === -1)\n                    sampleCount = colorAttachmentDescriptor.sampleCount;\n                else\n                    gDeviceApi.assert(sampleCount === colorAttachmentDescriptor.sampleCount);\n            }\n        }\n        var depthStencilAttachmentDescriptor = passDescriptor.depthStencilAttachment !== null\n            ? device.queryRenderTarget(passDescriptor.depthStencilAttachment)\n            : null;\n        this.renderPipelineDescriptor.depthStencilAttachmentFormat =\n            depthStencilAttachmentDescriptor !== null\n                ? depthStencilAttachmentDescriptor.format\n                : null;\n        if (depthStencilAttachmentDescriptor !== null) {\n            if (sampleCount === -1)\n                sampleCount = depthStencilAttachmentDescriptor.sampleCount;\n            else\n                gDeviceApi.assert(sampleCount == depthStencilAttachmentDescriptor.sampleCount);\n        }\n        gDeviceApi.assert(sampleCount > 0);\n        this.renderPipelineDescriptor.sampleCount = sampleCount;\n    };\n    RenderInst.prototype.drawOnPass = function (cache, passRenderer) {\n        var _this = this;\n        var device = cache.device;\n        this.setAttachmentFormatsFromRenderPass(device, passRenderer);\n        var gfxPipeline = cache.createRenderPipeline(this.renderPipelineDescriptor);\n        var pipelineReady = device.pipelineQueryReady(gfxPipeline);\n        if (!pipelineReady) {\n            if (this.flags & exports.RenderInstFlags.AllowSkippingIfPipelineNotReady) {\n                return false;\n            }\n            device.pipelineForceReady(gfxPipeline);\n        }\n        passRenderer.setPipeline(gfxPipeline);\n        passRenderer.setVertexInput(this.renderPipelineDescriptor.inputLayout, this.vertexBuffers, this.indexBuffer);\n        // upload uniforms\n        for (var i = 0; i < this.bindingDescriptors[0].uniformBufferBindings.length; i++) {\n            this.bindingDescriptors[0].uniformBufferBindings[i].buffer = gDeviceApi.assertExists(this.uniformBuffer.buffer);\n            this.bindingDescriptors[0].uniformBufferBindings[i].offset =\n                this.dynamicUniformBufferByteOffsets[i];\n        }\n        if (this.renderPipelineDescriptor.program.gl_program) {\n            this.uniforms.forEach(function (uniforms) {\n                var uniformsMap = {};\n                uniforms.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    uniformsMap[name] = value;\n                });\n                _this.renderPipelineDescriptor.program.setUniformsLegacy(uniformsMap);\n            });\n        }\n        // TODO: Support multiple binding descriptors.\n        var gfxBindings = cache.createBindings(tslib.__assign(tslib.__assign({}, this.bindingDescriptors[0]), { pipeline: gfxPipeline }));\n        passRenderer.setBindings(gfxBindings);\n        if (this.flags & exports.RenderInstFlags.Indexed) {\n            passRenderer.drawIndexed(this.drawCount, this.drawInstanceCount, this.drawStart, 0, 0);\n        }\n        else {\n            passRenderer.draw(this.drawCount, this.drawInstanceCount, this.drawStart, 0);\n        }\n        return true;\n    };\n    return RenderInst;\n}());\n\nvar renderInstCompareNone = null;\nfunction renderInstCompareSortKey(a, b) {\n    return a.sortKey - b.sortKey;\n}\nexports.RenderInstExecutionOrder = void 0;\n(function (RenderInstExecutionOrder) {\n    RenderInstExecutionOrder[RenderInstExecutionOrder[\"Forwards\"] = 0] = \"Forwards\";\n    RenderInstExecutionOrder[RenderInstExecutionOrder[\"Backwards\"] = 1] = \"Backwards\";\n})(exports.RenderInstExecutionOrder || (exports.RenderInstExecutionOrder = {}));\nvar RenderInstList = /** @class */ (function () {\n    function RenderInstList(compareFunction, executionOrder) {\n        if (compareFunction === void 0) { compareFunction = renderInstCompareSortKey; }\n        if (executionOrder === void 0) { executionOrder = exports.RenderInstExecutionOrder.Forwards; }\n        this.renderInsts = [];\n        this.usePostSort = false;\n        this.compareFunction = compareFunction;\n        this.executionOrder = executionOrder;\n    }\n    /**\n     * Determine whether to use post-sorting, based on some heuristics.\n     */\n    RenderInstList.prototype.checkUsePostSort = function () {\n        // Over a certain threshold, it's faster to push and then sort than insort directly...\n        this.usePostSort =\n            this.compareFunction !== null && this.renderInsts.length >= 500;\n    };\n    /**\n     * Insert a render inst to the list. This directly inserts the render inst to\n     * the position specified by the compare function, so the render inst must be\n     * fully constructed at this point.\n     */\n    RenderInstList.prototype.insertSorted = function (renderInst) {\n        if (this.compareFunction === null) {\n            this.renderInsts.push(renderInst);\n        }\n        else if (this.usePostSort) {\n            this.renderInsts.push(renderInst);\n        }\n        else {\n            gDeviceApi.spliceBisectRight(this.renderInsts, renderInst, this.compareFunction);\n        }\n        this.checkUsePostSort();\n    };\n    RenderInstList.prototype.submitRenderInst = function (renderInst) {\n        // TODO: drawCount = 0\n        // renderInst.validate();\n        renderInst.flags |= exports.RenderInstFlags.Draw;\n        this.insertSorted(renderInst);\n    };\n    RenderInstList.prototype.ensureSorted = function () {\n        if (this.usePostSort) {\n            if (this.renderInsts.length !== 0)\n                this.renderInsts.sort(this.compareFunction);\n            this.usePostSort = false;\n        }\n    };\n    RenderInstList.prototype.drawOnPassRendererNoReset = function (cache, passRenderer) {\n        this.ensureSorted();\n        if (this.executionOrder === exports.RenderInstExecutionOrder.Forwards) {\n            for (var i = 0; i < this.renderInsts.length; i++)\n                this.renderInsts[i].drawOnPass(cache, passRenderer);\n        }\n        else {\n            for (var i = this.renderInsts.length - 1; i >= 0; i--)\n                this.renderInsts[i].drawOnPass(cache, passRenderer);\n        }\n    };\n    RenderInstList.prototype.reset = function () {\n        this.renderInsts.length = 0;\n    };\n    RenderInstList.prototype.drawOnPassRenderer = function (cache, passRenderer) {\n        this.drawOnPassRendererNoReset(cache, passRenderer);\n        this.reset();\n    };\n    return RenderInstList;\n}());\n\nvar RenderInstPool = /** @class */ (function () {\n    function RenderInstPool() {\n        // The pool contains all render insts that we've ever created.\n        this.pool = [];\n        // The number of render insts currently allocated out to the user.\n        this.allocCount = 0;\n    }\n    RenderInstPool.prototype.allocRenderInstIndex = function () {\n        this.allocCount++;\n        if (this.allocCount > this.pool.length) {\n            this.pool.push(new RenderInst());\n        }\n        return this.allocCount - 1;\n    };\n    RenderInstPool.prototype.popRenderInst = function () {\n        this.allocCount--;\n    };\n    RenderInstPool.prototype.reset = function () {\n        for (var i = 0; i < this.pool.length; i++) {\n            this.pool[i].reset();\n        }\n        this.allocCount = 0;\n    };\n    RenderInstPool.prototype.destroy = function () {\n        this.pool.length = 0;\n        this.allocCount = 0;\n    };\n    return RenderInstPool;\n}());\n\nvar RenderInstManager = /** @class */ (function () {\n    function RenderInstManager(renderCache) {\n        this.renderCache = renderCache;\n        this.instPool = new RenderInstPool();\n        this.templatePool = new RenderInstPool();\n        this.simpleRenderInstList = new RenderInstList();\n        this.currentRenderInstList = this.simpleRenderInstList;\n    }\n    /**\n     * Creates a new RenderInst object and returns it. If there is a template\n     * pushed onto the template stack, then its values will be used as a base for this\n     * render inst.\n     */\n    RenderInstManager.prototype.newRenderInst = function () {\n        var templateIndex = this.templatePool.allocCount - 1;\n        var renderInstIndex = this.instPool.allocRenderInstIndex();\n        var renderInst = this.instPool.pool[renderInstIndex];\n        renderInst.debug = null;\n        if (templateIndex >= 0)\n            renderInst.setFromTemplate(this.templatePool.pool[templateIndex]);\n        return renderInst;\n    };\n    /**\n     * Submits RenderInst to the current render inst list. Note that\n     * this assumes the render inst was fully filled in, so do not modify it\n     * after submitting it.\n     */\n    RenderInstManager.prototype.submitRenderInst = function (renderInst, list) {\n        if (list === void 0) { list = this.currentRenderInstList; }\n        list.submitRenderInst(renderInst);\n    };\n    /**\n     * Sets the currently active render inst list. This is the list that will\n     * be used by @param submitRenderInst}. If you use this function, please\n     * make sure to call {@see disableSimpleMode} when the RenderInstManager\n     * is created, to ensure that nobody uses the \"legacy\" APIs. Failure to do\n     * so might cause memory leaks or other problems.\n     */\n    RenderInstManager.prototype.setCurrentRenderInstList = function (list) {\n        gDeviceApi.assert(this.simpleRenderInstList === null);\n        this.currentRenderInstList = list;\n    };\n    /**\n     * Pushes a new template render inst to the template stack. All properties set\n     * on the topmost template on the template stack will be the defaults for both\n     * for any future render insts created. Once done with a template, call\n     * {@param popTemplateRenderInst} to pop it off the template stack.\n     */\n    RenderInstManager.prototype.pushTemplateRenderInst = function () {\n        var templateIndex = this.templatePool.allocCount - 1;\n        var newTemplateIndex = this.templatePool.allocRenderInstIndex();\n        var newTemplate = this.templatePool.pool[newTemplateIndex];\n        if (templateIndex >= 0)\n            newTemplate.setFromTemplate(this.templatePool.pool[templateIndex]);\n        newTemplate.flags |= exports.RenderInstFlags.Template;\n        return newTemplate;\n    };\n    RenderInstManager.prototype.popTemplateRenderInst = function () {\n        this.templatePool.popRenderInst();\n    };\n    /**\n     * Retrieves the current template render inst on the top of the template stack.\n     */\n    RenderInstManager.prototype.getTemplateRenderInst = function () {\n        var templateIndex = this.templatePool.allocCount - 1;\n        return this.templatePool.pool[templateIndex];\n    };\n    /**\n     * Reset all allocated render insts. This should be called at the end of the frame,\n     * once done with all of the allocated render insts and render inst lists.\n     */\n    RenderInstManager.prototype.resetRenderInsts = function () {\n        // Retire the existing render insts.\n        this.instPool.reset();\n        if (this.simpleRenderInstList !== null)\n            this.simpleRenderInstList.reset();\n        // Ensure we aren't leaking templates.\n        gDeviceApi.assert(this.templatePool.allocCount === 0);\n    };\n    RenderInstManager.prototype.destroy = function () {\n        this.instPool.destroy();\n        this.renderCache.destroy();\n    };\n    /**\n     * Disables the \"simple\" render inst list management API.\n     */\n    RenderInstManager.prototype.disableSimpleMode = function () {\n        // This is a one-way street!\n        this.simpleRenderInstList = null;\n    };\n    // /**\n    //  * Execute all scheduled render insts in {@param list} onto the {@param RenderPass},\n    //  * using {@param device} and {@param cache} to create any device-specific resources\n    //  * necessary to complete the draws.\n    //  */\n    // drawListOnPassRenderer(list: RenderInstList, passRenderer: RenderPass): void {\n    //   list.drawOnPassRenderer(this.renderCache, passRenderer);\n    // }\n    RenderInstManager.prototype.drawOnPassRenderer = function (passRenderer) {\n        var list = gDeviceApi.assertExists(this.simpleRenderInstList);\n        list.drawOnPassRenderer(this.renderCache, passRenderer);\n    };\n    RenderInstManager.prototype.drawOnPassRendererNoReset = function (passRenderer) {\n        var list = gDeviceApi.assertExists(this.simpleRenderInstList);\n        list.drawOnPassRendererNoReset(this.renderCache, passRenderer);\n    };\n    return RenderInstManager;\n}());\n\nvar RenderHelper = /** @class */ (function () {\n    function RenderHelper(parameters) {\n        this.parameters = parameters;\n    }\n    RenderHelper.prototype.getDevice = function () {\n        return this.device;\n    };\n    RenderHelper.prototype.setDevice = function (device) {\n        this.device = device;\n        this.renderCache = new RenderCache(device);\n        this.renderGraph = new RenderGraph(this.device);\n        this.renderInstManager = new RenderInstManager(this.renderCache);\n        this.uniformBuffer = new DynamicUniformBuffer(this.device);\n        // this.debugThumbnails = new DebugThumbnailDrawer(this);\n    };\n    RenderHelper.prototype.pushTemplateRenderInst = function () {\n        var template = this.renderInstManager.pushTemplateRenderInst();\n        template.setUniformBuffer(this.uniformBuffer);\n        return template;\n    };\n    RenderHelper.prototype.prepareToRender = function () {\n        this.uniformBuffer.prepareToRender();\n    };\n    RenderHelper.prototype.destroy = function () {\n        if (this.uniformBuffer) {\n            this.uniformBuffer.destroy();\n        }\n        if (this.renderInstManager) {\n            this.renderInstManager.destroy();\n        }\n        if (this.renderCache) {\n            this.renderCache.destroy();\n        }\n        if (this.renderGraph) {\n            this.renderGraph.destroy();\n        }\n    };\n    // getDebugTextDrawer(): TextDrawer | null {\n    //   return null;\n    // }\n    RenderHelper.prototype.getCache = function () {\n        return this.renderCache;\n    };\n    RenderHelper.prototype.getDefines = function () {\n        var _a, _b, _c;\n        return {\n            USE_TONEMAPPING: ((_a = this.parameters) === null || _a === void 0 ? void 0 : _a.toneMapping) &&\n                ((_b = this.parameters) === null || _b === void 0 ? void 0 : _b.toneMapping) !== exports.ToneMapping.NONE,\n            toneMapping: (_c = this.parameters) === null || _c === void 0 ? void 0 : _c.toneMapping,\n        };\n    };\n    return RenderHelper;\n}());\n\nvar RGRenderTargetDescription = /** @class */ (function () {\n    function RGRenderTargetDescription(format) {\n        this.format = format;\n        this.width = 0;\n        this.height = 0;\n        this.sampleCount = 0;\n        this.colorClearColor = 'load';\n        this.depthClearValue = 'load';\n        this.stencilClearValue = 'load';\n    }\n    /**\n     * Set the dimensions of a render target description.\n     */\n    RGRenderTargetDescription.prototype.setDimensions = function (width, height, sampleCount) {\n        this.width = width;\n        this.height = height;\n        this.sampleCount = sampleCount;\n    };\n    RGRenderTargetDescription.prototype.copyDimensions = function (desc) {\n        this.width = desc.width;\n        this.height = desc.height;\n        this.sampleCount = desc.sampleCount;\n    };\n    return RGRenderTargetDescription;\n}());\n\nfunction makeAttachmentClearDescriptor(clearColor) {\n    return {\n        colorClearColor: clearColor,\n        // depthClearValue: reverseDepthForClearValue(1.0),\n        depthClearValue: 1,\n        stencilClearValue: 0.0,\n    };\n}\nvar standardFullClearRenderPassDescriptor = makeAttachmentClearDescriptor(gDeviceApi.colorNewFromRGBA(0.88, 0.88, 0.88, 1.0));\nvar opaqueBlackFullClearRenderPassDescriptor = makeAttachmentClearDescriptor(gDeviceApi.OpaqueBlack);\nvar opaqueWhiteFullClearRenderPassDescriptor = makeAttachmentClearDescriptor(gDeviceApi.OpaqueWhite);\nexports.AntialiasingMode = void 0;\n(function (AntialiasingMode) {\n    AntialiasingMode[AntialiasingMode[\"None\"] = 0] = \"None\";\n    AntialiasingMode[AntialiasingMode[\"FXAA\"] = 1] = \"FXAA\";\n    AntialiasingMode[AntialiasingMode[\"MSAAx4\"] = 2] = \"MSAAx4\";\n})(exports.AntialiasingMode || (exports.AntialiasingMode = {}));\nfunction selectFormatSimple(slot) {\n    if (slot === exports.RGAttachmentSlot.Color0) {\n        return gDeviceApi.Format.U8_RGBA_RT;\n    }\n    else if (slot === exports.RGAttachmentSlot.DepthStencil) {\n        return gDeviceApi.Format.D24_S8;\n    }\n    else {\n        throw new Error('whoops');\n    }\n}\nfunction selectSampleCount(renderInput) {\n    if (renderInput.antialiasingMode === exports.AntialiasingMode.MSAAx4) {\n        return 4;\n    }\n    else {\n        return 1;\n    }\n}\nfunction setBackbufferDescSimple(desc, renderInput) {\n    var sampleCount = selectSampleCount(renderInput);\n    desc.setDimensions(renderInput.backbufferWidth, renderInput.backbufferHeight, sampleCount);\n}\nfunction makeBackbufferDescSimple(slot, renderInput, clearDescriptor) {\n    var pixelFormat = selectFormatSimple(slot);\n    var desc = new RGRenderTargetDescription(pixelFormat);\n    setBackbufferDescSimple(desc, renderInput);\n    if (clearDescriptor !== null) {\n        desc.colorClearColor = clearDescriptor.colorClearColor;\n        desc.depthClearValue = clearDescriptor.depthClearValue;\n        desc.stencilClearValue = clearDescriptor.stencilClearValue;\n    }\n    return desc;\n}\n\nvar TextureMapping = /** @class */ (function () {\n    function TextureMapping() {\n        this.texture = null;\n        this.sampler = null;\n        this.width = 0;\n        this.height = 0;\n        this.lodBias = 0;\n    }\n    // GL sucks. This is a convenience when building texture matrices.\n    // The core renderer does not use this code at all.\n    // flipY: boolean = false;\n    TextureMapping.prototype.reset = function () {\n        this.texture = null;\n        this.sampler = null;\n        this.width = 0;\n        this.height = 0;\n        this.lodBias = 0;\n        // this.flipY = false;\n    };\n    TextureMapping.prototype.copy = function (other) {\n        this.texture = other.texture;\n        this.sampler = other.sampler;\n        this.width = other.width;\n        this.height = other.height;\n        this.lodBias = other.lodBias;\n        // this.flipY = other.flipY;\n    };\n    return TextureMapping;\n}());\n\n// Public API for saving off copies of images for temporal-style effects.\nvar TemporalTexture = /** @class */ (function () {\n    function TemporalTexture() {\n        // These names might be a bit confusing, but they're named relative to the graph.\n        // outputTexture is the target of a resolve, inputTexture is the source for sampling.\n        this.inputTexture = null;\n        this.outputTexture = null;\n    }\n    TemporalTexture.prototype.setDescription = function (device, desc) {\n        // Updating the description will happen at the start of the frame,\n        // so we need to keep the inputTexture alive (the previous frame's texture),\n        // and create a new outputTexture.\n        if (this.inputTexture !== this.outputTexture) {\n            if (this.inputTexture !== null)\n                this.inputTexture.destroy();\n            // Set the input texture to our old output texture.\n            this.inputTexture = this.outputTexture;\n        }\n        gDeviceApi.assert(this.inputTexture === this.outputTexture);\n        if (this.outputTexture !== null &&\n            this.outputTexture.matchesDescription(desc))\n            return;\n        this.outputTexture = new SingleSampledTexture(device, desc);\n        if (this.inputTexture === null)\n            this.inputTexture = this.outputTexture;\n    };\n    TemporalTexture.prototype.getTextureForSampling = function () {\n        return this.inputTexture !== null ? this.inputTexture.texture : null;\n    };\n    TemporalTexture.prototype.getTextureForResolving = function () {\n        var _a;\n        return (_a = this.outputTexture) === null || _a === void 0 ? void 0 : _a.texture;\n    };\n    TemporalTexture.prototype.destroy = function () {\n        if (this.outputTexture !== null &&\n            this.outputTexture !== this.inputTexture) {\n            this.outputTexture.destroy();\n            this.outputTexture = null;\n        }\n        if (this.inputTexture !== null) {\n            this.inputTexture.destroy();\n            this.inputTexture = null;\n        }\n    };\n    return TemporalTexture;\n}());\n\nvar Light = /** @class */ (function (_super) {\n    tslib.__extends(Light, _super);\n    function Light(_a) {\n        if (_a === void 0) { _a = {}; }\n        var style = _a.style, rest = tslib.__rest(_a, [\"style\"]);\n        return _super.call(this, tslib.__assign({ type: Light.tag, style: tslib.__assign({ intensity: Math.PI }, style) }, rest)) || this;\n    }\n    Light.tag = 'light';\n    return Light;\n}(gLite.DisplayObject));\n\nexports.FogType = void 0;\n(function (FogType) {\n    FogType[FogType[\"NONE\"] = 0] = \"NONE\";\n    FogType[FogType[\"EXP\"] = 1] = \"EXP\";\n    FogType[FogType[\"EXP2\"] = 2] = \"EXP2\";\n    FogType[FogType[\"LINEAR\"] = 3] = \"LINEAR\";\n})(exports.FogType || (exports.FogType = {}));\nvar Fog = /** @class */ (function (_super) {\n    tslib.__extends(Fog, _super);\n    function Fog(_a) {\n        if (_a === void 0) { _a = {}; }\n        var style = _a.style, rest = tslib.__rest(_a, [\"style\"]);\n        return _super.call(this, tslib.__assign({ type: Fog.tag, style: tslib.__assign({ type: exports.FogType.NONE, fill: 'black', start: 1, end: 1000, density: 0 }, style) }, rest)) || this;\n    }\n    Fog.tag = 'fog';\n    return Fog;\n}(gLite.DisplayObject));\n\nfunction makeDataBuffer(device, usage, data, hint) {\n    if (hint === void 0) { hint = gDeviceApi.BufferFrequencyHint.STATIC; }\n    var buffer = device.createBuffer({\n        viewOrSize: data.byteLength,\n        usage: usage,\n        hint: hint,\n    });\n    buffer.setSubData(0, new Uint8Array(data));\n    return buffer;\n}\nexports.GeometryEvent = void 0;\n(function (GeometryEvent) {\n    GeometryEvent[\"CHANGED\"] = \"changed\";\n})(exports.GeometryEvent || (exports.GeometryEvent = {}));\n/**\n * just hold descriptors of buffers & indices, won't use underlying GPU resources\n */\nvar BufferGeometry = /** @class */ (function (_super) {\n    tslib.__extends(BufferGeometry, _super);\n    function BufferGeometry(device, props) {\n        if (props === void 0) { props = {}; }\n        var _this = _super.call(this) || this;\n        _this.device = device;\n        _this.props = props;\n        _this.drawMode = gDeviceApi.PrimitiveTopology.TRIANGLES;\n        _this.vertexBuffers = [];\n        _this.vertices = [];\n        _this.inputLayoutDescriptor = {\n            vertexBufferDescriptors: [],\n            indexBufferFormat: null,\n            program: null,\n        };\n        _this.vertexCount = 0;\n        _this.instancedCount = 0;\n        _this.indexStart = 0;\n        _this.primitiveStart = 0;\n        _this.dirty = true;\n        _this.meshes = [];\n        return _this;\n    }\n    BufferGeometry.prototype.validate = function (mesh) {\n        return true;\n    };\n    BufferGeometry.prototype.build = function (meshes) { };\n    BufferGeometry.prototype.computeBoundingBox = function () {\n        return new gLite.AABB();\n    };\n    BufferGeometry.prototype.setIndexBuffer = function (indices) {\n        if (this.indexBuffer) {\n            this.indexBuffer.destroy();\n        }\n        this.indexBuffer = makeDataBuffer(this.device, gDeviceApi.BufferUsage.INDEX, new Uint32Array(ArrayBuffer.isView(indices) ? indices.buffer : indices)\n            .buffer);\n        this.indices = indices;\n        this.inputLayoutDescriptor.indexBufferFormat = gDeviceApi.Format.U32_R;\n        return this;\n    };\n    BufferGeometry.prototype.setVertexBuffer = function (descriptor) {\n        var _this = this;\n        var bufferIndex = descriptor.bufferIndex, byteStride = descriptor.byteStride, stepMode = descriptor.stepMode, attributes = descriptor.attributes, data = descriptor.data;\n        this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex] = {\n            arrayStride: byteStride,\n            stepMode: stepMode,\n            attributes: [],\n        };\n        this.vertices[bufferIndex] = data;\n        attributes.forEach(function (_a) {\n            var format = _a.format, bufferByteOffset = _a.bufferByteOffset, location = _a.location, divisor = _a.divisor; _a.byteStride;\n            var existed = _this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex].attributes.find(function (e) { return e.shaderLocation === location; });\n            if (existed) {\n                existed.format = format;\n                existed.offset = bufferByteOffset;\n                existed.divisor = divisor;\n            }\n            else {\n                _this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex].attributes.push({\n                    format: format,\n                    offset: bufferByteOffset,\n                    shaderLocation: location,\n                    divisor: divisor,\n                });\n            }\n        });\n        // create GPUBuffer\n        if (this.vertexBuffers[bufferIndex]) {\n            this.vertexBuffers[bufferIndex].destroy();\n        }\n        var buffer = makeDataBuffer(this.device, gDeviceApi.BufferUsage.VERTEX, data.buffer, gDeviceApi.BufferFrequencyHint.DYNAMIC);\n        this.vertexBuffers[bufferIndex] = buffer;\n        return this;\n    };\n    BufferGeometry.prototype.getVertexBuffer = function (bufferIndex) {\n        return this.vertexBuffers[bufferIndex];\n    };\n    BufferGeometry.prototype.updateVertexBuffer = function (bufferIndex, location, index, data) {\n        var bufferDescriptor = this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex];\n        if (!bufferDescriptor) {\n            return;\n        }\n        var arrayStride = bufferDescriptor.arrayStride;\n        var descriptor = this.inputLayoutDescriptor.vertexBufferDescriptors[bufferIndex].attributes.find(function (d) { return d.shaderLocation === location; });\n        if (descriptor) {\n            var vertexBuffer = this.getVertexBuffer(bufferIndex);\n            var offset = index * arrayStride;\n            vertexBuffer.setSubData(descriptor.offset + offset, data);\n            // TODO: update vertices\n            // this.vertices[bufferIndex] = data;\n        }\n        this.emit(exports.GeometryEvent.CHANGED);\n    };\n    BufferGeometry.prototype.updateIndices = function (indices, offset) {\n        if (offset === void 0) { offset = 0; }\n        if (this.indexBuffer) {\n            this.indexBuffer.setSubData(offset, new Uint8Array(ArrayBuffer.isView(indices) ? indices : new Uint32Array(indices)));\n        }\n        return this;\n    };\n    BufferGeometry.prototype.destroy = function () {\n        this.vertexBuffers.forEach(function (buffer) {\n            if (buffer) {\n                buffer.destroy();\n            }\n        });\n        if (this.indexBuffer) {\n            this.indexBuffer.destroy();\n        }\n        this.inputLayoutDescriptor.vertexBufferDescriptors = [];\n        this.indexBuffer = undefined;\n        this.vertexBuffers = [];\n        this.indices = undefined;\n        this.vertices = [];\n        this.vertexCount = 0;\n        this.instancedCount = 0;\n    };\n    return BufferGeometry;\n}(EventEmitter));\n\nvar vert$5 = \"#define GLSLIFY 1\\nlayout(location = 0) in vec2 a_Position;\\n\\nout vec2 v_TexCoord;\\n\\nvoid main() {\\n  v_TexCoord = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n\\n  #ifdef VIEWPORT_ORIGIN_TL\\n    v_TexCoord.y = 1.0 - v_TexCoord.y;\\n  #endif\\n}\"; // eslint-disable-line\n\nvar frag$5 = \"#define GLSLIFY 1\\nuniform sampler2D u_Texture;\\nin vec2 v_TexCoord;\\n\\nout vec4 outputColor;\\n\\nfloat MonochromeNTSC(vec3 t_Color) {\\n  // NTSC primaries.\\n  return dot(t_Color.rgb, vec3(0.299, 0.587, 0.114));\\n}\\n\\nvec4 FXAA(PD_SAMPLER_2D(t_Texture), in vec2 t_PixelCenter, in vec2 t_InvResolution) {\\n  // FXAA v2, based on implementations:\\n  // http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/\\n  // https://github.com/mitsuhiko/webgl-meincraft\\n\\n  float lumaMM = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy).rgb);\\n\\n  #if 1\\n    vec2 t_PixelTopLeft = t_PixelCenter.xy - t_InvResolution.xy * 0.5;\\n    float lumaNW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy)             .rgb);\\n    float lumaNE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy + vec2(1.0, 0.0)).rgb);\\n    float lumaSW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy + vec2(0.0, 1.0)).rgb);\\n    float lumaSE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelTopLeft.xy + vec2(1.0, 1.0)).rgb);\\n  #else\\n    // We're at the pixel center -- pixel edges are 0.5 units away.\\n    // NOTE(jstpierre): mitsuhiko's port seems to get this wrong?\\n    vec2 t_PixelSize = t_InvResolution.xy * 0.5;\\n\\n    float lumaNW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2(-1.0, -1.0)).rgb);\\n    float lumaNE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2( 1.0, -1.0)).rgb);\\n    float lumaSW = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2(-1.0,  1.0)).rgb);\\n    float lumaSE = MonochromeNTSC(texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + t_PixelSize * vec2( 1.0,  1.0)).rgb);\\n  #endif\\n\\n  vec2 dir; \\n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n  dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n  const float FXAA_REDUCE_MIN = 1.0/128.0;\\n  const float FXAA_REDUCE_MUL = 1.0/8.0;\\n  const float FXAA_SPAN_MAX = 8.0;\\n\\n  float dirReduce = max(\\n      (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\\n      FXAA_REDUCE_MIN);\\n\\n  float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\\n  dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * u_InvResolution.xy;\\n\\n  float lumaMin = min(lumaMM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n  float lumaMax = max(lumaMM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n  vec4 rgbA = (1.0/2.0) * (\\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (1.0/3.0 - 0.5)) +\\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (2.0/3.0 - 0.5)));\\n  vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (0.0/3.0 - 0.5)) +\\n      texture(PU_SAMPLER_2D(t_Texture), t_PixelCenter.xy + dir * (3.0/3.0 - 0.5)));\\n  float lumaB = MonochromeNTSC(rgbB.rgb);\\n\\n  vec4 rgbOutput = ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\\n  return rgbOutput;\\n}\\n\\nvoid main() {\\n  outputColor = FXAA(PP_SAMPLER_2D(u_Texture), v_TexCoord.xy, u_InvResolution.xy);\\n}\"; // eslint-disable-line\n\nvar FXAAProgram = /** @class */ (function (_super) {\n    tslib.__extends(FXAAProgram, _super);\n    function FXAAProgram() {\n        var _this = _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments), false)) || this;\n        _this.features = {};\n        _this.both = \"\\nlayout(std140) uniform ub_Params {\\n    vec4 u_Misc[1];\\n};\\n#define u_InvResolution (u_Misc[0].xy)\\n\";\n        _this.vert = vert$5;\n        _this.frag = frag$5;\n        return _this;\n    }\n    return FXAAProgram;\n}(DeviceProgram));\nvar textureMapping = gDeviceApi.nArray(1, function () { return new TextureMapping(); });\nvar geometry;\nvar inputLayout;\nfunction pushFXAAPass(builder, renderHelper, renderInput, mainColorTargetID) {\n    builder.pushPass(function (pass) {\n        pass.setDebugName('FXAA');\n        pass.attachRenderTargetID(exports.RGAttachmentSlot.Color0, mainColorTargetID);\n        var mainColorResolveTextureID = builder.resolveRenderTarget(mainColorTargetID);\n        pass.attachResolveTexture(mainColorResolveTextureID);\n        var renderInst = renderHelper.renderInstManager.newRenderInst();\n        renderInst.setUniformBuffer(renderHelper.uniformBuffer);\n        renderInst.setAllowSkippingIfPipelineNotReady(false);\n        renderInst.setMegaStateFlags(gDeviceApi.fullscreenMegaState);\n        renderInst.setBindingLayout({ numUniformBuffers: 1, numSamplers: 1 });\n        renderInst.drawPrimitives(3);\n        // since gl_VertexID is not available in GLSL 100, we need to use a geometry\n        var offs = renderInst.allocateUniformBuffer(0, 4);\n        var d = renderInst.mapUniformBufferF32(0);\n        fillVec4(d, offs, 1.0 / renderInput.backbufferWidth, 1.0 / renderInput.backbufferHeight);\n        var fxaaProgram = new FXAAProgram();\n        var program = renderHelper.renderCache.createProgramSimple(fxaaProgram);\n        renderInst.setProgram(program);\n        if (!geometry) {\n            geometry = new BufferGeometry(renderHelper.getDevice());\n            geometry.setVertexBuffer({\n                bufferIndex: 0,\n                byteStride: 4 * 2,\n                stepMode: gDeviceApi.VertexStepMode.VERTEX,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_RG,\n                        bufferByteOffset: 4 * 0,\n                        location: 0,\n                    },\n                ],\n                // rendering a fullscreen triangle instead of quad\n                // @see https://www.saschawillems.de/blog/2016/08/13/vulkan-tutorial-on-rendering-a-fullscreen-quad-without-buffers/\n                data: new Float32Array([1, 3, -3, -1, 1, -1]),\n            });\n            geometry.vertexCount = 3;\n            inputLayout = renderHelper\n                .getCache()\n                .createInputLayout(geometry.inputLayoutDescriptor);\n        }\n        pass.exec(function (passRenderer, scope) {\n            textureMapping[0].texture = scope.getResolveTextureForID(mainColorResolveTextureID);\n            renderInst.setSamplerBindingsFromTextureMappings(textureMapping);\n            renderInst.setVertexInput(inputLayout, geometry.vertexBuffers.map(function (buffer) { return ({\n                buffer: buffer,\n                byteOffset: 0,\n            }); }), null);\n            renderInst.drawOnPass(renderHelper.renderCache, passRenderer);\n        });\n    });\n}\n\n// scene uniform block index\nvar SceneUniformBufferIndex = 0;\n// uniforms in scene level\nvar SceneUniform;\n(function (SceneUniform) {\n    SceneUniform[\"PROJECTION_MATRIX\"] = \"u_ProjectionMatrix\";\n    SceneUniform[\"VIEW_MATRIX\"] = \"u_ViewMatrix\";\n    SceneUniform[\"CAMERA_POSITION\"] = \"u_CameraPosition\";\n    SceneUniform[\"DEVICE_PIXEL_RATIO\"] = \"u_DevicePixelRatio\";\n    SceneUniform[\"VIEWPORT\"] = \"u_Viewport\";\n    SceneUniform[\"IS_ORTHO\"] = \"u_IsOrtho\";\n    SceneUniform[\"IS_PICKING\"] = \"u_IsPicking\";\n})(SceneUniform || (SceneUniform = {}));\nvar RenderGraphPlugin = /** @class */ (function () {\n    function RenderGraphPlugin(renderHelper, lightPool, texturePool, batchManager, options) {\n        this.renderHelper = renderHelper;\n        this.lightPool = lightPool;\n        this.texturePool = texturePool;\n        this.batchManager = batchManager;\n        this.options = options;\n        this.renderLists = {\n            /**\n             * used in main forward rendering pass\n             */\n            world: new RenderInstList(),\n            /**\n             * used in picking pass, should disable blending\n             */\n            picking: new RenderInstList(),\n        };\n    }\n    RenderGraphPlugin.prototype.getDevice = function () {\n        return this.device;\n    };\n    RenderGraphPlugin.prototype.getSwapChain = function () {\n        return this.swapChain;\n    };\n    RenderGraphPlugin.prototype.getRenderLists = function () {\n        return this.renderLists;\n    };\n    RenderGraphPlugin.prototype.apply = function (context) {\n        var _this = this;\n        this.context = context;\n        var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;\n        var canvas = renderingContext.root.ownerDocument.defaultView;\n        config.disableRenderHooks = true;\n        var handleMounted = function (e) {\n            var object = e.target;\n            // collect lights\n            if (object.nodeName === Light.tag) {\n                _this.lightPool.addLight(object);\n                return;\n            }\n            else if (object.nodeName === Fog.tag) {\n                _this.lightPool.addFog(object);\n                return;\n            }\n            // @ts-ignore\n            if (!object.renderable3D) {\n                // @ts-ignore\n                object.renderable3D = new Renderable3D();\n            }\n            _this.batchManager.add(object);\n        };\n        var handleUnmounted = function (e) {\n            var _a, _b;\n            var object = e.target;\n            if (object.nodeName === Light.tag) {\n                _this.lightPool.removeLight(object);\n                return;\n            }\n            else if (object.nodeName === Fog.tag) {\n                _this.lightPool.removeFog(object);\n                return;\n            }\n            else if (object.nodeName === gLite.Shape.MESH) {\n                if ((_a = object.style.geometry) === null || _a === void 0 ? void 0 : _a.meshes) {\n                    var index = object.style.geometry.meshes.indexOf(object);\n                    if (index > -1) {\n                        object.style.geometry.meshes.splice(index, 1);\n                    }\n                }\n                if ((_b = object.style.material) === null || _b === void 0 ? void 0 : _b.meshes) {\n                    var index = object.style.material.meshes.indexOf(object);\n                    if (index > -1) {\n                        object.style.material.meshes.splice(index, 1);\n                    }\n                }\n            }\n            if (_this.swapChain) {\n                _this.batchManager.remove(object);\n            }\n            // @ts-ignore\n            delete object.renderable3D;\n            // entity.removeComponent(Geometry3D, true);\n            // entity.removeComponent(Material3D, true);\n            // entity.removeComponent(Renderable3D, true);\n        };\n        var handleAttributeChanged = function (e) {\n            if (_this.swapChain) {\n                var object = e.target;\n                var attrName = e.attrName, newValue = e.newValue;\n                if (attrName === 'zIndex') {\n                    object.parentNode.forEach(function (child) {\n                        _this.batchManager.changeRenderOrder(child, child.sortable.renderOrder);\n                    });\n                }\n                else {\n                    _this.batchManager.updateAttribute(object, attrName, newValue);\n                }\n            }\n        };\n        var handleBoundsChanged = function (e) {\n            if (_this.swapChain) {\n                var object = e.target;\n                _this.batchManager.updateAttribute(object, 'modelMatrix', null);\n            }\n        };\n        renderingService.hooks.initAsync.tapPromise(RenderGraphPlugin.tag, function () { return tslib.__awaiter(_this, void 0, void 0, function () {\n            var $canvas, _a, width, height, _b;\n            var _this = this;\n            return tslib.__generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        canvas.addEventListener(gLite.ElementEvent.MOUNTED, handleMounted);\n                        canvas.addEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n                        canvas.addEventListener(gLite.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);\n                        canvas.addEventListener(gLite.ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);\n                        this.context.config.renderer.getConfig().enableDirtyRectangleRendering =\n                            false;\n                        $canvas = this.context.contextService.getDomElement();\n                        _a = this.context.config, width = _a.width, height = _a.height;\n                        this.context.contextService.resize(width, height);\n                        // create swap chain and get device\n                        // @ts-ignore\n                        _b = this;\n                        return [4 /*yield*/, this.context.deviceContribution.createSwapChain($canvas)];\n                    case 1:\n                        // create swap chain and get device\n                        // @ts-ignore\n                        _b.swapChain = _c.sent();\n                        this.device = this.swapChain.getDevice();\n                        this.renderHelper.setDevice(this.device);\n                        this.renderHelper.renderInstManager.disableSimpleMode();\n                        this.swapChain.configureSwapChain($canvas.width, $canvas.height);\n                        canvas.addEventListener(gLite.CanvasEvent.RESIZE, function () {\n                            _this.swapChain.configureSwapChain($canvas.width, $canvas.height);\n                        });\n                        this.batchManager.attach(tslib.__assign({ device: this.device }, context));\n                        return [2 /*return*/];\n                }\n            });\n        }); });\n        renderingService.hooks.destroy.tap(RenderGraphPlugin.tag, function () {\n            _this.renderHelper.destroy();\n            _this.batchManager.destroy();\n            _this.texturePool.destroy();\n            canvas.removeEventListener(gLite.ElementEvent.MOUNTED, handleMounted);\n            canvas.removeEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n            canvas.removeEventListener(gLite.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);\n            canvas.removeEventListener(gLite.ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);\n            _this.device.destroy();\n            _this.device.checkForLeaks();\n            config.disableRenderHooks = false;\n        });\n        /**\n         * build frame graph at the beginning of each frame\n         */\n        renderingService.hooks.beginFrame.tap(RenderGraphPlugin.tag, function () {\n            var _a;\n            var canvas = _this.swapChain.getCanvas();\n            var renderInstManager = _this.renderHelper.renderInstManager;\n            _this.builder = _this.renderHelper.renderGraph.newGraphBuilder();\n            var clearColor;\n            if (_this.context.config.background === 'transparent') {\n                clearColor = gDeviceApi.TransparentBlack;\n            }\n            else {\n                // use canvas.background\n                var backgroundColor = gLite.parseColor(_this.context.config.background);\n                clearColor = _this.context.config.background\n                    ? // use premultipliedAlpha\n                        // @see https://canvatechblog.com/alpha-blending-and-webgl-99feb392779e\n                        gDeviceApi.colorNewFromRGBA((Number(backgroundColor.r) / 255) * Number(backgroundColor.alpha), (Number(backgroundColor.g) / 255) * Number(backgroundColor.alpha), (Number(backgroundColor.b) / 255) * Number(backgroundColor.alpha), Number(backgroundColor.alpha))\n                    : gDeviceApi.TransparentWhite;\n            }\n            // retrieve at each frame since canvas may resize\n            var renderInput = {\n                backbufferWidth: canvas.width,\n                backbufferHeight: canvas.height,\n                antialiasingMode: exports.AntialiasingMode.None,\n            };\n            // create main Color RT\n            var mainRenderDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.Color0, renderInput, makeAttachmentClearDescriptor(clearColor));\n            // create main Depth RT\n            var mainDepthDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.DepthStencil, renderInput, opaqueWhiteFullClearRenderPassDescriptor);\n            var mainColorTargetID = _this.builder.createRenderTargetID(mainRenderDesc, 'Main Color');\n            var mainDepthTargetID = _this.builder.createRenderTargetID(mainDepthDesc, 'Main Depth');\n            // main render pass\n            _this.builder.pushPass(function (pass) {\n                pass.setDebugName('Main Render Pass');\n                pass.attachRenderTargetID(exports.RGAttachmentSlot.Color0, mainColorTargetID);\n                pass.attachRenderTargetID(exports.RGAttachmentSlot.DepthStencil, mainDepthTargetID);\n                pass.exec(function (passRenderer) {\n                    _this.renderLists.world.drawOnPassRenderer(renderInstManager.renderCache, passRenderer);\n                });\n            });\n            // TODO: other post-processing passes\n            if ((_a = _this.options) === null || _a === void 0 ? void 0 : _a.enableFXAA) {\n                // FXAA\n                pushFXAAPass(_this.builder, _this.renderHelper, renderInput, mainColorTargetID);\n            }\n            // output to screen\n            _this.builder.resolveRenderTargetToExternalTexture(mainColorTargetID, _this.swapChain.getOnscreenTexture());\n        });\n        renderingService.hooks.endFrame.tap(RenderGraphPlugin.tag, function () {\n            var renderInstManager = _this.renderHelper.renderInstManager;\n            // TODO: time for GPU Animation\n            // const timeInMilliseconds = window.performance.now();\n            // Push our outer template, which contains the dynamic UBO bindings...\n            var template = _this.renderHelper.pushTemplateRenderInst();\n            // SceneParams: binding = 0, ObjectParams: binding = 1\n            template.setBindingLayout({ numUniformBuffers: 2, numSamplers: 0 });\n            template.setMegaStateFlags(gDeviceApi.setAttachmentStateSimple({\n                depthWrite: true,\n                blendConstant: gDeviceApi.TransparentBlack,\n            }, {\n                rgbBlendMode: gDeviceApi.BlendMode.ADD,\n                alphaBlendMode: gDeviceApi.BlendMode.ADD,\n                rgbBlendSrcFactor: gDeviceApi.BlendFactor.SRC_ALPHA,\n                alphaBlendSrcFactor: gDeviceApi.BlendFactor.ONE,\n                rgbBlendDstFactor: gDeviceApi.BlendFactor.ONE_MINUS_SRC_ALPHA,\n                alphaBlendDstFactor: gDeviceApi.BlendFactor.ONE_MINUS_SRC_ALPHA,\n            }));\n            // Update Scene Params\n            var _a = _this.context.config, width = _a.width, height = _a.height;\n            var camera = _this.context.camera;\n            template.setUniforms(SceneUniformBufferIndex, [\n                {\n                    name: SceneUniform.PROJECTION_MATRIX,\n                    value: camera.getPerspective(),\n                },\n                {\n                    name: SceneUniform.VIEW_MATRIX,\n                    value: camera.getViewTransform(),\n                },\n                {\n                    name: SceneUniform.CAMERA_POSITION,\n                    value: camera.getPosition(),\n                },\n                {\n                    name: SceneUniform.DEVICE_PIXEL_RATIO,\n                    value: _this.context.contextService.getDPR(),\n                },\n                {\n                    name: SceneUniform.VIEWPORT,\n                    value: [width, height],\n                },\n                {\n                    name: SceneUniform.IS_ORTHO,\n                    value: camera.isOrtho() ? 1 : 0,\n                },\n                {\n                    name: SceneUniform.IS_PICKING,\n                    value: 0,\n                },\n            ]);\n            _this.batchManager.render(_this.renderLists.world);\n            renderInstManager.popTemplateRenderInst();\n            _this.renderHelper.prepareToRender();\n            _this.renderHelper.renderGraph.execute();\n            renderInstManager.resetRenderInsts();\n            // capture here since we don't preserve drawing buffer\n            if (_this.enableCapture && _this.resolveCapturePromise) {\n                var _b = _this.captureOptions, type = _b.type, encoderOptions = _b.encoderOptions;\n                var dataURL = _this.context.contextService.getDomElement().toDataURL(type, encoderOptions);\n                _this.resolveCapturePromise(dataURL);\n                _this.enableCapture = false;\n                _this.captureOptions = undefined;\n                _this.resolveCapturePromise = undefined;\n            }\n        });\n    };\n    /**\n     * load texture in an async way and render when loaded\n     */\n    RenderGraphPlugin.prototype.loadTexture = function (src, descriptor, successCallback) {\n        return this.texturePool.getOrCreateTexture(this.device, src, descriptor, function (t) {\n            if (successCallback) {\n                successCallback(t);\n            }\n        });\n    };\n    RenderGraphPlugin.prototype.toDataURL = function (options) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return tslib.__generator(this, function (_a) {\n                // trigger re-render\n                this.enableCapture = true;\n                this.captureOptions = options;\n                this.capturePromise = new Promise(function (resolve) {\n                    _this.resolveCapturePromise = function (dataURL) {\n                        resolve(dataURL);\n                    };\n                });\n                return [2 /*return*/, this.capturePromise];\n            });\n        });\n    };\n    RenderGraphPlugin.tag = 'RenderGraph';\n    return RenderGraphPlugin;\n}());\n\n/**\n * max depth when doing multi-layer picking\n */\nvar MAX_PICKING_DEPTH = 100;\n/**\n * Use color-based picking in GPU\n */\nvar PickingPlugin = /** @class */ (function () {\n    function PickingPlugin(renderHelper, renderGraphPlugin, pickingIdGenerator, batchManager) {\n        this.renderHelper = renderHelper;\n        this.renderGraphPlugin = renderGraphPlugin;\n        this.pickingIdGenerator = pickingIdGenerator;\n        this.batchManager = batchManager;\n    }\n    PickingPlugin.prototype.apply = function (context) {\n        var _this = this;\n        this.context = context;\n        var renderingService = context.renderingService, renderingContext = context.renderingContext;\n        var canvas = renderingContext.root.ownerDocument.defaultView;\n        var handleMounted = function (e) {\n            var object = e.target;\n            // @ts-ignore\n            if (!object.renderable3D) {\n                // @ts-ignore\n                object.renderable3D = new Renderable3D();\n            }\n            // @ts-ignore\n            var renderable3D = object.renderable3D;\n            // generate picking id for later use\n            var pickingId = _this.pickingIdGenerator.getId(object);\n            renderable3D.pickingId = pickingId;\n            renderable3D.encodedPickingColor =\n                _this.pickingIdGenerator.encodePickingColor(pickingId);\n        };\n        var handleUnmounted = function (e) {\n            var object = e.target;\n            // @ts-ignore\n            var renderable3D = object.renderable3D;\n            if (renderable3D) {\n                _this.pickingIdGenerator.deleteById(renderable3D.pickingId);\n            }\n        };\n        renderingService.hooks.init.tap(PickingPlugin.tag, function () {\n            canvas.addEventListener(gLite.ElementEvent.MOUNTED, handleMounted);\n            canvas.addEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n        });\n        renderingService.hooks.destroy.tap(PickingPlugin.tag, function () {\n            canvas.removeEventListener(gLite.ElementEvent.MOUNTED, handleMounted);\n            canvas.removeEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n            _this.pickingIdGenerator.reset();\n        });\n        /**\n         * Sync version is not implemented.\n         */\n        renderingService.hooks.pickSync.tap(PickingPlugin.tag, function (result) {\n            return _this.pick(result);\n        });\n        renderingService.hooks.pick.tapPromise(PickingPlugin.tag, function (result) { return tslib.__awaiter(_this, void 0, void 0, function () {\n            return tslib.__generator(this, function (_a) {\n                return [2 /*return*/, this.pick(result)];\n            });\n        }); });\n    };\n    PickingPlugin.prototype.pick = function (result) {\n        var topmost = result.topmost, position = result.position;\n        // use viewportX/Y\n        var x = position.viewportX, y = position.viewportY;\n        var dpr = this.context.contextService.getDPR();\n        var width = this.context.config.width * dpr;\n        var height = this.context.config.height * dpr;\n        var xInDevicePixel = x * dpr;\n        var yInDevicePixel = y * dpr;\n        if (!this.renderHelper.renderGraph ||\n            xInDevicePixel > width ||\n            xInDevicePixel < 0 ||\n            yInDevicePixel > height ||\n            yInDevicePixel < 0) {\n            result.picked = [];\n            return result;\n        }\n        // implements multi-layer picking\n        // @see https://github.com/antvis/g/issues/948\n        var pickedDisplayObjects = this.pickByRectangleInDepth(new gLite.Rectangle(util.clamp(Math.round(xInDevicePixel), 0, width - 1), util.clamp(Math.round(yInDevicePixel), 0, height - 1), 1, 1), topmost ? 1 : MAX_PICKING_DEPTH);\n        result.picked = pickedDisplayObjects;\n        return result;\n    };\n    PickingPlugin.prototype.pickByRectangleInDepth = function (rect, depth) {\n        if (depth === void 0) { depth = MAX_PICKING_DEPTH; }\n        var picked = null;\n        var counter = 1;\n        var targets = [];\n        do {\n            picked = this.pickByRectangle(rect, picked);\n            if (picked) {\n                counter++;\n                targets.push(picked);\n            }\n            else {\n                break;\n            }\n        } while (picked && counter <= depth);\n        if (depth > 1) {\n            // restore encoded picking color\n            this.restorePickingColor(targets);\n        }\n        return targets;\n    };\n    PickingPlugin.prototype.restorePickingColor = function (displayObjects) {\n        var _this = this;\n        displayObjects.forEach(function (picked) {\n            _this.batchManager.updateAttribute(picked, 'pointerEvents', true, true);\n        });\n    };\n    /**\n     * return displayobjects in target rectangle\n     */\n    PickingPlugin.prototype.pickByRectangle = function (rect, picked) {\n        var _this = this;\n        var device = this.renderGraphPlugin.getDevice();\n        var renderLists = this.renderGraphPlugin.getRenderLists();\n        var renderInstManager = this.renderHelper.renderInstManager;\n        var builder = this.renderHelper.renderGraph.newGraphBuilder();\n        var clearColor = gDeviceApi.TransparentBlack;\n        var camera = this.context.camera;\n        // retrieve at each frame since canvas may resize\n        var x = rect.x, y = rect.y, width = rect.width, height = rect.height;\n        // use a small picking area(like 1x1) instead of a fullscreen rt\n        var renderInput = {\n            backbufferWidth: width,\n            backbufferHeight: height,\n            antialiasingMode: exports.AntialiasingMode.None,\n        };\n        var mainPickingDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.Color0, renderInput, makeAttachmentClearDescriptor(clearColor));\n        var pickingColorTargetID = builder.createRenderTargetID(mainPickingDesc, 'Picking Color');\n        // create main Depth RT\n        var mainDepthDesc = makeBackbufferDescSimple(exports.RGAttachmentSlot.DepthStencil, renderInput, opaqueWhiteFullClearRenderPassDescriptor);\n        var mainDepthTargetID = builder.createRenderTargetID(mainDepthDesc, 'Picking Depth');\n        // account for current view offset\n        var currentView = tslib.__assign({}, camera.getView());\n        // prevent unused RTs like main color being destroyed\n        this.renderHelper.renderGraph.renderTargetDeadPool.forEach(function (rt) {\n            rt.age = -1;\n        });\n        // picking pass\n        var target;\n        builder.pushPass(function (pass) {\n            pass.setDebugName('Picking Pass');\n            pass.attachRenderTargetID(exports.RGAttachmentSlot.Color0, pickingColorTargetID);\n            pass.attachRenderTargetID(exports.RGAttachmentSlot.DepthStencil, mainDepthTargetID);\n            pass.exec(function (passRenderer) {\n                renderLists.picking.drawOnPassRenderer(renderInstManager.renderCache, passRenderer);\n            });\n            pass.post(function (scope) {\n                var texture = scope.getRenderTargetTexture(exports.RGAttachmentSlot.Color0);\n                var readback = device.createReadback();\n                // restore previous view\n                if (currentView && currentView.enabled) {\n                    camera.setViewOffset(currentView.fullWidth, currentView.fullHeight, currentView.offsetX, currentView.offsetY, currentView.width, currentView.height);\n                }\n                else {\n                    camera.clearViewOffset();\n                }\n                camera.setEnableUpdate(true);\n                var pickedColors;\n                try {\n                    pickedColors = readback.readTextureSync(texture, 0, 0, width, height, new Uint8Array(width * height * 4));\n                }\n                catch (e) { }\n                var pickedFeatureIdx = -1;\n                if (pickedColors &&\n                    (pickedColors[0] !== 0 ||\n                        pickedColors[1] !== 0 ||\n                        pickedColors[2] !== 0)) {\n                    pickedFeatureIdx =\n                        _this.pickingIdGenerator.decodePickingColor(pickedColors);\n                }\n                if (pickedFeatureIdx > -1) {\n                    var pickedDisplayObject = _this.pickingIdGenerator.getById(pickedFeatureIdx);\n                    if (pickedDisplayObject &&\n                        pickedDisplayObject.isVisible() &&\n                        pickedDisplayObject.isInteractive()) {\n                        target = pickedDisplayObject;\n                    }\n                }\n                readback.destroy();\n            });\n        });\n        // Push our outer template, which contains the dynamic UBO bindings...\n        var template = this.renderHelper.pushTemplateRenderInst();\n        // SceneParams: binding = 0, ObjectParams: binding = 1\n        template.setBindingLayout({ numUniformBuffers: 2, numSamplers: 0 });\n        template.setMegaStateFlags(gDeviceApi.setAttachmentStateSimple({\n            depthWrite: true,\n        }, {\n            rgbBlendMode: gDeviceApi.BlendMode.ADD,\n            rgbBlendSrcFactor: gDeviceApi.BlendFactor.ONE,\n            rgbBlendDstFactor: gDeviceApi.BlendFactor.ZERO,\n            alphaBlendMode: gDeviceApi.BlendMode.ADD,\n            alphaBlendSrcFactor: gDeviceApi.BlendFactor.ONE,\n            alphaBlendDstFactor: gDeviceApi.BlendFactor.ZERO,\n        }));\n        // Update Scene Params\n        var _a = this.context.config, canvasWidth = _a.width, canvasHeight = _a.height;\n        var dpr = this.context.contextService.getDPR();\n        camera.setEnableUpdate(false);\n        camera.setViewOffset(canvasWidth * dpr, canvasHeight * dpr, x, y, width, height);\n        template.setUniforms(SceneUniformBufferIndex, [\n            {\n                name: SceneUniform.PROJECTION_MATRIX,\n                value: camera.getPerspective(),\n            },\n            {\n                name: SceneUniform.VIEW_MATRIX,\n                value: camera.getViewTransform(),\n            },\n            {\n                name: SceneUniform.CAMERA_POSITION,\n                value: camera.getPosition(),\n            },\n            {\n                name: SceneUniform.DEVICE_PIXEL_RATIO,\n                value: this.context.contextService.getDPR(),\n            },\n            {\n                name: SceneUniform.VIEWPORT,\n                value: [width, height],\n            },\n            {\n                name: SceneUniform.IS_ORTHO,\n                value: camera.isOrtho() ? 1 : 0,\n            },\n            {\n                name: SceneUniform.IS_PICKING,\n                value: 1,\n            },\n        ]);\n        if (picked) {\n            this.batchManager.updateAttribute(picked, 'pointerEvents', false, true);\n        }\n        this.batchManager.render(renderLists.picking, true);\n        renderInstManager.popTemplateRenderInst();\n        this.renderHelper.prepareToRender();\n        this.renderHelper.renderGraph.execute();\n        renderInstManager.resetRenderInsts();\n        return target;\n    };\n    PickingPlugin.tag = 'WebGLPicker';\n    return PickingPlugin;\n}());\n\n/**\n * render order start from 0, our default camera's Z is 500\n */\nvar RENDER_ORDER_SCALE = 500 / 1000000;\n/**\n * A container for multiple display objects with the same `style`,\n * eg. 1000 Circles with the same stroke color, but their position, radius can be different\n */\nvar Batch = /** @class */ (function () {\n    function Batch() {\n        this.clipPathMeshCreated = false;\n        // private findClipPath(): DisplayObject | null {\n        //   let node = this.instance;\n        //   while (node && node.style) {\n        //     if (node.style.clipPath) {\n        //       return node.style.clipPath;\n        //     }\n        //     node = node.parentNode as DisplayObject;\n        //   }\n        //   return null;\n        // }\n        // private applyClipPath() {\n        //   // find clipPath\n        //   const clipPathShape = this.findClipPath();\n        //   if (clipPathShape && !this.clipPathMeshCreated) {\n        //     if (this.batchMeshList.length === 0) {\n        //       return;\n        //     }\n        //     const clipPathMesh = this.meshFactory(clipPathShape.nodeName);\n        //     clipPathMesh.clipPathTarget = this.instance;\n        //     // draw clipPath first\n        //     this.batchMeshList.unshift(clipPathMesh);\n        //     this.clipPathMeshCreated = true;\n        //     this.batchMeshList.forEach((mesh, i) => {\n        //       mesh.clipPath = clipPathShape;\n        //       if (!mesh.material) {\n        //         mesh.material = new ShaderMaterial(this.device);\n        //       }\n        //       mesh.material.stencilRef = this.batchManager.getStencilRef(clipPathShape);\n        //     });\n        //   }\n        //   // remove clipPath from render queue\n        //   if (!clipPathShape) {\n        //     if (this.batchMeshList.length && this.batchMeshList[0].clipPathTarget) {\n        //       this.batchMeshList.shift();\n        //     }\n        //   }\n        // }\n    }\n    Batch.prototype.beforeUploadUBO = function (renderInst, mesh) { };\n    Batch.prototype.beforeInitMesh = function (mesh) { };\n    Batch.prototype.afterInitMesh = function (mesh) { };\n    return Batch;\n}());\n\nfunction isTexture(t) {\n    return !!(t && t.type);\n}\nexports.MaterialEvent = void 0;\n(function (MaterialEvent) {\n    MaterialEvent[\"CHANGED\"] = \"changed\";\n})(exports.MaterialEvent || (exports.MaterialEvent = {}));\n/**\n * an encapsulation on top of shaders\n * @see https://doc.babylonjs.com/divingDeeper/materials/using/materials_introduction\n */\nvar Material = /** @class */ (function (_super) {\n    tslib.__extends(Material, _super);\n    function Material(device, props) {\n        var _this = _super.call(this) || this;\n        _this.props = {};\n        /**\n         * relative meshes\n         */\n        _this.meshes = [];\n        // USE_XXX\n        _this.defines = {};\n        _this.uniforms = {};\n        _this.uboBuffer = [];\n        _this.textures = {};\n        _this.samplers = [];\n        /**\n         * need re-compiling like vs/fs changed\n         */\n        _this.programDirty = true;\n        /**\n         * need re-upload textures\n         */\n        _this.textureDirty = true;\n        /**\n         * inform geometry to rebuild, eg. wireframe\n         */\n        _this.geometryDirty = true;\n        var _a = gDeviceApi.copyMegaState(gDeviceApi.defaultMegaState), cullMode = _a.cullMode, depthCompare = _a.depthCompare, depthWrite = _a.depthWrite, stencilFront = _a.stencilFront, stencilBack = _a.stencilBack, stencilWrite = _a.stencilWrite, frontFace = _a.frontFace, polygonOffset = _a.polygonOffset, attachmentsState = _a.attachmentsState;\n        _this.device = device;\n        // @ts-ignore\n        _this.props = tslib.__assign({ cullMode: cullMode, depthTest: true, depthCompare: depthCompare, depthWrite: depthWrite, stencilFront: stencilFront, stencilBack: stencilBack, stencilWrite: stencilWrite, frontFace: frontFace, polygonOffset: polygonOffset, attachmentsState: attachmentsState, dithering: false, wireframe: false, wireframeColor: 'black', wireframeLineWidth: 1, vertexShader: '', fragmentShader: '' }, props);\n        _this.compile();\n        return _this;\n    }\n    Object.defineProperty(Material.prototype, \"cullMode\", {\n        /**\n         * cullFace\n         */\n        get: function () {\n            return this.props.cullMode;\n        },\n        set: function (value) {\n            this.props.cullMode = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"frontFace\", {\n        get: function () {\n            return this.props.frontFace;\n        },\n        set: function (value) {\n            this.props.frontFace = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendConstant\", {\n        /**\n         * Blending state\n         */\n        get: function () {\n            return this.props.blendConstant;\n        },\n        set: function (value) {\n            this.props.blendConstant = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendEquation\", {\n        get: function () {\n            return this.props.blendEquation;\n        },\n        set: function (value) {\n            this.props.blendEquation = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendEquationAlpha\", {\n        get: function () {\n            return this.props.blendEquationAlpha;\n        },\n        set: function (value) {\n            this.props.blendEquationAlpha = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendSrc\", {\n        get: function () {\n            return this.props.blendSrc;\n        },\n        set: function (value) {\n            this.props.blendSrc = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendDst\", {\n        get: function () {\n            return this.props.blendDst;\n        },\n        set: function (value) {\n            this.props.blendDst = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendSrcAlpha\", {\n        get: function () {\n            return this.props.blendSrcAlpha;\n        },\n        set: function (value) {\n            this.props.blendSrcAlpha = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"blendDstAlpha\", {\n        get: function () {\n            return this.props.blendDstAlpha;\n        },\n        set: function (value) {\n            this.props.blendDstAlpha = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"depthCompare\", {\n        get: function () {\n            return this.props.depthCompare;\n        },\n        set: function (value) {\n            this.props.depthCompare = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"depthTest\", {\n        get: function () {\n            return this.props.depthTest;\n        },\n        set: function (value) {\n            this.props.depthTest = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"depthWrite\", {\n        get: function () {\n            return this.props.depthWrite;\n        },\n        set: function (value) {\n            this.props.depthWrite = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"stencilFront\", {\n        get: function () {\n            return this.props.stencilFront;\n        },\n        set: function (value) {\n            this.props.stencilFront = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"stencilBack\", {\n        get: function () {\n            return this.props.stencilBack;\n        },\n        set: function (value) {\n            this.props.stencilBack = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"stencilWrite\", {\n        get: function () {\n            return this.props.stencilWrite;\n        },\n        set: function (value) {\n            this.props.stencilWrite = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"stencilRef\", {\n        get: function () {\n            return this.props.stencilRef;\n        },\n        set: function (value) {\n            this.props.stencilRef = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"polygonOffset\", {\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/polygonOffset\n        get: function () {\n            return this.props.polygonOffset;\n        },\n        set: function (value) {\n            this.props.polygonOffset = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"dithering\", {\n        // gl.DITHER\n        get: function () {\n            return this.props.dithering;\n        },\n        set: function (value) {\n            this.props.dithering = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"wireframe\", {\n        // @see https://doc.babylonjs.com/divingDeeper/materials/using/materials_introduction#wireframe\n        get: function () {\n            return this.props.wireframe;\n        },\n        set: function (value) {\n            if (this.props.wireframe !== value) {\n                // need re-generate geometry\n                this.geometryDirty = true;\n                this.programDirty = true;\n                this.props.wireframe = value;\n                this.dispatchMutationEvent();\n            }\n            this.defines.USE_WIREFRAME = !!value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"wireframeColor\", {\n        get: function () {\n            return this.props.wireframeColor;\n        },\n        set: function (value) {\n            this.props.wireframeColor = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"wireframeLineWidth\", {\n        get: function () {\n            return this.props.wireframeLineWidth;\n        },\n        set: function (value) {\n            this.props.wireframeLineWidth = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"vertexShader\", {\n        // shader pairs\n        get: function () {\n            return this.props.vertexShader;\n        },\n        set: function (value) {\n            if (this.props.vertexShader !== value) {\n                this.programDirty = true;\n                this.props.vertexShader = value;\n                this.compile();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Material.prototype, \"fragmentShader\", {\n        get: function () {\n            return this.props.fragmentShader;\n        },\n        set: function (value) {\n            if (this.props.fragmentShader !== value) {\n                this.programDirty = true;\n                this.props.fragmentShader = value;\n                this.compile();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Material.prototype.compile = function () {\n        var _this = this;\n        // uniform sampler2D u_Texture0;\n        this.props.fragmentShader.replace(/^\\s*uniform\\s*sampler2D\\s*(.*)\\s*;$/gm, function (_, name) {\n            _this.samplers.push(name);\n            return '';\n        });\n        /**\n         * extract from uniform buffer object, should account for struct & pre-defines, eg.\n         * layout(std140) uniform ub_ObjectParams {\n         *   mat4 u_ModelMatrix;\n         *   vec4 u_Color;\n         *   vec4 u_StrokeColor;\n         *   #ifdef NUM_DIR_LIGHTS\n         *     DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n         *   #endif\n         * }\n         */\n        this.uniformNames = gDeviceApi.getUniforms(this.props.fragmentShader);\n    };\n    /**\n     * @example\n     * material.setUniforms({\n     *   u_ModelMatrix: [1, 2, 3, 4],\n     *   u_Time: 1,\n     *   u_Map: texture,\n     * })\n     */\n    Material.prototype.setUniforms = function (uniforms) {\n        var _this = this;\n        var shoudDispatchMutationEvent = false;\n        Object.keys(uniforms).forEach(function (key) {\n            var value = uniforms[key];\n            var existedTexture = _this.textures[key];\n            if (existedTexture && existedTexture !== value) {\n                // existedTexture.destroy();\n                _this.textureDirty = true;\n            }\n            if (isTexture(value)) {\n                _this.textures[key] = value;\n                _this.textureDirty = true;\n                value.on(gDeviceApi.TextureEvent.LOADED, function () {\n                    _this.dispatchMutationEvent();\n                });\n            }\n            else {\n                _this.uniforms[key] = value;\n                shoudDispatchMutationEvent = true;\n            }\n            if (util.isNil(uniforms[key])) {\n                delete _this.textures[key];\n                delete _this.uniforms[key];\n            }\n        });\n        if (shoudDispatchMutationEvent) {\n            this.dispatchMutationEvent();\n        }\n    };\n    Material.prototype.dispatchMutationEvent = function () {\n        this.emit(exports.MaterialEvent.CHANGED);\n    };\n    return Material;\n}(EventEmitter));\n\nvar ShaderMaterial = /** @class */ (function (_super) {\n    tslib.__extends(ShaderMaterial, _super);\n    function ShaderMaterial(device, props) {\n        var _this = _super.call(this, device, tslib.__assign({}, props)) || this;\n        _this.defines = tslib.__assign(tslib.__assign({}, _this.defines), { USE_UV: false, USE_MAP: false, USE_WIREFRAME: false, USE_FOG: false, USE_LIGHT: false });\n        return _this;\n    }\n    return ShaderMaterial;\n}(Material));\n\nfunction enumToObject(enumObject) {\n    var result = {};\n    Object.keys(enumObject).forEach(function (key) {\n        if (typeof enumObject[key] === 'number') {\n            result[key] = enumObject[key];\n        }\n    });\n    return result;\n}\nfunction compareDefines(d1, d2) {\n    var d1Keys = Object.keys(d1);\n    var d2Keys = Object.keys(d2);\n    if (d1Keys.length !== d2Keys.length) {\n        return false;\n    }\n    return d1Keys.every(function (key) { return d1[key] === d2[key]; });\n}\nvar definedProps = function (obj) {\n    return Object.fromEntries(Object.entries(obj).filter(function (_a) {\n        var _b = tslib.__read(_a, 2); _b[0]; var v = _b[1];\n        return v !== undefined;\n    }));\n};\n\nfunction packUint8ToFloat(a, b) {\n    a = util.clamp(Math.floor(a), 0, 255);\n    b = util.clamp(Math.floor(b), 0, 255);\n    return 256 * a + b;\n}\n\nvar counter = 1;\nvar FILL_TEXTURE_MAPPING = 'FillTextureMapping';\n/**\n * WebGPU has max vertex attribute num(8)\n */\nexports.VertexAttributeBufferIndex = void 0;\n(function (VertexAttributeBufferIndex) {\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"MODEL_MATRIX\"] = 0] = \"MODEL_MATRIX\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"PACKED_COLOR\"] = 1] = \"PACKED_COLOR\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"PACKED_STYLE\"] = 2] = \"PACKED_STYLE\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"PICKING_COLOR\"] = 3] = \"PICKING_COLOR\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"POSITION\"] = 4] = \"POSITION\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"NORMAL\"] = 5] = \"NORMAL\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"UV\"] = 6] = \"UV\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"BARYCENTRIC\"] = 7] = \"BARYCENTRIC\";\n    VertexAttributeBufferIndex[VertexAttributeBufferIndex[\"MAX\"] = 8] = \"MAX\";\n})(exports.VertexAttributeBufferIndex || (exports.VertexAttributeBufferIndex = {}));\n/**\n * GL.MAX_VERTEX_ATTRIBS\n */\nexports.VertexAttributeLocation = void 0;\n(function (VertexAttributeLocation) {\n    // TODO: bind mat4 in WebGL2 instead of decomposed 4 * vec4?\n    // @see https://stackoverflow.com/questions/38853096/webgl-how-to-bind-values-to-a-mat4-attribute/38853623#38853623\n    VertexAttributeLocation[VertexAttributeLocation[\"MODEL_MATRIX0\"] = 0] = \"MODEL_MATRIX0\";\n    VertexAttributeLocation[VertexAttributeLocation[\"MODEL_MATRIX1\"] = 1] = \"MODEL_MATRIX1\";\n    VertexAttributeLocation[VertexAttributeLocation[\"MODEL_MATRIX2\"] = 2] = \"MODEL_MATRIX2\";\n    VertexAttributeLocation[VertexAttributeLocation[\"MODEL_MATRIX3\"] = 3] = \"MODEL_MATRIX3\";\n    VertexAttributeLocation[VertexAttributeLocation[\"PACKED_COLOR\"] = 4] = \"PACKED_COLOR\";\n    VertexAttributeLocation[VertexAttributeLocation[\"PACKED_STYLE1\"] = 5] = \"PACKED_STYLE1\";\n    VertexAttributeLocation[VertexAttributeLocation[\"PACKED_STYLE2\"] = 6] = \"PACKED_STYLE2\";\n    VertexAttributeLocation[VertexAttributeLocation[\"PICKING_COLOR\"] = 7] = \"PICKING_COLOR\";\n    VertexAttributeLocation[VertexAttributeLocation[\"POSITION\"] = 8] = \"POSITION\";\n    VertexAttributeLocation[VertexAttributeLocation[\"NORMAL\"] = 9] = \"NORMAL\";\n    VertexAttributeLocation[VertexAttributeLocation[\"UV\"] = 10] = \"UV\";\n    VertexAttributeLocation[VertexAttributeLocation[\"BARYCENTRIC\"] = 11] = \"BARYCENTRIC\";\n    VertexAttributeLocation[VertexAttributeLocation[\"MAX\"] = 12] = \"MAX\";\n})(exports.VertexAttributeLocation || (exports.VertexAttributeLocation = {}));\n/**\n * Draw call.\n */\nvar Instanced = /** @class */ (function () {\n    function Instanced(renderHelper, texturePool, lightPool, object, \n    /**\n     * All drawcall constructors.\n     */\n    drawcallCtors, \n    /**\n     * index in renderer.meshes\n     */\n    index, context) {\n        if (index === void 0) { index = -1; }\n        this.renderHelper = renderHelper;\n        this.texturePool = texturePool;\n        this.lightPool = lightPool;\n        this.drawcallCtors = drawcallCtors;\n        this.index = index;\n        this.context = context;\n        /**\n         * unique ID\n         */\n        this.id = counter++;\n        /**\n         * attribute name used for gradient or pattern\n         */\n        this.gradientAttributeName = 'fill';\n        /**\n         * instances\n         */\n        this.objects = [];\n        this.program = new DeviceProgram();\n        this.geometryDirty = true;\n        /**\n         * the same material maybe shared between different canvases\n         */\n        this.materialDirty = true;\n        /**\n         * texture mappings\n         */\n        this.textureMappings = [];\n        /**\n         * Divisor of instanced array.\n         */\n        this.divisor = 1;\n        /**\n         * Account for anchor and merge it into modelMatrix.\n         */\n        this.mergeAnchorIntoModelMatrix = false;\n        this.checkNodeName = true;\n        /**\n         * Create a new batch if the number of instances exceeds.\n         */\n        this.maxInstances = Infinity;\n        this.inited = false;\n    }\n    Object.defineProperty(Instanced.prototype, \"instance\", {\n        get: function () {\n            return this.objects[0];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Instanced.prototype.init = function () {\n        if (this.inited) {\n            return;\n        }\n        this.renderer.beforeInitMesh(this);\n        this.material = new ShaderMaterial(this.context.device);\n        this.material.defines = tslib.__assign(tslib.__assign({}, enumToObject(exports.VertexAttributeLocation)), this.material.defines);\n        this.geometry = new BufferGeometry(this.context.device);\n        // make refs so that we can trigger MutationEvent on every object\n        this.geometry.meshes = this.objects;\n        this.material.meshes = this.objects;\n        this.observeGeometryChanged();\n        this.observeMaterialChanged();\n        this.inited = true;\n        this.renderer.afterInitMesh(this);\n    };\n    Instanced.prototype.observeGeometryChanged = function () {\n        var _this = this;\n        this.geometry.on(exports.GeometryEvent.CHANGED, function () {\n            _this.geometry.meshes.forEach(function (mesh) {\n                mesh.renderable.dirty = true;\n            });\n            _this.context.renderingService.dirtify();\n        });\n    };\n    Instanced.prototype.observeMaterialChanged = function () {\n        var _this = this;\n        this.material.on(exports.MaterialEvent.CHANGED, function () {\n            _this.material.meshes.forEach(function (mesh) {\n                mesh.renderable.dirty = true;\n            });\n            _this.context.renderingService.dirtify();\n        });\n    };\n    Instanced.prototype.shouldMergeColor = function (o1, o2, name) {\n        // c1: CSSRGB | CSSGradientValue[] | Pattern, c2: CSSRGB | CSSGradientValue[] | Pattern\n        // can't be merged if gradients & pattern used\n        var source = o1.parsedStyle[name];\n        var target = o2.parsedStyle[name];\n        // constant color value\n        if (gLite.isCSSRGB(source) && gLite.isCSSRGB(target)) {\n            return true;\n        }\n        // pattern\n        if (gLite.isPattern(source) &&\n            gLite.isPattern(target) &&\n            source.image === target.image) {\n            return true;\n        }\n        // gradients\n        if (Array.isArray(source) &&\n            Array.isArray(target) &&\n            o1.style[name] === o2.style[name]) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * should be merged into current InstancedMesh\n     */\n    Instanced.prototype.shouldMerge = function (object, index) {\n        if (!this.instance) {\n            return true;\n        }\n        // Path / Polyline could be rendered as Line\n        if (this.checkNodeName && this.instance.nodeName !== object.nodeName) {\n            return false;\n        }\n        // can't be merged when using clipPath\n        if (object.parsedStyle.clipPath) {\n            return false;\n        }\n        if (!this.shouldMergeColor(this.instance, object, 'fill') ||\n            !this.shouldMergeColor(this.instance, object, 'stroke')) {\n            return false;\n        }\n        return true;\n    };\n    Instanced.prototype.createGeometry = function (objects) {\n        var _this = this;\n        var modelMatrix = glMatrix.mat4.create();\n        var modelViewMatrix = glMatrix.mat4.create();\n        // const normalMatrix = mat3.create();\n        var packedModelMatrix = [];\n        var packedFillStroke = [];\n        var packedStyle = [];\n        var packedPicking = [];\n        var divisor = this.divisor;\n        // const useNormal = this.material.defines.NORMAL;\n        objects.forEach(function (object) {\n            var _a;\n            var _b = object.parsedStyle, fill = _b.fill, stroke = _b.stroke, opacity = _b.opacity, fillOpacity = _b.fillOpacity, strokeOpacity = _b.strokeOpacity, lineWidth = _b.lineWidth, anchor = _b.anchor, visibility = _b.visibility, increasedLineWidthForHitTesting = _b.increasedLineWidthForHitTesting;\n            var fillColor = [0, 0, 0, 0];\n            if (gLite.isCSSRGB(fill)) {\n                fillColor = [\n                    Number(fill.r),\n                    Number(fill.g),\n                    Number(fill.b),\n                    Number(fill.alpha) * 255,\n                ];\n            }\n            var strokeColor = [0, 0, 0, 0];\n            if (gLite.isCSSRGB(stroke)) {\n                strokeColor = [\n                    Number(stroke.r),\n                    Number(stroke.g),\n                    Number(stroke.b),\n                    Number(stroke.alpha) * 255,\n                ];\n            }\n            // if (this.clipPathTarget) {\n            //   // account for target's rts\n            //   mat4.copy(modelMatrix, object.getLocalTransform());\n            //   fillColor = [255, 255, 255, 255];\n            //   mat4.mul(\n            //     modelMatrix,\n            //     this.clipPathTarget.getWorldTransform(),\n            //     modelMatrix,\n            //   );\n            // } else {\n            //   mat4.copy(modelMatrix, object.getWorldTransform());\n            // }\n            glMatrix.mat4.mul(modelViewMatrix, _this.context.camera.getViewTransform(), modelMatrix);\n            var encodedPickingColor = (object.isInteractive() &&\n                (\n                // @ts-ignore\n                (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];\n            if (_this.mergeAnchorIntoModelMatrix) {\n                var anchor_1 = object.parsedStyle.anchor;\n                var translateX = 0;\n                var translateY = 0;\n                var translateZ = 0;\n                var contentBounds = object.getGeometryBounds();\n                if (contentBounds) {\n                    var halfExtents = contentBounds.halfExtents;\n                    translateX = -halfExtents[0] * anchor_1[0] * 2;\n                    translateY = -halfExtents[1] * anchor_1[1] * 2;\n                    translateZ = -halfExtents[2] * (anchor_1[2] || 0) * 2;\n                }\n                glMatrix.mat4.mul(modelMatrix, object.getWorldTransform(), // apply anchor\n                glMatrix.mat4.fromTranslation(modelMatrix, glMatrix.vec3.fromValues(translateX, translateY, translateZ)));\n            }\n            else {\n                glMatrix.mat4.copy(modelMatrix, object.getWorldTransform());\n            }\n            packedModelMatrix.push.apply(packedModelMatrix, tslib.__spreadArray([], tslib.__read(modelMatrix), false));\n            packedFillStroke.push(packUint8ToFloat(fillColor[0], fillColor[1]), packUint8ToFloat(fillColor[2], fillColor[3]), packUint8ToFloat(strokeColor[0], strokeColor[1]), packUint8ToFloat(strokeColor[2], strokeColor[3]));\n            packedStyle.push(opacity, fillOpacity, strokeOpacity, lineWidth, visibility === 'visible' ? 1 : 0, anchor[0], anchor[1], increasedLineWidthForHitTesting || 0);\n            packedPicking.push.apply(packedPicking, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(encodedPickingColor), false), [object.sortable.renderOrder * RENDER_ORDER_SCALE], false));\n            // if (useNormal) {\n            //   // should not calc normal matrix in shader, mat3.invert is not cheap\n            //   // @see https://stackoverflow.com/a/21079741\n            //   mat3.fromMat4(normalMatrix, modelViewMatrix);\n            //   mat3.invert(normalMatrix, normalMatrix);\n            //   mat3.transpose(normalMatrix, normalMatrix);\n            //   const { NORMAL_MATRIX0, NORMAL_MATRIX1, NORMAL_MATRIX2 } = this.material.defines;\n            //   this.bufferGeometry.setVertexBuffer({\n            //     bufferIndex: 4,\n            //     byteStride: 4 * (3 * 3),\n            //     stepMode: VertexStepMode.INSTANCE,\n            //     attributes: [\n            //       {\n            //         format: Format.F32_RGB,\n            //         bufferByteOffset: 4 * 0,\n            //         location: Number(NORMAL_MATRIX0),\n            //         divisor\n            //       },\n            //       {\n            //         format: Format.F32_RGB,\n            //         bufferByteOffset: 4 * 3,\n            //         location: Number(NORMAL_MATRIX1),\n            //         divisor\n            //       },\n            //       {\n            //         format: Format.F32_RGB,\n            //         bufferByteOffset: 4 * 6,\n            //         location: Number(NORMAL_MATRIX2),\n            //         divisor\n            //       },\n            //     ],\n            //     data: new Float32Array(normalMatrix),\n            //   });\n            // }\n        });\n        this.geometry.instancedCount = objects.length;\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.MODEL_MATRIX,\n            byteStride: 4 * (4 * 4),\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX0,\n                    divisor: divisor,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 4,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX1,\n                    divisor: divisor,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 8,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX2,\n                    divisor: divisor,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 12,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX3,\n                    divisor: divisor,\n                },\n            ],\n            data: new Float32Array(packedModelMatrix),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.PACKED_COLOR,\n            byteStride: 4 * 4,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.PACKED_COLOR,\n                    divisor: divisor,\n                },\n            ],\n            data: new Float32Array(packedFillStroke),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.PACKED_STYLE,\n            byteStride: 4 * 8,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.PACKED_STYLE1,\n                    divisor: divisor,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 4,\n                    location: exports.VertexAttributeLocation.PACKED_STYLE2,\n                    divisor: divisor,\n                },\n            ],\n            data: new Float32Array(packedStyle),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.PICKING_COLOR,\n            byteStride: 4 * 4,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.PICKING_COLOR,\n                    divisor: divisor,\n                },\n            ],\n            data: new Float32Array(packedPicking),\n        });\n    };\n    Instanced.prototype.destroy = function () {\n        if (this.geometry) {\n            this.geometry.destroy();\n        }\n    };\n    Instanced.prototype.applyRenderInst = function (renderInst, objects) {\n        var _this = this;\n        // detect if scene changed, eg. lights & fog\n        var fog = this.lightPool.getFog();\n        var useFog = !!fog;\n        if (this.clipPathTarget || this.clipPath) {\n            if (this.clipPathTarget) {\n                this.material.stencilWrite = true;\n                // @see https://open.gl/depthstencils\n                this.material.depthWrite = false;\n                this.material.stencilFront = {\n                    compare: gDeviceApi.CompareFunction.ALWAYS,\n                    passOp: gDeviceApi.StencilOp.REPLACE,\n                };\n                this.material.stencilBack = {\n                    compare: gDeviceApi.CompareFunction.ALWAYS,\n                    passOp: gDeviceApi.StencilOp.REPLACE,\n                };\n            }\n            else {\n                this.material.stencilWrite = false;\n                this.material.depthWrite = true;\n                this.material.stencilFront = {\n                    compare: gDeviceApi.CompareFunction.EQUAL,\n                    passOp: gDeviceApi.StencilOp.KEEP,\n                };\n                this.material.stencilBack = {\n                    compare: gDeviceApi.CompareFunction.EQUAL,\n                    passOp: gDeviceApi.StencilOp.KEEP,\n                };\n            }\n        }\n        else {\n            this.material.stencilWrite = false;\n        }\n        if (this.materialDirty || this.material.programDirty) {\n            this.createMaterial(objects);\n        }\n        var oldDefines = tslib.__assign({}, this.material.defines);\n        this.material.defines.USE_FOG = useFog;\n        this.material.defines = tslib.__assign(tslib.__assign(tslib.__assign({}, this.lightPool.getDefines()), this.material.defines), this.renderHelper.getDefines());\n        // re-upload textures\n        if (this.material.textureDirty) {\n            this.textureMappings = [];\n            // set texture mappings\n            var fillTextureMapping = this.createFillGradientTextureMapping(objects);\n            if (fillTextureMapping) {\n                this.textureMappings.push(fillTextureMapping);\n            }\n            Object.keys(this.material.textures)\n                .sort(function (a, b) {\n                return _this.material.samplers.indexOf(a) -\n                    _this.material.samplers.indexOf(b);\n            })\n                .forEach(function (key) {\n                var mapping = new TextureMapping();\n                mapping.name = key;\n                mapping.texture = _this.material.textures[key];\n                _this.context.device.setResourceName(mapping.texture, 'Material Texture ' + key);\n                mapping.sampler = _this.renderHelper.getCache().createSampler({\n                    addressModeU: gDeviceApi.AddressMode.CLAMP_TO_EDGE,\n                    addressModeV: gDeviceApi.AddressMode.CLAMP_TO_EDGE,\n                    minFilter: gDeviceApi.FilterMode.POINT,\n                    magFilter: gDeviceApi.FilterMode.BILINEAR,\n                    mipmapFilter: gDeviceApi.MipmapFilterMode.LINEAR,\n                    lodMinClamp: 0,\n                    lodMaxClamp: 0,\n                });\n                _this.textureMappings.push(mapping);\n            });\n            if (this.textureMappings.length) {\n                this.material.defines.USE_UV = true;\n                this.material.defines.USE_MAP = true;\n            }\n            else {\n                this.material.defines.USE_UV = false;\n                this.material.defines.USE_MAP = false;\n            }\n            this.material.textureDirty = false;\n        }\n        var needRecompileProgram = !compareDefines(oldDefines, this.material.defines);\n        // re-compile program, eg. DEFINE changed\n        if (needRecompileProgram ||\n            this.material.programDirty ||\n            this.materialDirty) {\n            // set defines\n            this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(exports.VertexAttributeLocation));\n            Object.keys(this.material.defines).forEach(function (key) {\n                var value = _this.material.defines[key];\n                if (typeof value === 'boolean') {\n                    _this.program.setDefineBool(key, value);\n                }\n                else {\n                    _this.program.setDefineString(key, \"\".concat(value));\n                }\n            });\n            // build shaders\n            this.program.vert = this.material.vertexShader;\n            this.program.frag = this.material.fragmentShader;\n            this.material.programDirty = false;\n            this.materialDirty = false;\n        }\n        if (this.material.geometryDirty) {\n            // wireframe  geometry \n            this.geometryDirty = true;\n            this.material.geometryDirty = false;\n        }\n        if (this.geometryDirty || this.geometry.dirty) {\n            // destroy first\n            if (this.geometry) {\n                this.geometry.destroy();\n            }\n            // re-create buffer geometry\n            this.createGeometry(objects);\n            // generate wireframe\n            if (this.material.wireframe) {\n                this.generateWireframe(this.geometry);\n            }\n            // sync to internal Geometry\n            this.geometryDirty = false;\n            this.geometry.dirty = false;\n        }\n        // cached input layout\n        var program = this.renderHelper\n            .getCache()\n            .createProgramSimple(this.program);\n        var inputLayout = this.renderHelper.getCache().createInputLayout(tslib.__assign(tslib.__assign({}, this.geometry.inputLayoutDescriptor), { program: program }));\n        var useIndexes = !!this.geometry.indexBuffer;\n        renderInst.renderPipelineDescriptor.topology = this.geometry.drawMode;\n        renderInst.setProgram(program);\n        renderInst.setVertexInput(inputLayout, this.geometry.vertexBuffers\n            .filter(function (b) { return !!b; })\n            .map(function (buffer) { return ({\n            buffer: buffer,\n            byteOffset: 0,\n        }); }), useIndexes ? { buffer: this.geometry.indexBuffer, offset: 0 } : null);\n        this.renderer.beforeUploadUBO(renderInst, this);\n        // upload uniform buffer object\n        this.uploadUBO(renderInst);\n        if (useIndexes) {\n            // drawElements\n            renderInst.drawIndexesInstanced(this.geometry.vertexCount, this.geometry.instancedCount, this.geometry.indexStart);\n        }\n        else {\n            // drawArrays\n            renderInst.drawPrimitives(this.geometry.vertexCount, this.geometry.primitiveStart);\n        }\n        // FIXME: \n        renderInst.sortKey = makeSortKeyOpaque(exports.RendererLayer.OPAQUE, objects[0].sortable.renderOrder);\n    };\n    /**\n     * update a continuous GPU buffer\n     */\n    Instanced.prototype.updateBatchedAttribute = function (objects, startIndex, name, value) {\n        var _this = this;\n        if (objects.length === 0) {\n            return;\n        }\n        var stylePacked = [\n            'opacity',\n            'fillOpacity',\n            'strokeOpacity',\n            'lineWidth',\n            'visibility',\n            'anchor',\n            'increasedLineWidthForHitTesting',\n        ];\n        if (name === 'fill' || name === 'stroke') {\n            var packedFillStroke_1 = [];\n            objects.forEach(function (object) {\n                var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke;\n                var fillColor = [0, 0, 0, 0];\n                if (gLite.isCSSRGB(fill)) {\n                    fillColor = [\n                        Number(fill.r),\n                        Number(fill.g),\n                        Number(fill.b),\n                        Number(fill.alpha) * 255,\n                    ];\n                }\n                var strokeColor = [0, 0, 0, 0];\n                if (gLite.isCSSRGB(stroke)) {\n                    strokeColor = [\n                        Number(stroke.r),\n                        Number(stroke.g),\n                        Number(stroke.b),\n                        Number(stroke.alpha) * 255,\n                    ];\n                }\n                packedFillStroke_1.push(packUint8ToFloat(fillColor[0], fillColor[1]), packUint8ToFloat(fillColor[2], fillColor[3]), packUint8ToFloat(strokeColor[0], strokeColor[1]), packUint8ToFloat(strokeColor[2], strokeColor[3]));\n            });\n            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PACKED_COLOR, exports.VertexAttributeLocation.PACKED_COLOR, startIndex, new Uint8Array(new Float32Array(packedFillStroke_1).buffer));\n            var fill = this.instance.parsedStyle.fill;\n            var i = this.textureMappings.findIndex(function (m) { return m.name === FILL_TEXTURE_MAPPING; });\n            if (gLite.isCSSRGB(fill)) {\n                if (i >= 0) {\n                    // remove original fill texture mapping\n                    this.textureMappings.splice(i, -1);\n                    this.material.textureDirty = true;\n                }\n            }\n            else {\n                var fillTextureMapping = this.createFillGradientTextureMapping([\n                    this.instance,\n                ]);\n                if (i >= 0) {\n                    this.textureMappings.splice(i, 1, fillTextureMapping);\n                }\n                this.material.textureDirty = true;\n            }\n        }\n        else if (stylePacked.indexOf(name) > -1) {\n            var packed_1 = [];\n            objects.forEach(function (object) {\n                var _a = object.parsedStyle, opacity = _a.opacity, fillOpacity = _a.fillOpacity, strokeOpacity = _a.strokeOpacity, lineWidth = _a.lineWidth, visibility = _a.visibility, anchor = _a.anchor, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting;\n                packed_1.push(opacity, fillOpacity, strokeOpacity, lineWidth, visibility === 'visible' ? 1 : 0, anchor[0], anchor[1], increasedLineWidthForHitTesting || 0);\n            });\n            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PACKED_STYLE, exports.VertexAttributeLocation.PACKED_STYLE1, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));\n        }\n        else if (name === 'modelMatrix') {\n            var packed_2 = [];\n            var modelMatrix_1 = glMatrix.mat4.create();\n            objects.forEach(function (object) {\n                if (_this.mergeAnchorIntoModelMatrix) {\n                    var anchor = object.parsedStyle.anchor;\n                    var translateX = 0;\n                    var translateY = 0;\n                    var translateZ = 0;\n                    var contentBounds = object.getGeometryBounds();\n                    if (contentBounds) {\n                        var halfExtents = contentBounds.halfExtents;\n                        translateX = -halfExtents[0] * anchor[0] * 2;\n                        translateY = -halfExtents[1] * anchor[1] * 2;\n                        translateZ = -halfExtents[2] * (anchor[2] || 0) * 2;\n                    }\n                    glMatrix.mat4.mul(modelMatrix_1, object.getWorldTransform(), // apply anchor\n                    glMatrix.mat4.fromTranslation(modelMatrix_1, glMatrix.vec3.fromValues(translateX, translateY, translateZ)));\n                }\n                else {\n                    glMatrix.mat4.copy(modelMatrix_1, object.getWorldTransform());\n                }\n                packed_2.push.apply(packed_2, tslib.__spreadArray([], tslib.__read(modelMatrix_1), false));\n            });\n            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.MODEL_MATRIX, exports.VertexAttributeLocation.MODEL_MATRIX0, startIndex, new Uint8Array(new Float32Array(packed_2).buffer));\n        }\n        else if (name === 'pointerEvents') {\n            var packed_3 = [];\n            objects.forEach(function (object) {\n                var _a;\n                var encodedPickingColor = (value &&\n                    object.isInteractive() &&\n                    (\n                    // @ts-ignore\n                    (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];\n                packed_3.push.apply(packed_3, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(encodedPickingColor), false), [object.sortable.renderOrder * RENDER_ORDER_SCALE], false));\n            });\n            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PICKING_COLOR, exports.VertexAttributeLocation.PICKING_COLOR, startIndex, new Uint8Array(new Float32Array(packed_3).buffer));\n        }\n    };\n    Instanced.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        if (name === 'clipPath') {\n            if (this.clipPath) {\n                this.geometryDirty = true;\n            }\n        }\n    };\n    Instanced.prototype.changeRenderOrder = function (object, renderOrder) {\n        var _a;\n        var index = this.objects.indexOf(object);\n        var encodedPickingColor = (object.isInteractive() &&\n            (\n            // @ts-ignore\n            (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];\n        this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.PICKING_COLOR, exports.VertexAttributeLocation.PICKING_COLOR, index, new Uint8Array(new Float32Array(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(encodedPickingColor), false), [\n            renderOrder * RENDER_ORDER_SCALE,\n        ], false)).buffer));\n    };\n    Instanced.prototype.generateWireframe = function (geometry) {\n        // need generate barycentric coordinates\n        var indices = geometry.indices;\n        var indiceNum = geometry.indices.length;\n        var originalVertexBuffers = geometry.vertices.map(function (buffer) {\n            // @ts-ignore\n            return buffer.slice();\n        });\n        for (var i = exports.VertexAttributeBufferIndex.PICKING_COLOR; i < geometry.vertexBuffers.length; i++) {\n            var arrayStride = geometry.inputLayoutDescriptor.vertexBufferDescriptors[i].arrayStride;\n            geometry.vertices[i] = new Float32Array((arrayStride / 4) * indiceNum);\n        }\n        // reallocate attribute data\n        var cursor = 0;\n        var uniqueIndices = new Uint32Array(indiceNum);\n        for (var i = 0; i < indiceNum; i++) {\n            var ii = indices[i];\n            for (var j = 1; j < geometry.vertices.length; j++) {\n                var arrayStride = geometry.inputLayoutDescriptor.vertexBufferDescriptors[j].arrayStride;\n                var size = arrayStride / 4;\n                for (var k = 0; k < size; k++) {\n                    geometry.vertices[j][cursor * size + k] =\n                        originalVertexBuffers[j][ii * size + k];\n                }\n            }\n            uniqueIndices[i] = cursor;\n            cursor++;\n        }\n        for (var i = exports.VertexAttributeBufferIndex.PICKING_COLOR + 1; i < geometry.vertexBuffers.length; i++) {\n            // if (i === 3) {\n            //   continue;\n            // }\n            var _a = geometry.inputLayoutDescriptor.vertexBufferDescriptors[i], stepMode = _a.stepMode, arrayStride = _a.arrayStride;\n            var descriptor = geometry.inputLayoutDescriptor.vertexBufferDescriptors[i].attributes[0];\n            if (descriptor) {\n                var location_1 = descriptor.shaderLocation, bufferByteOffset = descriptor.offset, format = descriptor.format, divisor = descriptor.divisor;\n                geometry.setVertexBuffer({\n                    bufferIndex: i,\n                    byteStride: arrayStride,\n                    stepMode: stepMode,\n                    attributes: [\n                        {\n                            format: format,\n                            bufferByteOffset: bufferByteOffset,\n                            location: location_1,\n                            divisor: divisor,\n                        },\n                    ],\n                    data: geometry.vertices[i],\n                });\n            }\n        }\n        // create barycentric attributes\n        var barycentricBuffer = new Float32Array(indiceNum * 3);\n        for (var i = 0; i < indiceNum;) {\n            for (var j = 0; j < 3; j++) {\n                var ii = uniqueIndices[i++];\n                barycentricBuffer[ii * 3 + j] = 1;\n            }\n        }\n        geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.BARYCENTRIC,\n            byteStride: 4 * 3,\n            stepMode: gDeviceApi.VertexStepMode.VERTEX,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGB,\n                    bufferByteOffset: 4 * 0,\n                    location: Number(exports.VertexAttributeLocation.BARYCENTRIC),\n                },\n            ],\n            data: barycentricBuffer,\n        });\n        geometry.setIndexBuffer(uniqueIndices);\n    };\n    Instanced.prototype.beforeUploadUBO = function (renderInst, objects) { };\n    Instanced.prototype.uploadUBO = function (renderInst) {\n        var _this = this;\n        var _a;\n        var numUniformBuffers = 1; // Scene UBO\n        var material = this.material;\n        var lights = this.lightPool.getAllLights();\n        var fog = this.lightPool.getFog();\n        var useFog = !!fog;\n        var useLight = (_a = material.defines.USE_LIGHT) !== null && _a !== void 0 ? _a : !!lights.length;\n        var useWireframe = material.defines.USE_WIREFRAME;\n        // collect uniforms\n        var uniforms = [];\n        if (useWireframe) {\n            var wireframeColor = gLite.parseColor(material.wireframeColor);\n            uniforms.push({\n                name: 'u_WireframeLineColor',\n                value: [\n                    Number(wireframeColor.r) / 255,\n                    Number(wireframeColor.g) / 255,\n                    Number(wireframeColor.b) / 255,\n                ],\n            });\n            uniforms.push({\n                name: 'u_WireframeLineWidth',\n                value: material.wireframeLineWidth,\n            });\n        }\n        if (useFog) {\n            this.uploadFog(uniforms, fog);\n        }\n        this.uploadMaterial(uniforms, material);\n        if (useLight) {\n            var counter_1 = {};\n            lights.forEach(function (light) {\n                if (!counter_1[light.define]) {\n                    counter_1[light.define] = -1;\n                }\n                counter_1[light.define]++;\n                light.uploadUBO(uniforms, counter_1[light.define]);\n            });\n        }\n        uniforms.sort(function (a, b) {\n            return _this.material.uniformNames.indexOf(a.name) -\n                _this.material.uniformNames.indexOf(b.name);\n        });\n        // TODO: should not upload all uniforms if no change\n        renderInst.setUniforms(numUniformBuffers, uniforms);\n        var depthCompare = material.depthCompare, depthWrite = material.depthWrite, stencilFront = material.stencilFront, stencilBack = material.stencilBack, stencilWrite = material.stencilWrite, stencilRef = material.stencilRef, cullMode = material.cullMode, frontFace = material.frontFace, polygonOffset = material.polygonOffset, blendConstant = material.blendConstant, blendEquation = material.blendEquation, blendEquationAlpha = material.blendEquationAlpha, blendSrc = material.blendSrc, blendDst = material.blendDst, blendSrcAlpha = material.blendSrcAlpha, blendDstAlpha = material.blendDstAlpha;\n        var materialMegaState = definedProps({\n            blendConstant: blendConstant,\n            depthCompare: depthCompare,\n            depthWrite: depthWrite,\n            stencilFront: stencilFront,\n            stencilBack: stencilBack,\n            stencilWrite: stencilWrite,\n            stencilRef: stencilRef,\n            cullMode: cullMode,\n            frontFace: frontFace,\n            polygonOffset: polygonOffset,\n        });\n        var currentAttachmentsState = renderInst.getMegaStateFlags().attachmentsState[0];\n        renderInst.setMegaStateFlags(tslib.__assign({ attachmentsState: [\n                {\n                    // should not affect color buffer when drawing stencil\n                    channelWriteMask: this.material.stencilWrite\n                        ? gDeviceApi.ChannelWriteMask.NONE\n                        : gDeviceApi.ChannelWriteMask.ALL,\n                    // channelWriteMask: ChannelWriteMask.AllChannels,\n                    rgbBlendState: tslib.__assign(tslib.__assign({}, currentAttachmentsState.rgbBlendState), definedProps({\n                        blendMode: blendEquation,\n                        blendSrcFactor: blendSrc,\n                        blendDstFactor: blendDst,\n                    })),\n                    alphaBlendState: tslib.__assign(tslib.__assign({}, currentAttachmentsState.alphaBlendState), definedProps({\n                        blendMode: blendEquationAlpha,\n                        blendSrcFactor: blendSrcAlpha,\n                        blendDstFactor: blendDstAlpha,\n                    })),\n                },\n            ] }, materialMegaState));\n        renderInst.setBindingLayout({\n            numUniformBuffers: numUniformBuffers,\n            numSamplers: this.textureMappings.length,\n        });\n        renderInst.setSamplerBindingsFromTextureMappings(this.textureMappings);\n    };\n    Instanced.prototype.uploadFog = function (uniforms, fog) {\n        var _a = fog.parsedStyle, type = _a.type, fill = _a.fill, start = _a.start, end = _a.end, density = _a.density;\n        if (gLite.isCSSRGB(fill)) {\n            var fillColor = [\n                Number(fill.r) / 255,\n                Number(fill.g) / 255,\n                Number(fill.b) / 255,\n                Number(fill.alpha),\n            ];\n            uniforms.push({\n                name: 'u_FogInfos',\n                value: [type, start, end, density],\n            });\n            uniforms.push({\n                name: 'u_FogColor',\n                value: fillColor,\n            });\n        }\n    };\n    Instanced.prototype.uploadMaterial = function (uniforms, material) {\n        // sort\n        var materialUniforms = Object.keys(material.uniforms).map(function (name) { return ({\n            name: name,\n            value: material.uniforms[name],\n        }); });\n        uniforms.push.apply(uniforms, tslib.__spreadArray([], tslib.__read(materialUniforms), false));\n    };\n    Instanced.prototype.createFillGradientTextureMapping = function (objects) {\n        var _this = this;\n        var instance = objects[0];\n        // should account for Line, Path, Polyline and Polyline\n        var fill = instance.parsedStyle[this.gradientAttributeName];\n        var texImageSource;\n        // use pattern & gradient\n        if (fill && (gLite.isPattern(fill) || Array.isArray(fill))) {\n            if (Array.isArray(fill)) {\n                this.program.setDefineBool('USE_PATTERN', false);\n                this.texturePool.getOrCreateGradient({\n                    gradients: fill,\n                    width: 128,\n                    height: 128,\n                    instance: instance,\n                });\n            }\n            else if (gLite.isPattern(fill)) {\n                this.program.setDefineBool('USE_PATTERN', true);\n                this.texturePool.getOrCreatePattern(fill, instance, function () {\n                    // need re-render\n                    objects.forEach(function (object) {\n                        object.renderable.dirty = true;\n                    });\n                    _this.material.textureDirty = true;\n                });\n            }\n            texImageSource = this.texturePool.getOrCreateCanvas();\n            var texture = this.texturePool.getOrCreateTexture(this.context.device, texImageSource, gDeviceApi.makeTextureDescriptor2D(gDeviceApi.Format.U8_RGBA_NORM, 1, 1, 1));\n            if (texture) {\n                var fillMapping = new TextureMapping();\n                fillMapping.name = FILL_TEXTURE_MAPPING;\n                fillMapping.texture = texture;\n                fillMapping.texture.on('loaded', function () {\n                    // need re-render\n                    objects.forEach(function (object) {\n                        object.renderable.dirty = true;\n                    });\n                    _this.material.textureDirty = true;\n                });\n                this.context.device.setResourceName(fillMapping.texture, 'Fill Texture' + this.id);\n                fillMapping.sampler = this.renderHelper.getCache().createSampler({\n                    addressModeU: gDeviceApi.AddressMode.CLAMP_TO_EDGE,\n                    addressModeV: gDeviceApi.AddressMode.CLAMP_TO_EDGE,\n                    minFilter: gDeviceApi.FilterMode.POINT,\n                    magFilter: gDeviceApi.FilterMode.BILINEAR,\n                    mipmapFilter: gDeviceApi.MipmapFilterMode.LINEAR,\n                    lodMinClamp: 0,\n                    lodMaxClamp: 0,\n                });\n                return fillMapping;\n            }\n        }\n        return null;\n    };\n    return Instanced;\n}());\n\nvar frag$4 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nin vec4 v_PickingResult;\\nin vec4 v_Color;\\nin vec4 v_StrokeColor;\\nin vec4 v_StylePacked1;\\nin vec4 v_StylePacked2;\\n#ifdef USE_UV\\n  in vec2 v_Uv;\\n#endif\\n#ifdef USE_MAP\\n  uniform sampler2D u_Map;\\n#endif\\n\\nin vec2 v_Data;\\nin vec2 v_Radius;\\nin vec3 v_StylePacked3;\\n\\nout vec4 outputColor;\\nfloat epsilon = 0.000001;\\n\\n/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\n// @see http://www.iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\\nfloat sdEllipsoidApproximated(vec2 p, vec2 r) {\\n  float k0 = length(p / r);\\n  float k1 = length(p / (r * r));\\n  return k0 * (k0 - 1.0) / k1;\\n}\\n\\n// @see https://www.shadertoy.com/view/4llXD7\\nfloat sdRoundedBox(vec2 p, vec2 b, float r) {\\n  p = abs(p) - b + r;\\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0) - r;\\n}\\n\\nvoid main() {\\n  int shape = int(floor(v_StylePacked3.x + 0.5));\\n\\n  vec4 u_Color = v_Color;\\nvec4 u_StrokeColor = v_StrokeColor;\\nfloat u_Opacity = v_StylePacked1.x;\\nfloat u_FillOpacity = v_StylePacked1.y;\\nfloat u_StrokeOpacity = v_StylePacked1.z;\\nfloat u_StrokeWidth = v_StylePacked1.w;\\nfloat u_Visible = v_StylePacked2.x;\\nvec3 u_PickingColor = v_PickingResult.xyz;\\n\\nif (u_Visible < 0.5) {\\n    discard;\\n}\\n  #ifdef USE_MAP\\n  #ifdef USE_PATTERN\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #else\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #endif\\n#endif\\n\\n  bool omitStroke = v_StylePacked3.z == 1.0;\\n\\n  vec2 r = (v_Radius - (omitStroke ? 0.0 : u_StrokeWidth)) / v_Radius.y;\\n  float wh = v_Radius.x / v_Radius.y;\\n\\n  float dist = length(v_Data);\\n  float antialiased_blur = -fwidth(dist);\\n\\n  float outer_df;\\n  float inner_df;\\n  // 'circle', 'ellipse', 'rect'\\n  if (shape == 0) {\\n    outer_df = sdCircle(v_Data, 1.0);\\n    inner_df = sdCircle(v_Data, r.x);\\n  } else if (shape == 1) {\\n    outer_df = sdEllipsoidApproximated(v_Data, vec2(wh, 1.0));\\n    inner_df = sdEllipsoidApproximated(v_Data, r);\\n  } else if (shape == 2) {\\n    bool useRadius = v_StylePacked3.y > epsilon;\\n    outer_df = sdRoundedBox(v_Data, vec2(wh, 1.0), useRadius ? (v_StylePacked3.y + u_StrokeWidth / 2.0) / v_Radius.y : 0.0);\\n    inner_df = sdRoundedBox(v_Data, r, useRadius ? (v_StylePacked3.y - u_StrokeWidth / 2.0) / v_Radius.y : 0.0);\\n  }\\n\\n  float opacity_t = smoothstep(0.0, antialiased_blur, outer_df);\\n\\n  float color_t = u_StrokeWidth < 0.01 ? 0.0 : smoothstep(\\n    antialiased_blur,\\n    0.0,\\n    inner_df\\n  );\\n\\n  vec4 diffuseColor;\\n  vec4 strokeColor;\\n  if (u_IsPicking > 0.5) {\\n    diffuseColor = vec4(u_PickingColor, 1.0);\\n    strokeColor = vec4(u_PickingColor, 1.0);\\n  } else {\\n    diffuseColor = u_Color;\\n    strokeColor = (u_StrokeColor == vec4(0) || omitStroke) ? vec4(0.0) : u_StrokeColor;\\n  }\\n\\n  outputColor = mix(vec4(diffuseColor.rgb, diffuseColor.a * u_FillOpacity), strokeColor * u_StrokeOpacity, color_t);\\n  outputColor.a = outputColor.a * u_Opacity * opacity_t;\\n\\n  if (outputColor.a < epsilon)\\n    discard;\\n\\n  if (u_IsPicking > 0.5) {\\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\\n      discard;\\n    }\\n  }\\n}\"; // eslint-disable-line\n\nvar vert$4 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\\n\\nout vec4 v_PickingResult;\\nout vec4 v_Color;\\nout vec4 v_StrokeColor;\\nout vec4 v_StylePacked1;\\nout vec4 v_StylePacked2;\\n\\n#define COLOR_SCALE 1. / 255.\\nvoid setPickingColor(vec3 pickingColor) {\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nvec2 unpack_float(const float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\nvec4 decode_color(const vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\\n  return pm * vm * mm * pos;\\n}\\n\\nbool isPerspectiveMatrix(mat4 m) {\\n  return m[2][3] == -1.0;\\n}\\n\\nvec4 billboard(vec2 offset, float rotation, bool isSizeAttenuation, mat4 pm, mat4 vm, mat4 mm) {\\n  vec4 mvPosition = vm * mm * vec4(0.0, 0.0, 0.0, 1.0);\\n  vec2 scale;\\n  scale.x = length(vec3(mm[0][0], mm[0][1], mm[0][2]));\\n  scale.y = length(vec3(mm[1][0], mm[1][1], mm[1][2]));\\n\\n  if (isSizeAttenuation) {\\n    bool isPerspective = isPerspectiveMatrix(pm);\\n    if (isPerspective) {\\n      scale *= -mvPosition.z / 250.0;\\n    }\\n  }\\n\\n  vec2 alignedPosition = offset * scale;\\n  vec2 rotatedPosition;\\n  rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\\n  rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\\n\\n  mvPosition.xy += rotatedPosition;\\n  return pm * mvPosition;\\n}\\n\\nlayout(location = POSITION) in vec2 a_Extrude;\\n// shape, radius, omitStroke, isBillboard\\nlayout(location = PACKED_STYLE3) in vec3 a_StylePacked3;\\nlayout(location = SIZE) in vec4 a_Size;\\n#ifdef USE_UV\\n  layout(location = UV) in vec2 a_Uv;\\n  out vec2 v_Uv;\\n#endif\\n\\nout vec2 v_Data;\\nout vec2 v_Radius;\\nout vec3 v_StylePacked3;\\n\\nvoid main() {\\n  vec4 a_Color = decode_color(a_PackedColor.xy);\\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\\n\\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\\nvec4 u_StrokeColor = a_StrokeColor;\\nfloat u_Opacity = a_StylePacked1.x;\\nfloat u_FillOpacity = a_StylePacked1.y;\\nfloat u_StrokeOpacity = a_StylePacked1.z;\\nfloat u_StrokeWidth = a_StylePacked1.w;\\nfloat u_ZIndex = a_PickingColor.w;\\nvec2 u_Anchor = a_StylePacked2.yz;\\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\\n\\nsetPickingColor(a_PickingColor.xyz);\\n\\nv_Color = a_Color;\\nv_StrokeColor = a_StrokeColor;\\nv_StylePacked1 = a_StylePacked1;\\nv_StylePacked2 = a_StylePacked2;\\n\\n// #ifdef CLIPSPACE_NEAR_ZERO\\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\\n// #endif\\n  #ifdef USE_UV\\n  v_Uv = a_Uv;\\n#endif\\n\\n  float strokeWidth;\\n  if (u_IsPicking > 0.5) {\\n    strokeWidth = u_IncreasedLineWidthForHitTesting + u_StrokeWidth;\\n  } else {\\n    strokeWidth = u_StrokeWidth;\\n  }\\n\\n  bool omitStroke = a_StylePacked3.z == 1.0;\\n  vec2 radius = a_Size.xy + vec2(omitStroke ? 0.0 : strokeWidth / 2.0);\\n  vec2 offset = (a_Extrude + vec2(1.0) - 2.0 * u_Anchor.xy) * a_Size.xy + a_Extrude * vec2(omitStroke ? 0.0 : strokeWidth / 2.0);\\n\\n  bool isBillboard = a_Size.z > 0.5;\\n  if (isBillboard) {\\n    float rotation = 0.0;\\n    bool isSizeAttenuation = a_Size.w > 0.5;\\n    gl_Position = billboard(offset, rotation, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  } else {\\n    gl_Position = project(vec4(offset, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  }\\n  \\n  v_Radius = radius;\\n  v_Data = vec2(a_Extrude * radius / radius.y);\\n  v_StylePacked3 = a_StylePacked3;\\n}\"; // eslint-disable-line\n\nvar SDFVertexAttributeBufferIndex;\n(function (SDFVertexAttributeBufferIndex) {\n    SDFVertexAttributeBufferIndex[SDFVertexAttributeBufferIndex[\"PACKED_STYLE\"] = 5] = \"PACKED_STYLE\";\n})(SDFVertexAttributeBufferIndex || (SDFVertexAttributeBufferIndex = {}));\nvar SDFVertexAttributeLocation;\n(function (SDFVertexAttributeLocation) {\n    SDFVertexAttributeLocation[SDFVertexAttributeLocation[\"PACKED_STYLE3\"] = 12] = \"PACKED_STYLE3\";\n    SDFVertexAttributeLocation[SDFVertexAttributeLocation[\"SIZE\"] = 13] = \"SIZE\";\n})(SDFVertexAttributeLocation || (SDFVertexAttributeLocation = {}));\nvar SDF_Shape = [gLite.Shape.CIRCLE, gLite.Shape.ELLIPSE, gLite.Shape.RECT];\n/**\n * Use SDF to render 2D shapes, eg. circle, ellipse.\n * Use less triangles(2) and vertices compared with normal triangulation.\n */\nvar SDFDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(SDFDrawcall, _super);\n    function SDFDrawcall() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SDFDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        // if (\n        //   this.needDrawStrokeSeparately(object.parsedStyle) ||\n        //   this.needDrawStrokeSeparately(this.instance.parsedStyle)\n        // ) {\n        //   return false;\n        // }\n        // const { fill: instanceFill } = this.instance\n        //   .parsedStyle as ParsedBaseStyleProps;\n        // const { fill } = object.parsedStyle as ParsedBaseStyleProps;\n        // if ((instanceFill as CSSRGB).isNone !== (fill as CSSRGB).isNone) {\n        //   return false;\n        // }\n        return true;\n    };\n    SDFDrawcall.prototype.createMaterial = function (objects) {\n        this.material.vertexShader = vert$4;\n        this.material.fragmentShader = frag$4;\n        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(SDFVertexAttributeLocation));\n    };\n    SDFDrawcall.prototype.createGeometry = function (objects) {\n        var _this = this;\n        // use default common attributes\n        _super.prototype.createGeometry.call(this, objects);\n        var instanced = [];\n        objects.forEach(function (object, i) {\n            var circle = object;\n            // @ts-ignore\n            var radius = circle.parsedStyle.radius;\n            var omitStroke = _this.shouldOmitStroke(circle.parsedStyle);\n            var size = _this.getSize(object.parsedStyle, circle.nodeName);\n            instanced.push.apply(instanced, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(size), false), [circle.parsedStyle.isBillboard ? 1 : 0,\n                circle.parsedStyle.isSizeAttenuation ? 1 : 0,\n                SDF_Shape.indexOf(circle.nodeName),\n                (radius && radius[0]) || 0,\n                omitStroke ? 1 : 0], false));\n        });\n        this.geometry.setIndexBuffer(new Uint32Array([0, 2, 1, 0, 3, 2]));\n        this.geometry.vertexCount = 6;\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,\n            byteStride: 4 * 4,\n            stepMode: gDeviceApi.VertexStepMode.VERTEX,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.POSITION,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 2,\n                    location: exports.VertexAttributeLocation.UV,\n                },\n            ],\n            data: new Float32Array([\n                -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1,\n            ]),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: SDFVertexAttributeBufferIndex.PACKED_STYLE,\n            byteStride: 4 * 7,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: SDFVertexAttributeLocation.SIZE,\n                    divisor: 1,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGB,\n                    bufferByteOffset: 4 * 4,\n                    location: SDFVertexAttributeLocation.PACKED_STYLE3,\n                    divisor: 1,\n                },\n            ],\n            data: new Float32Array(instanced),\n        });\n    };\n    SDFDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        var _this = this;\n        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);\n        this.updateBatchedAttribute(objects, startIndex, name, value);\n        if (name === 'r' ||\n            name === 'rx' ||\n            name === 'ry' ||\n            name === 'width' ||\n            name === 'height' ||\n            name === 'lineWidth' ||\n            name === 'stroke' ||\n            name === 'lineDash' ||\n            name === 'strokeOpacity' ||\n            name === 'radius' ||\n            name === 'isBillboard' ||\n            name === 'isSizeAttenuation') {\n            var packed_1 = [];\n            objects.forEach(function (object) {\n                var circle = object;\n                var omitStroke = _this.shouldOmitStroke(circle.parsedStyle);\n                var _a = tslib.__read(_this.getSize(object.parsedStyle, object.nodeName), 2), halfWidth = _a[0], halfHeight = _a[1];\n                var size = [halfWidth, halfHeight];\n                packed_1.push.apply(packed_1, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(size), false), [circle.parsedStyle.isBillboard ? 1 : 0,\n                    circle.parsedStyle.isSizeAttenuation ? 1 : 0,\n                    SDF_Shape.indexOf(object.nodeName),\n                    (object.parsedStyle.radius && object.parsedStyle.radius[0]) || 0,\n                    omitStroke ? 1 : 0], false));\n            });\n            this.geometry.updateVertexBuffer(SDFVertexAttributeBufferIndex.PACKED_STYLE, SDFVertexAttributeLocation.SIZE, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));\n        }\n    };\n    SDFDrawcall.prototype.getSize = function (parsed, tagName) {\n        var size = [0, 0];\n        if (tagName === gLite.Shape.CIRCLE) {\n            var r = parsed.r;\n            size = [r, r];\n        }\n        else if (tagName === gLite.Shape.ELLIPSE) {\n            var _a = parsed, rx = _a.rx, ry = _a.ry;\n            size = [rx, ry];\n        }\n        else if (tagName === gLite.Shape.RECT) {\n            var _b = parsed, width = _b.width, height = _b.height;\n            size = [width / 2, height / 2];\n        }\n        return size;\n    };\n    SDFDrawcall.prototype.shouldOmitStroke = function (parsedStyle) {\n        var lineDash = parsedStyle.lineDash, stroke = parsedStyle.stroke, strokeOpacity = parsedStyle.strokeOpacity;\n        var hasStroke = stroke && !stroke.isNone;\n        var hasLineDash = lineDash &&\n            lineDash.length &&\n            lineDash.every(function (item) { return item !== 0; });\n        var hasStrokeOpacity = strokeOpacity < 1;\n        return !hasStroke || (hasStroke && (hasLineDash || hasStrokeOpacity));\n    };\n    return SDFDrawcall;\n}(Instanced));\n\nvar frag$3 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nin vec4 v_PickingResult;\\nin vec4 v_Color;\\nin vec4 v_StrokeColor;\\nin vec4 v_StylePacked1;\\nin vec4 v_StylePacked2;\\n#ifdef USE_UV\\n  in vec2 v_Uv;\\n#endif\\n#ifdef USE_MAP\\n  uniform sampler2D u_Map;\\n#endif\\n\\nin vec4 v_Dash;\\nin vec2 v_Distance;\\n\\nout vec4 outputColor;\\nfloat epsilon = 0.000001;\\n\\nvoid main() {\\n  vec4 u_Color = v_Color;\\nvec4 u_StrokeColor = v_StrokeColor;\\nfloat u_Opacity = v_StylePacked1.x;\\nfloat u_FillOpacity = v_StylePacked1.y;\\nfloat u_StrokeOpacity = v_StylePacked1.z;\\nfloat u_StrokeWidth = v_StylePacked1.w;\\nfloat u_Visible = v_StylePacked2.x;\\nvec3 u_PickingColor = v_PickingResult.xyz;\\n\\nif (u_Visible < 0.5) {\\n    discard;\\n}\\n  #ifdef USE_MAP\\n  #ifdef USE_PATTERN\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #else\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #endif\\n#endif\\n\\n  if (u_IsPicking > 0.5) {\\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\\n      discard;\\n    }\\n    outputColor = vec4(u_PickingColor, 1.0);\\n  } else {\\n    outputColor = u_StrokeColor;\\n    #ifdef USE_MAP\\n      outputColor = u_Color;\\n    #endif\\n\\n    float blur;\\n    if (v_Distance.y < 1.0) {\\n      blur = smoothstep(0.0, v_Distance.y, 1.0 - abs(v_Distance.x));\\n    } else {\\n      blur = 1.0 / v_Distance.y;\\n    }\\n    float u_dash_offset = v_Dash.y;\\n    float u_dash_array = v_Dash.z;\\n    float u_dash_ratio = v_Dash.w;\\n\\n    outputColor.a = outputColor.a\\n      * blur\\n      * u_Opacity * u_StrokeOpacity\\n      * (u_dash_array < 1.0 ? (ceil((u_dash_array * u_dash_ratio) - mod(v_Dash.x + u_dash_offset, u_dash_array))) : 1.0);\\n\\n    if (outputColor.a < epsilon) {\\n      discard;\\n    }\\n  }\\n}\"; // eslint-disable-line\n\nvar vert$3 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\\n\\nout vec4 v_PickingResult;\\nout vec4 v_Color;\\nout vec4 v_StrokeColor;\\nout vec4 v_StylePacked1;\\nout vec4 v_StylePacked2;\\n\\n#define COLOR_SCALE 1. / 255.\\nvoid setPickingColor(vec3 pickingColor) {\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nvec2 unpack_float(const float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\nvec4 decode_color(const vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\\n  return pm * vm * mm * pos;\\n}\\n\\nlayout(location = POSITION) in vec3 a_Position;\\nlayout(location = POINTA) in vec3 a_PointA;\\nlayout(location = POINTB) in vec3 a_PointB;\\nlayout(location = CAP) in float a_Cap;\\n#ifdef USE_UV\\n  layout(location = UV) in vec2 a_Uv;\\n  out vec2 v_Uv;\\n#endif\\nlayout(location = DASH) in vec4 a_Dash;\\n\\nout vec4 v_Dash;\\nout vec2 v_Distance;\\n\\nvoid main() {\\n  vec4 a_Color = decode_color(a_PackedColor.xy);\\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\\n\\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\\nvec4 u_StrokeColor = a_StrokeColor;\\nfloat u_Opacity = a_StylePacked1.x;\\nfloat u_FillOpacity = a_StylePacked1.y;\\nfloat u_StrokeOpacity = a_StylePacked1.z;\\nfloat u_StrokeWidth = a_StylePacked1.w;\\nfloat u_ZIndex = a_PickingColor.w;\\nvec2 u_Anchor = a_StylePacked2.yz;\\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\\n\\nsetPickingColor(a_PickingColor.xyz);\\n\\nv_Color = a_Color;\\nv_StrokeColor = a_StrokeColor;\\nv_StylePacked1 = a_StylePacked1;\\nv_StylePacked2 = a_StylePacked2;\\n\\n// #ifdef CLIPSPACE_NEAR_ZERO\\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\\n// #endif\\n  #ifdef USE_UV\\n  v_Uv = a_Uv;\\n#endif\\n\\n  float strokeWidth;\\n  if (u_IsPicking > 0.5) {\\n    strokeWidth = u_IncreasedLineWidthForHitTesting + u_StrokeWidth;\\n  } else {\\n    strokeWidth = u_StrokeWidth;\\n  }\\n  float clampedStrokeWidth = max(strokeWidth, 1.0);\\n\\n  bool isSizeAttenuation = a_Dash.w > 0.5;\\n  if (isSizeAttenuation) {\\n    vec4 clip0 = project(vec4(a_PointA, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n    vec4 clip1 = project(vec4(a_PointB, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n    // screen space\\n    vec2 screen0 = u_Viewport * (0.5 * clip0.xy / clip0.w + 0.5);\\n    vec2 screen1 = u_Viewport * (0.5 * clip1.xy / clip1.w + 0.5);\\n    vec2 xBasis = normalize(screen1 - screen0);\\n    vec2 yBasis = vec2(-xBasis.y, xBasis.x);\\n    vec2 pt0 = screen0 + clampedStrokeWidth * (a_Position.x * xBasis + a_Position.y * yBasis);\\n    vec2 pt1 = screen1 + clampedStrokeWidth * (a_Position.x * xBasis + a_Position.y * yBasis);\\n    vec2 pt = mix(pt0, pt1, a_Position.z);\\n    vec4 clip = mix(clip0, clip1, a_Position.z);\\n    gl_Position = vec4(clip.w * (2.0 * pt / u_Viewport - 1.0), clip.z, clip.w);\\n  } else {\\n    vec2 xBasis = a_PointB.xy - a_PointA.xy;\\n    vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\\n\\n    vec2 point = a_PointA.xy + xBasis * a_Position.x + yBasis * clampedStrokeWidth * a_Position.y;\\n    point = point - u_Anchor.xy * abs(xBasis);\\n\\n    // round & square\\n    if (a_Cap > 1.0) {\\n      point += sign(a_Position.x - 0.5) * normalize(xBasis) * vec2(clampedStrokeWidth / 2.0);\\n    }\\n    gl_Position = project(vec4(point, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  }\\n\\n  float antialiasblur = 1.0 / strokeWidth;\\n  v_Distance = vec2(a_Position.y * 2.0, antialiasblur);\\n  v_Dash = vec4(a_Position.x, a_Dash.xyz);\\n}\"; // eslint-disable-line\n\nvar meshFrag = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nin vec4 v_PickingResult;\\nin vec4 v_Color;\\nin vec4 v_StrokeColor;\\nin vec4 v_StylePacked1;\\nin vec4 v_StylePacked2;\\n#ifdef USE_UV\\n  in vec2 v_Uv;\\n#endif\\n#ifdef USE_MAP\\n  uniform sampler2D u_Map;\\n#endif\\n\\nout vec4 outputColor;\\n\\nvoid main(){\\n  vec4 u_Color = v_Color;\\nvec4 u_StrokeColor = v_StrokeColor;\\nfloat u_Opacity = v_StylePacked1.x;\\nfloat u_FillOpacity = v_StylePacked1.y;\\nfloat u_StrokeOpacity = v_StylePacked1.z;\\nfloat u_StrokeWidth = v_StylePacked1.w;\\nfloat u_Visible = v_StylePacked2.x;\\nvec3 u_PickingColor = v_PickingResult.xyz;\\n\\nif (u_Visible < 0.5) {\\n    discard;\\n}\\n  #ifdef USE_MAP\\n  #ifdef USE_PATTERN\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #else\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #endif\\n#endif\\n\\n  if (u_IsPicking > 0.5) {\\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\\n      discard;\\n    }\\n    outputColor = vec4(u_PickingColor, 1.0);\\n  } else {\\n    outputColor = u_Color;\\n\\n    outputColor.a = outputColor.a * u_Opacity * u_FillOpacity;\\n  }\\n}\"; // eslint-disable-line\n\nvar meshVert = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\\n\\nout vec4 v_PickingResult;\\nout vec4 v_Color;\\nout vec4 v_StrokeColor;\\nout vec4 v_StylePacked1;\\nout vec4 v_StylePacked2;\\n\\n#define COLOR_SCALE 1. / 255.\\nvoid setPickingColor(vec3 pickingColor) {\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nvec2 unpack_float(const float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\nvec4 decode_color(const vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\\n  return pm * vm * mm * pos;\\n}\\n\\nbool isPerspectiveMatrix(mat4 m) {\\n  return m[2][3] == -1.0;\\n}\\n\\nvec4 billboard(vec2 offset, float rotation, bool isSizeAttenuation, mat4 pm, mat4 vm, mat4 mm) {\\n  vec4 mvPosition = vm * mm * vec4(0.0, 0.0, 0.0, 1.0);\\n  vec2 scale;\\n  scale.x = length(vec3(mm[0][0], mm[0][1], mm[0][2]));\\n  scale.y = length(vec3(mm[1][0], mm[1][1], mm[1][2]));\\n\\n  if (isSizeAttenuation) {\\n    bool isPerspective = isPerspectiveMatrix(pm);\\n    if (isPerspective) {\\n      scale *= -mvPosition.z / 250.0;\\n    }\\n  }\\n\\n  vec2 alignedPosition = offset * scale;\\n  vec2 rotatedPosition;\\n  rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\\n  rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\\n\\n  mvPosition.xy += rotatedPosition;\\n  return pm * mvPosition;\\n}\\n\\nlayout(location = POSITION) in vec3 a_Position;\\nlayout(location = PACKED_STYLE3) in vec4 a_StylePacked3;\\n\\n#ifdef USE_UV\\n  layout(location = UV) in vec2 a_Uv;\\n  out vec2 v_Uv;\\n#endif\\n\\nvoid main() {\\n  vec4 a_Color = decode_color(a_PackedColor.xy);\\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\\n\\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\\nvec4 u_StrokeColor = a_StrokeColor;\\nfloat u_Opacity = a_StylePacked1.x;\\nfloat u_FillOpacity = a_StylePacked1.y;\\nfloat u_StrokeOpacity = a_StylePacked1.z;\\nfloat u_StrokeWidth = a_StylePacked1.w;\\nfloat u_ZIndex = a_PickingColor.w;\\nvec2 u_Anchor = a_StylePacked2.yz;\\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\\n\\nsetPickingColor(a_PickingColor.xyz);\\n\\nv_Color = a_Color;\\nv_StrokeColor = a_StrokeColor;\\nv_StylePacked1 = a_StylePacked1;\\nv_StylePacked2 = a_StylePacked2;\\n\\n// #ifdef CLIPSPACE_NEAR_ZERO\\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\\n// #endif\\n  #ifdef USE_UV\\n  v_Uv = a_Uv;\\n#endif\\n\\n  bool isBillboard = a_StylePacked3.x > 0.5;\\n  if (isBillboard) {\\n    float rotation = a_StylePacked3.y;\\n    bool isSizeAttenuation = a_StylePacked3.z > 0.5;\\n    gl_Position = billboard(a_Position.xy, rotation, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  } else {\\n    gl_Position = project(vec4(a_Position.xy, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  }\\n}\"; // eslint-disable-line\n\nvar frag$2 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nin vec4 v_PickingResult;\\nin vec4 v_Color;\\nin vec4 v_StrokeColor;\\nin vec4 v_StylePacked1;\\nin vec4 v_StylePacked2;\\n#ifdef USE_UV\\n  in vec2 v_Uv;\\n#endif\\n#ifdef USE_MAP\\n  uniform sampler2D u_Map;\\n#endif\\n\\nin vec4 v_Dash;\\n\\nin vec4 v_Distance;\\nin vec4 v_Arc;\\nin float v_Type;\\nin float v_Travel;\\nin float v_ScalingFactor;\\n\\nout vec4 outputColor;\\nfloat epsilon = 0.000001;\\n\\nvoid main(){\\n  vec4 u_Color = v_Color;\\nvec4 u_StrokeColor = v_StrokeColor;\\nfloat u_Opacity = v_StylePacked1.x;\\nfloat u_FillOpacity = v_StylePacked1.y;\\nfloat u_StrokeOpacity = v_StylePacked1.z;\\nfloat u_StrokeWidth = v_StylePacked1.w;\\nfloat u_Visible = v_StylePacked2.x;\\nvec3 u_PickingColor = v_PickingResult.xyz;\\n\\nif (u_Visible < 0.5) {\\n    discard;\\n}\\n  #ifdef USE_MAP\\n  #ifdef USE_PATTERN\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #else\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #endif\\n#endif\\n\\n  float alpha = 1.0;\\n  float lineWidth = v_Distance.w;\\n  if (v_Type < 0.5) {\\n    float left = max(v_Distance.x - 0.5, -v_Distance.w);\\n    float right = min(v_Distance.x + 0.5, v_Distance.w);\\n    float near = v_Distance.y - 0.5;\\n    float far = min(v_Distance.y + 0.5, 0.0);\\n    float top = v_Distance.z - 0.5;\\n    float bottom = min(v_Distance.z + 0.5, 0.0);\\n    alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\\n  } else if (v_Type < 1.5) {\\n    float a1 = clamp(v_Distance.x + 0.5 - lineWidth, 0.0, 1.0);\\n    float a2 = clamp(v_Distance.x + 0.5 + lineWidth, 0.0, 1.0);\\n    float b1 = clamp(v_Distance.y + 0.5 - lineWidth, 0.0, 1.0);\\n    float b2 = clamp(v_Distance.y + 0.5 + lineWidth, 0.0, 1.0);\\n    alpha = a2 * b2 - a1 * b1;\\n  } else if (v_Type < 2.5) {\\n    alpha *= max(min(v_Distance.x + 0.5, 1.0), 0.0);\\n    alpha *= max(min(v_Distance.y + 0.5, 1.0), 0.0);\\n    alpha *= max(min(v_Distance.z + 0.5, 1.0), 0.0);\\n  } else if (v_Type < 3.5) {\\n    float a1 = clamp(v_Distance.x + 0.5 - lineWidth, 0.0, 1.0);\\n    float a2 = clamp(v_Distance.x + 0.5 + lineWidth, 0.0, 1.0);\\n    float b1 = clamp(v_Distance.y + 0.5 - lineWidth, 0.0, 1.0);\\n    float b2 = clamp(v_Distance.y + 0.5 + lineWidth, 0.0, 1.0);\\n    float alpha_miter = a2 * b2 - a1 * b1;\\n    float alpha_plane = max(min(v_Distance.z + 0.5, 1.0), 0.0);\\n    float d = length(v_Arc.xy);\\n    float circle_hor = max(min(v_Arc.w, d + 0.5) - max(-v_Arc.w, d - 0.5), 0.0);\\n    float circle_vert = min(v_Arc.w * 2.0, 1.0);\\n    float alpha_circle = circle_hor * circle_vert;\\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\\n  } else {\\n    float a1 = clamp(v_Distance.x + 0.5 - lineWidth, 0.0, 1.0);\\n    float a2 = clamp(v_Distance.x + 0.5 + lineWidth, 0.0, 1.0);\\n    float b1 = clamp(v_Distance.y + 0.5 - lineWidth, 0.0, 1.0);\\n    float b2 = clamp(v_Distance.y + 0.5 + lineWidth, 0.0, 1.0);\\n    alpha = a2 * b2 - a1 * b1;\\n    alpha *= max(min(v_Distance.z + 0.5, 1.0), 0.0);\\n  }\\n\\n  float u_Dash = v_Dash.x;\\n  float u_Gap = v_Dash.y;\\n  float u_DashOffset = v_Dash.z;\\n  if (u_Dash + u_Gap > 1.0) {\\n    float travel = mod(v_Travel + u_Gap * v_ScalingFactor * 0.5 + u_DashOffset, u_Dash * v_ScalingFactor + u_Gap * v_ScalingFactor) - (u_Gap * v_ScalingFactor * 0.5);\\n    float left = max(travel - 0.5, -0.5);\\n    float right = min(travel + 0.5, u_Gap * v_ScalingFactor + 0.5);\\n    alpha *= max(0.0, right - left);\\n  }\\n\\n  if (u_IsPicking > 0.5) {\\n    vec3 pickingColor = u_PickingColor;\\n    if (pickingColor.x == 0.0 && pickingColor.y == 0.0 && pickingColor.z == 0.0) {\\n      discard;\\n    }\\n    outputColor = vec4(pickingColor, 1.0);\\n  } else {\\n    outputColor = u_StrokeColor;\\n    #ifdef USE_MAP\\n      outputColor = u_Color;\\n    #endif\\n\\n    outputColor.a *= alpha * u_Opacity * u_StrokeOpacity;\\n    if (outputColor.a < epsilon) {\\n      discard;\\n    }\\n  }\\n}\"; // eslint-disable-line\n\nvar vert$2 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\\n\\nout vec4 v_PickingResult;\\nout vec4 v_Color;\\nout vec4 v_StrokeColor;\\nout vec4 v_StylePacked1;\\nout vec4 v_StylePacked2;\\n\\n#define COLOR_SCALE 1. / 255.\\nvoid setPickingColor(vec3 pickingColor) {\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nvec2 unpack_float(const float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\nvec4 decode_color(const vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\\n  return pm * vm * mm * pos;\\n}\\n\\nbool isPerspectiveMatrix(mat4 m) {\\n  return m[2][3] == -1.0;\\n}\\n\\nvec4 billboard(vec2 offset, float rotation, bool isSizeAttenuation, mat4 pm, mat4 vm, mat4 mm) {\\n  vec4 mvPosition = vm * mm * vec4(0.0, 0.0, 0.0, 1.0);\\n  vec2 scale;\\n  scale.x = length(vec3(mm[0][0], mm[0][1], mm[0][2]));\\n  scale.y = length(vec3(mm[1][0], mm[1][1], mm[1][2]));\\n\\n  if (isSizeAttenuation) {\\n    bool isPerspective = isPerspectiveMatrix(pm);\\n    if (isPerspective) {\\n      scale *= -mvPosition.z / 250.0;\\n    }\\n  }\\n\\n  vec2 alignedPosition = offset * scale;\\n  vec2 rotatedPosition;\\n  rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\\n  rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\\n\\n  mvPosition.xy += rotatedPosition;\\n  return pm * mvPosition;\\n}\\n\\nlayout(location = PREV) in vec3 a_Prev;\\nlayout(location = POINT1) in vec3 a_Point1;\\nlayout(location = POINT2) in vec3 a_Point2;\\nlayout(location = NEXT) in vec3 a_Next;\\nlayout(location = VERTEX_JOINT) in float a_VertexJoint;\\nlayout(location = VERTEX_NUM) in float a_VertexNum;\\nlayout(location = TRAVEL) in float a_Travel;\\n#ifdef USE_UV\\n  layout(location = UV) in vec2 a_Uv;\\n  out vec2 v_Uv;\\n#endif\\nlayout(location = DASH) in vec4 a_Dash;\\nout vec4 v_Dash;\\n\\nconst float FILL = 1.0;\\nconst float BEVEL = 4.0;\\nconst float MITER = 8.0;\\nconst float ROUND = 12.0;\\nconst float JOINT_CAP_BUTT = 16.0;\\nconst float JOINT_CAP_SQUARE = 18.0;\\nconst float JOINT_CAP_ROUND = 20.0;\\nconst float FILL_EXPAND = 24.0;\\nconst float CAP_BUTT = 1.0;\\nconst float CAP_SQUARE = 2.0;\\nconst float CAP_ROUND = 3.0;\\nconst float CAP_BUTT2 = 4.0;\\n\\nconst float u_Expand = 1.0;\\nconst float u_MiterLimit = 5.0;\\nconst float u_ScaleMode = 1.0;\\nconst float u_Alignment = 0.5;\\n\\nout vec4 v_Distance;\\nout vec4 v_Arc;\\nout float v_Type;\\nout float v_Travel;\\nout float v_ScalingFactor;\\n\\nvec2 doBisect(\\n  vec2 norm, float len, vec2 norm2, float len2, float dy, float inner\\n) {\\n  vec2 bisect = (norm + norm2) / 2.0;\\n  bisect /= dot(norm, bisect);\\n  vec2 shift = dy * bisect;\\n  if (inner > 0.5) {\\n    if (len < len2) {\\n      if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\\n        return dy * norm;\\n      }\\n    } else {\\n      if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\\n        return dy * norm;\\n      }\\n    }\\n  }\\n  return dy * bisect;\\n}\\n\\nvec2 clip2ScreenSpace(vec4 clip) {\\n  return u_Viewport * (0.5 * clip.xy / clip.w + 0.5);\\n}\\n\\nvoid main() {\\n  vec4 a_Color = decode_color(a_PackedColor.xy);\\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\\n\\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\\nvec4 u_StrokeColor = a_StrokeColor;\\nfloat u_Opacity = a_StylePacked1.x;\\nfloat u_FillOpacity = a_StylePacked1.y;\\nfloat u_StrokeOpacity = a_StylePacked1.z;\\nfloat u_StrokeWidth = a_StylePacked1.w;\\nfloat u_ZIndex = a_PickingColor.w;\\nvec2 u_Anchor = a_StylePacked2.yz;\\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\\n\\nsetPickingColor(a_PickingColor.xyz);\\n\\nv_Color = a_Color;\\nv_StrokeColor = a_StrokeColor;\\nv_StylePacked1 = a_StylePacked1;\\nv_StylePacked2 = a_StylePacked2;\\n\\n// #ifdef CLIPSPACE_NEAR_ZERO\\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\\n// #endif\\n  #ifdef USE_UV\\n  v_Uv = a_Uv;\\n#endif\\n\\n  v_Dash = a_Dash;\\n\\n  vec2 pointA;\\n  vec2 pointB;\\n  vec4 clip0;\\n  vec4 clip1;\\n\\n  float compressed = a_Dash.w;\\n  float is_billboard = floor(compressed / 4.0);\\n  compressed -= is_billboard * 4.0;\\n  float is_size_attenuation = floor(compressed / 2.0);\\n  compressed -= is_size_attenuation * 2.0;\\n  float is_3d_polyline = compressed;\\n\\n  bool isBillboard = is_billboard > 0.5;\\n  bool isSizeAttenuation = is_size_attenuation > 0.5;\\n  bool is3DPolyline = is_3d_polyline > 0.5;\\n  if (isBillboard) {\\n    clip0 = billboard(a_Point1.xy, 0.0, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n    clip1 = billboard(a_Point2.xy, 0.0, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  } else if (is3DPolyline) {\\n    clip0 = project(vec4(a_Point1, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n    clip1 = project(vec4(a_Point2, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  }\\n\\n  if (isBillboard || is3DPolyline) {\\n    pointA = clip2ScreenSpace(clip0);\\n    pointB = clip2ScreenSpace(clip1);\\n  } else {\\n    pointA = (u_ModelMatrix * vec4(a_Point1, 1.0)).xy;\\n    pointB = (u_ModelMatrix * vec4(a_Point2, 1.0)).xy;\\n  }\\n\\n  vec2 xBasis = pointB - pointA;\\n  float len = length(xBasis);\\n  vec2 forward = xBasis / len;\\n  vec2 norm = vec2(forward.y, -forward.x);\\n\\n  float type = a_VertexJoint;\\n\\n  float lineWidth;\\n  if (u_IsPicking > 0.5) {\\n    lineWidth = u_IncreasedLineWidthForHitTesting + u_StrokeWidth;\\n  } else {\\n    lineWidth = u_StrokeWidth;\\n  }\\n\\n  if (u_ScaleMode > 2.5) {\\n    lineWidth *= length(u_ModelMatrix * vec4(1.0, 0.0, 0.0, 0.0));\\n  } else if (u_ScaleMode > 1.5) {\\n    lineWidth *= length(u_ModelMatrix * vec4(0.0, 1.0, 0.0, 0.0));\\n  } else if (u_ScaleMode > 0.5) {\\n    vec2 avgDiag = (u_ModelMatrix * vec4(1.0, 1.0, 0.0, 0.0)).xy;\\n    lineWidth *= sqrt(dot(avgDiag, avgDiag) * 0.5);\\n  }\\n  float capType = floor(type / 32.0);\\n  type -= capType * 32.0;\\n  v_Arc = vec4(0.0);\\n  lineWidth *= 0.5;\\n  float lineAlignment = 2.0 * u_Alignment - 1.0;\\n\\n  vec2 pos;\\n\\n  if (capType == CAP_ROUND) {\\n    if (a_VertexNum < 3.5) {\\n      gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    type = JOINT_CAP_ROUND;\\n    capType = 0.0;\\n  }\\n\\n  if (type >= BEVEL) {\\n    float dy = lineWidth + u_Expand;\\n    float inner = 0.0;\\n    if (a_VertexNum >= 1.5) {\\n      dy = -dy;\\n      inner = 1.0;\\n    }\\n\\n    vec2 base, next, xBasis2, bisect;\\n    float flag = 0.0;\\n    float sign2 = 1.0;\\n    if (a_VertexNum < 0.5 || a_VertexNum > 2.5 && a_VertexNum < 3.5) {\\n      if (isBillboard) {\\n        next = clip2ScreenSpace(billboard(a_Prev.xy, 0.0, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix));\\n      } else if (is3DPolyline) {\\n        next = clip2ScreenSpace(project(vec4(a_Prev, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix));\\n      } else {\\n        next = (u_ModelMatrix * vec4(a_Prev, 1.0)).xy;\\n      }\\n\\n      base = pointA;\\n      flag = type - floor(type / 2.0) * 2.0;\\n      sign2 = -1.0;\\n    } else {\\n      if (isBillboard) {\\n        next = clip2ScreenSpace(billboard(a_Next.xy, 0.0, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix));\\n      } else if (is3DPolyline) {\\n        next = clip2ScreenSpace(project(vec4(a_Next, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix));\\n      } else {\\n        next = (u_ModelMatrix * vec4(a_Next, 1.0)).xy;\\n      }\\n      \\n      base = pointB;\\n      if (type >= MITER && type < MITER + 3.5) {\\n        flag = step(MITER + 1.5, type);\\n        // check miter limit here?\\n      }\\n    }\\n    xBasis2 = next - base;\\n    float len2 = length(xBasis2);\\n    vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\\n    float D = norm.x * norm2.y - norm.y * norm2.x;\\n    if (D < 0.0) {\\n      inner = 1.0 - inner;\\n    }\\n    norm2 *= sign2;\\n\\n    if (abs(lineAlignment) > 0.01) {\\n      float shift = lineWidth * lineAlignment;\\n      pointA += norm * shift;\\n      pointB += norm * shift;\\n      if (abs(D) < 0.01) {\\n        base += norm * shift;\\n      } else {\\n        base += doBisect(norm, len, norm2, len2, shift, 0.0);\\n      }\\n    }\\n\\n    float collinear = step(0.0, dot(norm, norm2));\\n    v_Type = 0.0;\\n    float dy2 = -1000.0;\\n    float dy3 = -1000.0;\\n    if (abs(D) < 0.01 && collinear < 0.5) {\\n      if (type >= ROUND && type < ROUND + 1.5) {\\n        type = JOINT_CAP_ROUND;\\n      }\\n      // TODO: BUTT here too\\n    }\\n\\n    if (a_VertexNum < 3.5) {\\n      if (abs(D) < 0.01) {\\n        pos = dy * norm;\\n      } else {\\n        if (flag < 0.5 && inner < 0.5) {\\n          pos = dy * norm;\\n        } else {\\n          pos = doBisect(norm, len, norm2, len2, dy, inner);\\n        }\\n      }\\n      if (capType >= CAP_BUTT && capType < CAP_ROUND) {\\n        float extra = step(CAP_SQUARE, capType) * lineWidth;\\n        vec2 back = -forward;\\n        if (a_VertexNum < 0.5 || a_VertexNum > 2.5) {\\n          pos += back * (u_Expand + extra);\\n          dy2 = u_Expand;\\n        } else {\\n          dy2 = dot(pos + base - pointA, back) - extra;\\n        }\\n      }\\n      if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\\n        float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\\n        if (a_VertexNum < 0.5 || a_VertexNum > 2.5) {\\n          dy3 = dot(pos + base - pointB, forward) - extra;\\n        } else {\\n          pos += forward * (u_Expand + extra);\\n          dy3 = u_Expand;\\n          if (capType >= CAP_BUTT) {\\n            dy2 -= u_Expand + extra;\\n          }\\n        }\\n      }\\n    } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\\n      if (inner > 0.5) {\\n        dy = -dy;\\n        inner = 0.0;\\n      }\\n      vec2 d2 = abs(dy) * forward;\\n      if (a_VertexNum < 4.5) {\\n        dy = -dy;\\n        pos = dy * norm;\\n      } else if (a_VertexNum < 5.5) {\\n        pos = dy * norm;\\n      } else if (a_VertexNum < 6.5) {\\n        pos = dy * norm + d2;\\n        v_Arc.x = abs(dy);\\n      } else {\\n        dy = -dy;\\n        pos = dy * norm + d2;\\n        v_Arc.x = abs(dy);\\n      }\\n      dy2 = 0.0;\\n      v_Arc.y = dy;\\n      v_Arc.z = 0.0;\\n      v_Arc.w = lineWidth;\\n      v_Type = 3.0;\\n    } else if (abs(D) < 0.01) {\\n      pos = dy * norm;\\n    } else {\\n      if (type >= ROUND && type < ROUND + 1.5) {\\n        if (inner > 0.5) {\\n          dy = -dy;\\n          inner = 0.0;\\n        }\\n        if (a_VertexNum < 4.5) {\\n          pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\\n        } else if (a_VertexNum < 5.5) {\\n          pos = dy * norm;\\n        } else if (a_VertexNum > 7.5) {\\n          pos = dy * norm2;\\n        } else {\\n          pos = doBisect(norm, len, norm2, len2, dy, 0.0);\\n          float d2 = abs(dy);\\n          if (length(pos) > abs(dy) * 1.5) {\\n            if (a_VertexNum < 6.5) {\\n              pos.x = dy * norm.x - d2 * norm.y;\\n              pos.y = dy * norm.y + d2 * norm.x;\\n            } else {\\n              pos.x = dy * norm2.x + d2 * norm2.y;\\n              pos.y = dy * norm2.y - d2 * norm2.x;\\n            }\\n          }\\n        }\\n        vec2 norm3 = normalize(norm + norm2);\\n        float sign = step(0.0, dy) * 2.0 - 1.0;\\n        v_Arc.x = sign * dot(pos, norm3);\\n        v_Arc.y = pos.x * norm3.y - pos.y * norm3.x;\\n        v_Arc.z = dot(norm, norm3) * lineWidth;\\n        v_Arc.w = lineWidth;\\n        dy = -sign * dot(pos, norm);\\n        dy2 = -sign * dot(pos, norm2);\\n        dy3 = v_Arc.z - v_Arc.x;\\n        v_Type = 3.0;\\n      } else {\\n        float hit = 0.0;\\n        if (type >= BEVEL && type < BEVEL + 1.5) {\\n          if (dot(norm, norm2) > 0.0) {\\n            type = MITER;\\n          }\\n        }\\n        if (type >= MITER && type < MITER + 3.5) {\\n          if (inner > 0.5) {\\n            dy = -dy;\\n            inner = 0.0;\\n          }\\n          float sign = step(0.0, dy) * 2.0 - 1.0;\\n          pos = doBisect(norm, len, norm2, len2, dy, 0.0);\\n          if (length(pos) > abs(dy) * u_MiterLimit) {\\n            type = BEVEL;\\n          } else {\\n            if (a_VertexNum < 4.5) {\\n              dy = -dy;\\n              pos = doBisect(norm, len, norm2, len2, dy, 1.0);\\n            } else if (a_VertexNum < 5.5) {\\n              pos = dy * norm;\\n            } else if (a_VertexNum > 6.5) {\\n              pos = dy * norm2;\\n            }\\n            v_Type = 1.0;\\n            dy = -sign * dot(pos, norm);\\n            dy2 = -sign * dot(pos, norm2);\\n            hit = 1.0;\\n          }\\n        }\\n        if (type >= BEVEL && type < BEVEL + 1.5) {\\n          if (inner > 0.5) {\\n            dy = -dy;\\n            inner = 0.0;\\n          }\\n          float d2 = abs(dy);\\n          vec2 pos3 = vec2(dy * norm.x - d2 * norm.y, dy * norm.y + d2 * norm.x);\\n          vec2 pos4 = vec2(dy * norm2.x + d2 * norm2.y, dy * norm2.y - d2 * norm2.x);\\n          if (a_VertexNum < 4.5) {\\n            pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\\n          } else if (a_VertexNum < 5.5) {\\n            pos = dy * norm;\\n          } else if (a_VertexNum > 7.5) {\\n            pos = dy * norm2;\\n          } else {\\n            if (a_VertexNum < 6.5) {\\n              pos = pos3;\\n            } else {\\n              pos = pos4;\\n            }\\n          }\\n          vec2 norm3 = normalize(norm + norm2);\\n          float sign = step(0.0, dy) * 2.0 - 1.0;\\n          dy = -sign * dot(pos, norm);\\n          dy2 = -sign * dot(pos, norm2);\\n          dy3 = (-sign * dot(pos, norm3)) + lineWidth;\\n          v_Type = 4.0;\\n          hit = 1.0;\\n        }\\n        if (hit < 0.5) {\\n          gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n          return;\\n        }\\n      }\\n    }\\n    pos += base;\\n    v_Distance = vec4(dy, dy2, dy3, lineWidth) * u_DevicePixelRatio;\\n    v_Arc = v_Arc * u_DevicePixelRatio;\\n    v_Travel = a_Travel + dot(pos - pointA, vec2(-norm.y, norm.x));\\n  }\\n\\n  v_ScalingFactor = sqrt(u_ModelMatrix[0][0] * u_ModelMatrix[0][0] + u_ModelMatrix[0][1] * u_ModelMatrix[0][1] + u_ModelMatrix[0][2] * u_ModelMatrix[0][2]);\\n\\n  if (isBillboard || is3DPolyline) {\\n    vec4 clip = mix(clip0, clip1, 0.5);\\n    gl_Position = vec4(clip.w * (2.0 * pos / u_Viewport - 1.0), clip.z, clip.w);\\n  } else {\\n    gl_Position = u_ProjectionMatrix * u_ViewMatrix * vec4(pos, u_ZIndex, 1.0);\\n  }\\n}\"; // eslint-disable-line\n\nvar SEGMENT_LENGTH = 10;\nvar MIN_SEGMENT_NUM = 8;\nvar MAX_SEGMENT_NUM = 100;\nfunction quadCurveTo(cpX, cpY, toX, toY, points, segmentNum) {\n    var fromX = points[points.length - 3];\n    var fromY = points[points.length - 2];\n    var n = segmentNum !== null && segmentNum !== void 0 ? segmentNum : util.clamp(gMath.quadLength(fromX, fromY, cpX, cpY, toX, toY) / SEGMENT_LENGTH, MIN_SEGMENT_NUM, MAX_SEGMENT_NUM);\n    var xa = 0;\n    var ya = 0;\n    for (var i = 1; i <= n; ++i) {\n        var j = i / n;\n        xa = fromX + (cpX - fromX) * j;\n        ya = fromY + (cpY - fromY) * j;\n        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j, 0);\n    }\n}\nfunction bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY, points, segmentNum) {\n    var fromX = points[points.length - 3];\n    var fromY = points[points.length - 2];\n    points.length -= 3;\n    var n = segmentNum !== null && segmentNum !== void 0 ? segmentNum : util.clamp(gMath.cubicLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) /\n        SEGMENT_LENGTH, MIN_SEGMENT_NUM, MAX_SEGMENT_NUM);\n    var dt = 0;\n    var dt2 = 0;\n    var dt3 = 0;\n    var t2 = 0;\n    var t3 = 0;\n    points.push(fromX, fromY, 0);\n    for (var i = 1, j = 0; i <= n; ++i) {\n        j = i / n;\n        dt = 1 - j;\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n        t2 = j * j;\n        t3 = t2 * j;\n        points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY, 0);\n    }\n}\n\n/**\n * Borrow from https://github.com/mapbox/tiny-sdf\n */\nvar INF = 1e20;\nvar TinySDF = /** @class */ (function () {\n    function TinySDF(options, runtime) {\n        var _a = options.fontSize, fontSize = _a === void 0 ? 24 : _a, _b = options.buffer, buffer = _b === void 0 ? 3 : _b, _c = options.radius, radius = _c === void 0 ? 8 : _c, _d = options.cutoff, cutoff = _d === void 0 ? 0.25 : _d, _e = options.fontFamily, fontFamily = _e === void 0 ? 'sans-serif' : _e, _f = options.fontWeight, fontWeight = _f === void 0 ? 'normal' : _f, _g = options.fontStyle, fontStyle = _g === void 0 ? 'normal' : _g, canvas = options.canvas;\n        this.buffer = buffer;\n        this.cutoff = cutoff;\n        this.radius = radius;\n        // make the canvas size big enough to both have the specified buffer around the glyph\n        // for \"halo\", and account for some glyphs possibly being larger than their font size\n        var size = (this.size = fontSize + buffer * 4);\n        var $offscreenCanvas = runtime.offscreenCanvasCreator.getOrCreateCanvas(canvas);\n        // canvas.width = canvas.height = size;\n        // $offscreenCanvas.width = width * dpr;\n        // $offscreenCanvas.height = height * dpr;\n        $offscreenCanvas.width = size;\n        $offscreenCanvas.height = size;\n        var ctx = runtime.offscreenCanvasCreator.getOrCreateContext(canvas, {\n            willReadFrequently: true,\n        });\n        this.ctx = ctx;\n        // const ctx = (this.ctx = canvas.getContext('2d', {\n        //   willReadFrequently: true,\n        // }));\n        ctx.font = \"\".concat(fontStyle, \" \").concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n        ctx.textBaseline = 'alphabetic';\n        ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n        ctx.fillStyle = 'black';\n        // temporary arrays for the distance transform\n        this.gridOuter = new Float64Array(size * size);\n        this.gridInner = new Float64Array(size * size);\n        this.f = new Float64Array(size);\n        this.z = new Float64Array(size + 1);\n        this.v = new Uint16Array(size);\n    }\n    // _createCanvas(size) {\n    //   const canvas = document.createElement('canvas');\n    //   canvas.width = canvas.height = size;\n    //   return canvas;\n    // }\n    TinySDF.prototype.draw = function (char) {\n        var _a = this.ctx.measureText(char), glyphAdvance = _a.width, actualBoundingBoxAscent = _a.actualBoundingBoxAscent, actualBoundingBoxDescent = _a.actualBoundingBoxDescent, actualBoundingBoxLeft = _a.actualBoundingBoxLeft, actualBoundingBoxRight = _a.actualBoundingBoxRight;\n        // The integer/pixel part of the top alignment is encoded in metrics.glyphTop\n        // The remainder is implicitly encoded in the rasterization\n        var glyphTop = Math.ceil(actualBoundingBoxAscent);\n        var glyphLeft = 0;\n        // If the glyph overflows the canvas size, it will be clipped at the bottom/right\n        var glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));\n        var glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));\n        var width = glyphWidth + 2 * this.buffer;\n        var height = glyphHeight + 2 * this.buffer;\n        var len = Math.max(width * height, 0);\n        var data = new Uint8ClampedArray(len);\n        var glyph = {\n            data: data,\n            width: width,\n            height: height,\n            glyphWidth: glyphWidth,\n            glyphHeight: glyphHeight,\n            glyphTop: glyphTop,\n            glyphLeft: glyphLeft,\n            glyphAdvance: glyphAdvance,\n        };\n        if (glyphWidth === 0 || glyphHeight === 0)\n            return glyph;\n        var _b = this, ctx = _b.ctx, buffer = _b.buffer, gridInner = _b.gridInner, gridOuter = _b.gridOuter;\n        ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);\n        ctx.fillText(char, buffer, buffer + glyphTop);\n        var imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);\n        // Initialize grids outside the glyph range to alpha 0\n        gridOuter.fill(INF, 0, len);\n        gridInner.fill(0, 0, len);\n        for (var y = 0; y < glyphHeight; y++) {\n            for (var x = 0; x < glyphWidth; x++) {\n                var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n                if (a === 0)\n                    continue; // empty pixels\n                var j = (y + buffer) * width + x + buffer;\n                if (a === 1) {\n                    // fully drawn pixels\n                    gridOuter[j] = 0;\n                    gridInner[j] = INF;\n                }\n                else {\n                    // aliased pixels\n                    var d = 0.5 - a;\n                    gridOuter[j] = d > 0 ? d * d : 0;\n                    gridInner[j] = d < 0 ? d * d : 0;\n                }\n            }\n        }\n        edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);\n        edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);\n        for (var i = 0; i < len; i++) {\n            var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n            data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));\n        }\n        return glyph;\n    };\n    return TinySDF;\n}());\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, x0, y0, width, height, gridSize, f, v, z) {\n    for (var x = x0; x < x0 + width; x++)\n        edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);\n    for (var y = y0; y < y0 + height; y++)\n        edt1d(data, y * gridSize + x0, 1, width, f, v, z);\n}\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n    f[0] = grid[offset];\n    for (var q = 1, k = 0, s = 0; q < length; q++) {\n        f[q] = grid[offset + q * stride];\n        var q2 = q * q;\n        do {\n            var r = v[k];\n            s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;\n        } while (s <= z[k] && --k > -1);\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n    for (var q = 0, k = 0; q < length; q++) {\n        while (z[k + 1] < q)\n            k++;\n        var r = v[k];\n        var qr = q - r;\n        grid[offset + q * stride] = f[r] + qr * qr;\n    }\n}\n\nvar LineVertexAttributeBufferIndex;\n(function (LineVertexAttributeBufferIndex) {\n    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex[\"PACKED\"] = 5] = \"PACKED\";\n    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex[\"VERTEX_NUM\"] = 6] = \"VERTEX_NUM\";\n    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex[\"TRAVEL\"] = 7] = \"TRAVEL\";\n    LineVertexAttributeBufferIndex[LineVertexAttributeBufferIndex[\"DASH\"] = 8] = \"DASH\";\n})(LineVertexAttributeBufferIndex || (LineVertexAttributeBufferIndex = {}));\nvar LineVertexAttributeLocation;\n(function (LineVertexAttributeLocation) {\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"PREV\"] = 8] = \"PREV\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"POINT1\"] = 9] = \"POINT1\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"POINT2\"] = 10] = \"POINT2\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"NEXT\"] = 11] = \"NEXT\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"VERTEX_JOINT\"] = 12] = \"VERTEX_JOINT\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"VERTEX_NUM\"] = 13] = \"VERTEX_NUM\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"TRAVEL\"] = 14] = \"TRAVEL\";\n    LineVertexAttributeLocation[LineVertexAttributeLocation[\"DASH\"] = 15] = \"DASH\";\n})(LineVertexAttributeLocation || (LineVertexAttributeLocation = {}));\nvar SEGMENT_NUM$1 = 12;\nfunction packBoolean(a, b, c) {\n    return (a ? 1 : 0) * 4 + (b ? 1 : 0) * 2 + (c ? 1 : 0);\n}\nfunction is3DPolyline(object) {\n    var isPolyline = object.nodeName === gLite.Shape.POLYLINE;\n    if (!isPolyline) {\n        return false;\n    }\n    // Polyline supports 3 dimensions so that each point is shaped like [x, y, z].\n    var polylineControlPoints = object.parsedStyle.points.points;\n    var length = polylineControlPoints.length;\n    return length && !util.isNil(polylineControlPoints[0][2]);\n}\n/**\n * Used for Curve only contains 2 commands, e.g. [[M], [C | Q | A]]\n */\nvar InstancedPathDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(InstancedPathDrawcall, _super);\n    function InstancedPathDrawcall(renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) {\n        var _this = _super.call(this, renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) || this;\n        _this.renderHelper = renderHelper;\n        _this.texturePool = texturePool;\n        _this.lightPool = lightPool;\n        _this.mergeAnchorIntoModelMatrix = true;\n        _this.segmentNum = -1;\n        _this.segmentNum = _this.calcSegmentNum(object);\n        _this.gradientAttributeName = 'stroke';\n        return _this;\n    }\n    InstancedPathDrawcall.calcSubpathNum = function (object) {\n        if (object.nodeName === gLite.Shape.PATH) {\n            var absolutePath = object.parsedStyle.path.absolutePath;\n            return absolutePath.filter(function (d) { return d[0] === 'M'; }).length;\n        }\n        return 1;\n    };\n    InstancedPathDrawcall.prototype.calcSegmentNum = function (object) {\n        // FIXME: only need to collect instanced count\n        var instancedCount = updateBuffer(object, false, SEGMENT_NUM$1, this.calcSubpathIndex(object)).instancedCount;\n        return instancedCount;\n    };\n    InstancedPathDrawcall.prototype.calcSubpathIndex = function (object) {\n        if (object.nodeName === gLite.Shape.PATH) {\n            var fillDrawcallCount = this.drawcallCtors.filter(function (ctor) { return ctor === InstancedFillDrawcall; }).length;\n            return this.index - fillDrawcallCount;\n        }\n        return 0;\n    };\n    /**\n     * Paths with the same number of vertices should be merged.\n     */\n    InstancedPathDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        if (this.index !== index) {\n            return false;\n        }\n        var segmentNum = this.calcSegmentNum(object);\n        return this.segmentNum === segmentNum;\n    };\n    InstancedPathDrawcall.prototype.createMaterial = function (objects) {\n        this.material.vertexShader = vert$2;\n        this.material.fragmentShader = frag$2;\n        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(LineVertexAttributeLocation));\n    };\n    InstancedPathDrawcall.prototype.createGeometry = function (objects) {\n        var _this = this;\n        var indices = [];\n        var pointsBuffer = [];\n        var travelBuffer = [];\n        var packedDash = [];\n        var instancedCount = 0;\n        var offset = 0;\n        objects.forEach(function (object) {\n            var _a = updateBuffer(object, false, SEGMENT_NUM$1, _this.calcSubpathIndex(object)), pBuffer = _a.pointsBuffer, tBuffer = _a.travelBuffer, count = _a.instancedCount;\n            var _b = object.parsedStyle, lineDash = _b.lineDash, lineDashOffset = _b.lineDashOffset, isBillboard = _b.isBillboard, isSizeAttenuation = _b.isSizeAttenuation;\n            packedDash.push((lineDash && lineDash[0]) || 0, // DASH\n            (lineDash && lineDash[1]) || 0, // GAP\n            lineDashOffset || 0, packBoolean(isBillboard, isSizeAttenuation, is3DPolyline(object)));\n            instancedCount += count;\n            // Can't use interleaved buffer here, we should spread them like:\n            // | prev - pointA - pointB - next |. This will allocate ~4x buffer memory space.\n            for (var i = 0; i < pBuffer.length - 3 * 4; i += 4) {\n                pointsBuffer.push(pBuffer[i], pBuffer[i + 1], pBuffer[i + 2], pBuffer[i + 3], pBuffer[i + 4], pBuffer[i + 5], pBuffer[i + 6], pBuffer[i + 7], pBuffer[i + 8], pBuffer[i + 9], pBuffer[i + 10], pBuffer[i + 11], pBuffer[i + 12], pBuffer[i + 13], pBuffer[i + 14], pBuffer[i + 15]);\n            }\n            travelBuffer.push.apply(travelBuffer, tslib.__spreadArray([], tslib.__read(tBuffer), false));\n            indices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset, 4 + offset, 6 + offset, 5 + offset, 4 + offset, 7 + offset, 6 + offset, 4 + offset, 7 + offset, 8 + offset);\n            offset += 9;\n        });\n        if (pointsBuffer.length) {\n            this.geometry.setVertexBuffer({\n                bufferIndex: LineVertexAttributeBufferIndex.PACKED,\n                byteStride: 4 * (4 + 4 + 4 + 4),\n                stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_RGB,\n                        bufferByteOffset: 4 * 0,\n                        location: LineVertexAttributeLocation.PREV,\n                        divisor: 1,\n                    },\n                    {\n                        format: gDeviceApi.Format.F32_RGB,\n                        bufferByteOffset: 4 * 4,\n                        location: LineVertexAttributeLocation.POINT1,\n                        divisor: 1,\n                    },\n                    {\n                        format: gDeviceApi.Format.F32_R,\n                        bufferByteOffset: 4 * 7,\n                        location: LineVertexAttributeLocation.VERTEX_JOINT,\n                        divisor: 1,\n                    },\n                    {\n                        format: gDeviceApi.Format.F32_RGB,\n                        bufferByteOffset: 4 * 8,\n                        location: LineVertexAttributeLocation.POINT2,\n                        divisor: 1,\n                    },\n                    {\n                        format: gDeviceApi.Format.F32_RGB,\n                        bufferByteOffset: 4 * 12,\n                        location: LineVertexAttributeLocation.NEXT,\n                        divisor: 1,\n                    },\n                ],\n                data: new Float32Array(pointsBuffer),\n            });\n            this.geometry.setVertexBuffer({\n                bufferIndex: LineVertexAttributeBufferIndex.VERTEX_NUM,\n                byteStride: 4 * 1,\n                stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_R,\n                        bufferByteOffset: 4 * 0,\n                        byteStride: 4 * 1,\n                        location: LineVertexAttributeLocation.VERTEX_NUM,\n                        divisor: 0,\n                    },\n                ],\n                data: new Float32Array([0, 1, 2, 3, 4, 5, 6, 7, 8]),\n            });\n            this.geometry.setVertexBuffer({\n                bufferIndex: LineVertexAttributeBufferIndex.TRAVEL,\n                byteStride: 4 * 1,\n                stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_R,\n                        bufferByteOffset: 4 * 0,\n                        byteStride: 4 * 1,\n                        location: LineVertexAttributeLocation.TRAVEL,\n                        divisor: 1,\n                    },\n                ],\n                data: new Float32Array(travelBuffer),\n            });\n            // this attribute only changes for each n instance\n            this.divisor = instancedCount / objects.length;\n            this.geometry.setVertexBuffer({\n                bufferIndex: LineVertexAttributeBufferIndex.DASH,\n                byteStride: 4 * 4,\n                stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_RGBA,\n                        bufferByteOffset: 4 * 0,\n                        location: LineVertexAttributeLocation.DASH,\n                        divisor: this.divisor,\n                    },\n                ],\n                data: new Float32Array(packedDash),\n            });\n            // use default common attributes\n            _super.prototype.createGeometry.call(this, objects);\n            this.geometry.vertexCount = 15;\n            this.geometry.instancedCount = instancedCount;\n            this.geometry.setIndexBuffer(new Uint32Array(indices));\n        }\n    };\n    InstancedPathDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        var _this = this;\n        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);\n        this.updateBatchedAttribute(objects, startIndex, name, value);\n        if (name === 'r' ||\n            name === 'rx' ||\n            name === 'ry' ||\n            name === 'width' ||\n            name === 'height' ||\n            name === 'radius' ||\n            name === 'x1' ||\n            name === 'y1' ||\n            name === 'x2' ||\n            name === 'y2' ||\n            name === 'points' ||\n            name === 'path' ||\n            name === 'lineJoin' ||\n            name === 'lineCap' ||\n            name === 'markerStartOffset' ||\n            name === 'markerEndOffset' ||\n            name === 'markerStart' ||\n            name === 'markerEnd') {\n            var pointsBuffer_1 = [];\n            var travelBuffer_1 = [];\n            var instancedCount_1 = 0;\n            objects.forEach(function (object) {\n                var _a = updateBuffer(object, false, SEGMENT_NUM$1, _this.calcSubpathIndex(object)), pBuffer = _a.pointsBuffer, tBuffer = _a.travelBuffer, iCount = _a.instancedCount;\n                instancedCount_1 = iCount;\n                // Can't use interleaved buffer here, we should spread them like:\n                // | prev - pointA - pointB - next |. This will allocate ~4x buffer memory space.\n                for (var i = 0; i < pBuffer.length - 3 * 4; i += 4) {\n                    pointsBuffer_1.push(pBuffer[i], pBuffer[i + 1], pBuffer[i + 2], pBuffer[i + 3], pBuffer[i + 4], pBuffer[i + 5], pBuffer[i + 6], pBuffer[i + 7], pBuffer[i + 8], pBuffer[i + 9], pBuffer[i + 10], pBuffer[i + 11], pBuffer[i + 12], pBuffer[i + 13], pBuffer[i + 14], pBuffer[i + 15]);\n                }\n                travelBuffer_1.push.apply(travelBuffer_1, tslib.__spreadArray([], tslib.__read(tBuffer), false));\n            });\n            this.geometry.updateVertexBuffer(LineVertexAttributeBufferIndex.PACKED, LineVertexAttributeLocation.PREV, startIndex * instancedCount_1, new Uint8Array(new Float32Array(pointsBuffer_1).buffer));\n            this.geometry.updateVertexBuffer(LineVertexAttributeBufferIndex.TRAVEL, LineVertexAttributeLocation.TRAVEL, startIndex, new Uint8Array(new Float32Array(travelBuffer_1).buffer));\n        }\n        else if (name === 'lineDashOffset' ||\n            name === 'lineDash' ||\n            name === 'isBillboard' ||\n            name === 'isSizeAttenuation') {\n            var packedDash_1 = [];\n            objects.forEach(function (object) {\n                var _a = object.parsedStyle, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset, isBillboard = _a.isBillboard, isSizeAttenuation = _a.isSizeAttenuation;\n                packedDash_1.push((lineDash && lineDash[0]) || 0, // DASH\n                (lineDash && lineDash[1]) || 0, // GAP\n                lineDashOffset || 0, packBoolean(isBillboard, isSizeAttenuation, is3DPolyline(object)));\n            });\n            this.geometry.updateVertexBuffer(LineVertexAttributeBufferIndex.DASH, LineVertexAttributeLocation.DASH, startIndex, new Uint8Array(new Float32Array(packedDash_1).buffer));\n        }\n    };\n    return InstancedPathDrawcall;\n}(Instanced));\nexports.JOINT_TYPE = void 0;\n(function (JOINT_TYPE) {\n    JOINT_TYPE[JOINT_TYPE[\"NONE\"] = 0] = \"NONE\";\n    JOINT_TYPE[JOINT_TYPE[\"FILL\"] = 1] = \"FILL\";\n    JOINT_TYPE[JOINT_TYPE[\"JOINT_BEVEL\"] = 4] = \"JOINT_BEVEL\";\n    JOINT_TYPE[JOINT_TYPE[\"JOINT_MITER\"] = 8] = \"JOINT_MITER\";\n    JOINT_TYPE[JOINT_TYPE[\"JOINT_ROUND\"] = 12] = \"JOINT_ROUND\";\n    JOINT_TYPE[JOINT_TYPE[\"JOINT_CAP_BUTT\"] = 16] = \"JOINT_CAP_BUTT\";\n    JOINT_TYPE[JOINT_TYPE[\"JOINT_CAP_SQUARE\"] = 18] = \"JOINT_CAP_SQUARE\";\n    JOINT_TYPE[JOINT_TYPE[\"JOINT_CAP_ROUND\"] = 20] = \"JOINT_CAP_ROUND\";\n    JOINT_TYPE[JOINT_TYPE[\"FILL_EXPAND\"] = 24] = \"FILL_EXPAND\";\n    JOINT_TYPE[JOINT_TYPE[\"CAP_BUTT\"] = 32] = \"CAP_BUTT\";\n    JOINT_TYPE[JOINT_TYPE[\"CAP_SQUARE\"] = 64] = \"CAP_SQUARE\";\n    JOINT_TYPE[JOINT_TYPE[\"CAP_ROUND\"] = 96] = \"CAP_ROUND\";\n    JOINT_TYPE[JOINT_TYPE[\"CAP_BUTT2\"] = 128] = \"CAP_BUTT2\";\n})(exports.JOINT_TYPE || (exports.JOINT_TYPE = {}));\nvar stridePoints = 3;\nvar strideFloats = 4;\nfunction updateBuffer(object, needEarcut, segmentNum, subPathIndex) {\n    var _a;\n    if (needEarcut === void 0) { needEarcut = false; }\n    if (subPathIndex === void 0) { subPathIndex = 0; }\n    var _b = object.parsedStyle, lineCap = _b.lineCap, lineJoin = _b.lineJoin;\n    var zIndex = object.sortable.renderOrder * RENDER_ORDER_SCALE;\n    var _c = object.parsedStyle, defX = _c.defX, defY = _c.defY;\n    var _d = object.parsedStyle, markerStart = _d.markerStart, markerEnd = _d.markerEnd, markerStartOffset = _d.markerStartOffset, markerEndOffset = _d.markerEndOffset;\n    var points = [];\n    var triangles = [];\n    if (object.nodeName === gLite.Shape.POLYLINE || object.nodeName === gLite.Shape.POLYGON) {\n        var polylineControlPoints = object.parsedStyle.points\n            .points;\n        var length_1 = polylineControlPoints.length;\n        var startOffsetX_1 = 0;\n        var startOffsetY_1 = 0;\n        var endOffsetX_1 = 0;\n        var endOffsetY_1 = 0;\n        var rad = 0;\n        var x = void 0;\n        var y = void 0;\n        if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n            x = polylineControlPoints[1][0] - polylineControlPoints[0][0];\n            y = polylineControlPoints[1][1] - polylineControlPoints[0][1];\n            rad = Math.atan2(y, x);\n            startOffsetX_1 = Math.cos(rad) * (markerStartOffset || 0);\n            startOffsetY_1 = Math.sin(rad) * (markerStartOffset || 0);\n        }\n        if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n            x =\n                polylineControlPoints[length_1 - 2][0] -\n                    polylineControlPoints[length_1 - 1][0];\n            y =\n                polylineControlPoints[length_1 - 2][1] -\n                    polylineControlPoints[length_1 - 1][1];\n            rad = Math.atan2(y, x);\n            endOffsetX_1 = Math.cos(rad) * (markerEndOffset || 0);\n            endOffsetY_1 = Math.sin(rad) * (markerEndOffset || 0);\n        }\n        var isPolyline_1 = object.nodeName === gLite.Shape.POLYLINE;\n        points[0] = polylineControlPoints.reduce(function (prev, cur, i) {\n            var offsetX = 0;\n            var offsetY = 0;\n            if (i === 0) {\n                offsetX = startOffsetX_1;\n                offsetY = startOffsetY_1;\n            }\n            else if (i === length_1 - 1) {\n                offsetX = endOffsetX_1;\n                offsetY = endOffsetY_1;\n            }\n            prev.push(cur[0] - defX + offsetX, cur[1] - defY + offsetY, isPolyline_1 ? cur[2] || 0 : zIndex);\n            return prev;\n        }, []);\n        // close polygon, dealing with extra joint\n        if (object.nodeName === gLite.Shape.POLYGON) {\n            if (needEarcut) {\n                // use earcut for triangulation\n                triangles = earcut(points[0], [], 3);\n                return {\n                    pointsBuffer: points[0],\n                    travelBuffer: [],\n                    triangles: triangles,\n                    instancedCount: Math.round(points[0].length / stridePoints),\n                };\n            }\n            else {\n                points[0].push(points[0][0], points[0][1], points[0][2] || zIndex);\n                (_a = points[0]).push.apply(_a, tslib.__spreadArray([], tslib.__read(addTailSegment(points[0][0], points[0][1], points[0][2] || zIndex, points[0][3], points[0][4], points[0][5] || zIndex)), false));\n            }\n        }\n    }\n    else if (object.nodeName === gLite.Shape.PATH ||\n        object.nodeName === gLite.Shape.CIRCLE ||\n        object.nodeName === gLite.Shape.ELLIPSE ||\n        object.nodeName === gLite.Shape.RECT) {\n        var path = void 0;\n        if (object.nodeName !== gLite.Shape.PATH) {\n            path = gLite.parsePath(gLite.convertToPath(object, glMatrix.mat4.identity(glMatrix.mat4.create())));\n            defX = path.rect.x;\n            defY = path.rect.y;\n            // support negative width/height of Rect\n            if (object.nodeName === gLite.Shape.RECT) {\n                var _e = object.parsedStyle, width = _e.width, height = _e.height;\n                if (width < 0) {\n                    defX += path.rect.width;\n                }\n                if (height < 0) {\n                    defY += path.rect.height;\n                }\n            }\n        }\n        else {\n            path = object.parsedStyle.path;\n        }\n        var absolutePath_1 = path.absolutePath, segments_1 = path.segments;\n        var startOffsetX_2 = 0;\n        var startOffsetY_2 = 0;\n        var endOffsetX_2 = 0;\n        var endOffsetY_2 = 0;\n        var rad = 0;\n        var x = void 0;\n        var y = void 0;\n        if (markerStart &&\n            markerStart.parentNode &&\n            gLite.isDisplayObject(markerStart) &&\n            markerStartOffset) {\n            var _f = tslib.__read(markerStart.parentNode.getStartTangent(), 2), p1 = _f[0], p2 = _f[1];\n            x = p1[0] - p2[0];\n            y = p1[1] - p2[1];\n            rad = Math.atan2(y, x);\n            startOffsetX_2 = Math.cos(rad) * (markerStartOffset || 0);\n            startOffsetY_2 = Math.sin(rad) * (markerStartOffset || 0);\n        }\n        if (markerEnd &&\n            markerEnd.parentNode &&\n            gLite.isDisplayObject(markerEnd) &&\n            markerEndOffset) {\n            var _g = tslib.__read(markerEnd.parentNode.getEndTangent(), 2), p1 = _g[0], p2 = _g[1];\n            x = p1[0] - p2[0];\n            y = p1[1] - p2[1];\n            rad = Math.atan2(y, x);\n            endOffsetX_2 = Math.cos(rad) * (markerEndOffset || 0);\n            endOffsetY_2 = Math.sin(rad) * (markerEndOffset || 0);\n        }\n        var startPointIndex_1 = -1;\n        var mCommandsNum_1 = -1;\n        absolutePath_1.forEach(function (_a, i) {\n            var _b;\n            var _c = tslib.__read(_a), command = _c[0], params = _c.slice(1);\n            var nextSegment = absolutePath_1[i + 1];\n            var useStartOffset = i === 0 && (startOffsetX_2 !== 0 || startOffsetY_2 !== 0);\n            var useEndOffset = (i === absolutePath_1.length - 1 ||\n                (nextSegment &&\n                    (nextSegment[0] === 'M' || nextSegment[0] === 'Z'))) &&\n                endOffsetX_2 !== 0 &&\n                endOffsetY_2 !== 0;\n            if (command === 'M') {\n                mCommandsNum_1++;\n                points[mCommandsNum_1] = [];\n                startPointIndex_1 = points[mCommandsNum_1].length;\n                if (useStartOffset) {\n                    points[mCommandsNum_1].push(params[0] - defX + startOffsetX_2, params[1] - defY + startOffsetY_2, zIndex, params[0] - defX, params[1] - defY, zIndex);\n                }\n                else {\n                    points[mCommandsNum_1].push(params[0] - defX, params[1] - defY, zIndex);\n                }\n            }\n            else if (command === 'L') {\n                if (useEndOffset) {\n                    points[mCommandsNum_1].push(params[0] - defX + endOffsetX_2, params[1] - defY + endOffsetY_2, zIndex);\n                }\n                else {\n                    points[mCommandsNum_1].push(params[0] - defX, params[1] - defY, zIndex);\n                }\n            }\n            else if (command === 'Q') {\n                quadCurveTo(params[0] - defX, params[1] - defY, params[2] - defX, params[3] - defY, points[mCommandsNum_1], segmentNum);\n                if (useEndOffset) {\n                    points[mCommandsNum_1].push(params[2] - defX + endOffsetX_2, params[3] - defY + endOffsetY_2, zIndex);\n                }\n            }\n            else if (command === 'A') {\n                // convert Arc to Cubic\n                var _d = tslib.__read(segments_1[i].prePoint, 2), px1 = _d[0], py1 = _d[1];\n                var args = util.arcToCubic(px1, py1, params[0], params[1], params[2], params[3], params[4], params[5], params[6], undefined);\n                // fixArc\n                for (var i_1 = 0; i_1 < args.length; i_1 += 6) {\n                    bezierCurveTo(args[i_1] - defX, args[i_1 + 1] - defY, args[i_1 + 2] - defX, args[i_1 + 3] - defY, args[i_1 + 4] - defX, args[i_1 + 5] - defY, points[mCommandsNum_1], segmentNum);\n                }\n                if (useEndOffset) {\n                    points[mCommandsNum_1].push(params[5] - defX + endOffsetX_2, params[6] - defY + endOffsetY_2, zIndex);\n                }\n            }\n            else if (command === 'C') {\n                bezierCurveTo(params[0] - defX, params[1] - defY, params[2] - defX, params[3] - defY, params[4] - defX, params[5] - defY, points[mCommandsNum_1], segmentNum);\n                if (useEndOffset) {\n                    points[mCommandsNum_1].push(params[4] - defX + endOffsetX_2, params[5] - defY + endOffsetY_2, zIndex);\n                }\n            }\n            else if (command === 'Z' &&\n                (object.nodeName === gLite.Shape.PATH || object.nodeName === gLite.Shape.RECT)) {\n                var epsilon = 0.0001;\n                // skip if already closed\n                if (Math.abs(points[mCommandsNum_1][points[mCommandsNum_1].length - 2] -\n                    points[mCommandsNum_1][startPointIndex_1]) > epsilon ||\n                    Math.abs(points[mCommandsNum_1][points[mCommandsNum_1].length - 1] -\n                        points[mCommandsNum_1][startPointIndex_1 + 1]) > epsilon) {\n                    points[mCommandsNum_1].push(points[mCommandsNum_1][startPointIndex_1], points[mCommandsNum_1][startPointIndex_1 + 1], zIndex);\n                }\n                (_b = points[mCommandsNum_1]).push.apply(_b, tslib.__spreadArray([], tslib.__read(addTailSegment(points[mCommandsNum_1][startPointIndex_1], points[mCommandsNum_1][startPointIndex_1 + 1], points[mCommandsNum_1][startPointIndex_1 + 2], points[mCommandsNum_1][startPointIndex_1 + 3], points[mCommandsNum_1][startPointIndex_1 + 4], points[mCommandsNum_1][startPointIndex_1 + 5])), false));\n            }\n        });\n        if (needEarcut) {\n            var pointsBuffer = points[subPathIndex];\n            // use earcut for triangulation\n            triangles = earcut(pointsBuffer, [], 3);\n            return {\n                pointsBuffer: pointsBuffer,\n                travelBuffer: [],\n                triangles: triangles,\n                instancedCount: Math.round(pointsBuffer.length / stridePoints),\n            };\n        }\n    }\n    var jointType = getJointType(lineJoin);\n    var capType = getCapType(lineCap);\n    var endJoint = capType;\n    if (capType === exports.JOINT_TYPE.CAP_ROUND) {\n        endJoint = exports.JOINT_TYPE.JOINT_CAP_ROUND;\n    }\n    if (capType === exports.JOINT_TYPE.CAP_BUTT) {\n        endJoint = exports.JOINT_TYPE.JOINT_CAP_BUTT;\n    }\n    if (capType === exports.JOINT_TYPE.CAP_SQUARE) {\n        endJoint = exports.JOINT_TYPE.JOINT_CAP_SQUARE;\n    }\n    var subPath = points[subPathIndex];\n    {\n        var points_1 = subPath;\n        var j = (Math.round(0 / stridePoints) + 2) * strideFloats;\n        // const needDash = !isNil(lineDash);\n        var dist = 0;\n        var pointsBuffer = [];\n        var travelBuffer = [];\n        for (var i = 0; i < points_1.length; i += stridePoints) {\n            // calc travel\n            // if (needDash) {\n            if (i > 1) {\n                dist += Math.sqrt(Math.pow(points_1[i] - points_1[i - stridePoints], 2) +\n                    Math.pow(points_1[i + 1] - points_1[i + 1 - stridePoints], 2) +\n                    Math.pow(points_1[i + 2] - points_1[i + 2 - stridePoints], 2));\n            }\n            travelBuffer.push(dist);\n            // } else {\n            //   travelBuffer.push(0);\n            // }\n            pointsBuffer[j++] = points_1[i];\n            pointsBuffer[j++] = points_1[i + 1];\n            pointsBuffer[j++] = points_1[i + 2] || 0;\n            pointsBuffer[j] = jointType;\n            if (i == 0 && capType !== exports.JOINT_TYPE.CAP_ROUND) {\n                pointsBuffer[j] += capType;\n            }\n            if (i + stridePoints * 2 >= points_1.length) {\n                pointsBuffer[j] += endJoint - jointType;\n            }\n            else if (i + stridePoints >= points_1.length) {\n                pointsBuffer[j] = 0;\n            }\n            j++;\n        }\n        pointsBuffer[j++] = points_1[points_1.length - 6];\n        pointsBuffer[j++] = points_1[points_1.length - 5];\n        pointsBuffer[j++] = points_1[points_1.length - 4] || zIndex;\n        pointsBuffer[j++] = 0;\n        pointsBuffer[0] = points_1[0];\n        pointsBuffer[1] = points_1[1];\n        pointsBuffer[2] = points_1[2] || zIndex;\n        pointsBuffer[3] = 0;\n        pointsBuffer[4] = points_1[3];\n        pointsBuffer[5] = points_1[4];\n        pointsBuffer[6] = points_1[5] || zIndex;\n        pointsBuffer[7] = capType === exports.JOINT_TYPE.CAP_ROUND ? capType : 0;\n        var instancedCount = Math.round(points_1.length / stridePoints);\n        return {\n            pointsBuffer: pointsBuffer,\n            travelBuffer: travelBuffer,\n            triangles: triangles,\n            instancedCount: instancedCount,\n        };\n    }\n}\nfunction getJointType(lineJoin) {\n    var joint;\n    switch (lineJoin) {\n        case 'bevel':\n            joint = exports.JOINT_TYPE.JOINT_BEVEL;\n            break;\n        case 'round':\n            joint = exports.JOINT_TYPE.JOINT_ROUND;\n            break;\n        default:\n            joint = exports.JOINT_TYPE.JOINT_MITER;\n            break;\n    }\n    return joint;\n}\nfunction getCapType(lineCap) {\n    var cap;\n    switch (lineCap) {\n        case 'square':\n            cap = exports.JOINT_TYPE.CAP_SQUARE;\n            break;\n        case 'round':\n            cap = exports.JOINT_TYPE.CAP_ROUND;\n            break;\n        default:\n            cap = exports.JOINT_TYPE.CAP_BUTT;\n            break;\n    }\n    return cap;\n}\nfunction addTailSegment(x1, y1, z1, x2, y2, z2) {\n    if (x2 === void 0) { x2 = x1; }\n    if (y2 === void 0) { y2 = y1; }\n    if (z2 === void 0) { z2 = z1; }\n    var vec = [x2 - x1, y2 - y1, z2 - z1];\n    var length = 0.01;\n    return [x1 + vec[0] * length, y1 + vec[1] * length, z1 + vec[2] * length];\n}\n\nvar SEGMENT_NUM = 12;\nvar FillVertexAttributeBufferIndex;\n(function (FillVertexAttributeBufferIndex) {\n    FillVertexAttributeBufferIndex[FillVertexAttributeBufferIndex[\"PACKED_STYLE\"] = 5] = \"PACKED_STYLE\";\n})(FillVertexAttributeBufferIndex || (FillVertexAttributeBufferIndex = {}));\nvar FillVertexAttributeLocation;\n(function (FillVertexAttributeLocation) {\n    FillVertexAttributeLocation[FillVertexAttributeLocation[\"PACKED_STYLE3\"] = 12] = \"PACKED_STYLE3\";\n})(FillVertexAttributeLocation || (FillVertexAttributeLocation = {}));\nvar InstancedFillDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(InstancedFillDrawcall, _super);\n    function InstancedFillDrawcall(renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) {\n        var _this = _super.call(this, renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) || this;\n        _this.renderHelper = renderHelper;\n        _this.texturePool = texturePool;\n        _this.lightPool = lightPool;\n        _this.mergeAnchorIntoModelMatrix = true;\n        _this.trianglesHash = [[], []];\n        _this.trianglesHash = _this.calcSegmentNum(object);\n        return _this;\n    }\n    InstancedFillDrawcall.prototype.calcSegmentNum = function (object) {\n        var _a = updateBuffer(object, true, SEGMENT_NUM, this.calcSubpathIndex(object)), triangles = _a.triangles, pointsBuffer = _a.pointsBuffer;\n        return [triangles, pointsBuffer];\n    };\n    InstancedFillDrawcall.prototype.calcSubpathIndex = function (object) {\n        if (object.nodeName === gLite.Shape.PATH) {\n            return this.index;\n        }\n        return 0;\n    };\n    InstancedFillDrawcall.prototype.compareTrianglesHash = function (hash) {\n        var _a = tslib.__read(this.trianglesHash, 2), triangles = _a[0], points = _a[1];\n        var _b = tslib.__read(hash, 2), t = _b[0], p = _b[1];\n        if (triangles.length !== t.length || points.length !== p.length) {\n            return false;\n        }\n        if (triangles.some(function (n, i) { return n !== t[i]; }) ||\n            points.some(function (n, i) { return n !== p[i]; })) {\n            return false;\n        }\n        return true;\n    };\n    InstancedFillDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        if (this.index !== index) {\n            return false;\n        }\n        var trianglesHash = this.calcSegmentNum(object);\n        return this.compareTrianglesHash(trianglesHash);\n    };\n    InstancedFillDrawcall.prototype.createGeometry = function (objects) {\n        var _this = this;\n        var indices = [];\n        var pointsBuffer = [];\n        var uvsBuffer = [];\n        var offset = 0;\n        objects.forEach(function (object, i) {\n            // use triangles for Polygon\n            var _a = updateBuffer(object, true, SEGMENT_NUM, _this.calcSubpathIndex(object)), triangles = _a.triangles, pBuffer = _a.pointsBuffer;\n            if (triangles.length) {\n                var halfExtents_1 = object.getGeometryBounds().halfExtents;\n                // pointsBuffer use 3D\n                var uvBuffer_1 = [];\n                pBuffer.forEach(function (x, i) {\n                    if (i % 3 !== 2) {\n                        uvBuffer_1.push(x / halfExtents_1[i % 3] / 2);\n                    }\n                });\n                offset += pointsBuffer.length / 3;\n                pointsBuffer.push.apply(pointsBuffer, tslib.__spreadArray([], tslib.__read(pBuffer), false));\n                uvsBuffer.push.apply(uvsBuffer, tslib.__spreadArray([], tslib.__read(uvBuffer_1), false));\n                indices.push.apply(indices, tslib.__spreadArray([], tslib.__read(triangles.map(function (n) { return n + offset; })), false));\n            }\n        });\n        if (pointsBuffer.length) {\n            // use default common attributes\n            _super.prototype.createGeometry.call(this, objects);\n            var packedStyle_1 = [];\n            objects.forEach(function (object) {\n                var _a = object.parsedStyle, isBillboard = _a.isBillboard, billboardRotation = _a.billboardRotation, isSizeAttenuation = _a.isSizeAttenuation;\n                packedStyle_1.push(isBillboard ? 1 : 0, billboardRotation !== null && billboardRotation !== void 0 ? billboardRotation : 0, isSizeAttenuation ? 1 : 0, 0);\n            });\n            this.geometry.setVertexBuffer({\n                bufferIndex: exports.VertexAttributeBufferIndex.POSITION,\n                byteStride: 4 * 3,\n                stepMode: gDeviceApi.VertexStepMode.VERTEX,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_RGB,\n                        bufferByteOffset: 4 * 0,\n                        location: exports.VertexAttributeLocation.POSITION,\n                    },\n                ],\n                data: new Float32Array(pointsBuffer),\n            });\n            this.geometry.setVertexBuffer({\n                bufferIndex: FillVertexAttributeBufferIndex.PACKED_STYLE,\n                byteStride: 4 * 4,\n                stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_RGBA,\n                        bufferByteOffset: 4 * 0,\n                        location: FillVertexAttributeLocation.PACKED_STYLE3,\n                        divisor: 1,\n                    },\n                ],\n                data: new Float32Array(packedStyle_1),\n            });\n            this.geometry.setVertexBuffer({\n                bufferIndex: exports.VertexAttributeBufferIndex.UV,\n                byteStride: 4 * 2,\n                stepMode: gDeviceApi.VertexStepMode.VERTEX,\n                attributes: [\n                    {\n                        format: gDeviceApi.Format.F32_RG,\n                        bufferByteOffset: 4 * 0,\n                        location: exports.VertexAttributeLocation.UV,\n                    },\n                ],\n                data: new Float32Array(uvsBuffer),\n            });\n            this.geometry.vertexCount = indices.length / objects.length;\n            this.geometry.setIndexBuffer(new Uint32Array(indices));\n        }\n    };\n    InstancedFillDrawcall.prototype.createMaterial = function (objects) {\n        this.material.vertexShader = meshVert;\n        this.material.fragmentShader = meshFrag;\n        this.material.defines = tslib.__assign(tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(FillVertexAttributeLocation)), { INSTANCED: true });\n    };\n    InstancedFillDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);\n        this.updateBatchedAttribute(objects, startIndex, name, value);\n        if (name === 'isBillboard' ||\n            name === 'billboardRotation' ||\n            name === 'isSizeAttenuation') {\n            var packed_1 = [];\n            objects.forEach(function (object) {\n                var _a = object.parsedStyle, isBillboard = _a.isBillboard, billboardRotation = _a.billboardRotation, isSizeAttenuation = _a.isSizeAttenuation;\n                packed_1.push(isBillboard ? 1 : 0, billboardRotation !== null && billboardRotation !== void 0 ? billboardRotation : 0, isSizeAttenuation ? 1 : 0, 0);\n            });\n            this.geometry.updateVertexBuffer(FillVertexAttributeBufferIndex.PACKED_STYLE, FillVertexAttributeLocation.PACKED_STYLE3, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));\n        }\n    };\n    return InstancedFillDrawcall;\n}(Instanced));\n\nvar segmentInstanceGeometry = [\n    0, -0.5, 0, 0, 0, 1, -0.5, 1, 1, 0, 1, 0.5, 1, 1, 1, 0, 0.5, 0, 0, 1,\n];\nvar InstancedLineVertexAttributeBufferIndex;\n(function (InstancedLineVertexAttributeBufferIndex) {\n    InstancedLineVertexAttributeBufferIndex[InstancedLineVertexAttributeBufferIndex[\"POINT\"] = 5] = \"POINT\";\n    InstancedLineVertexAttributeBufferIndex[InstancedLineVertexAttributeBufferIndex[\"CAP\"] = 6] = \"CAP\";\n    InstancedLineVertexAttributeBufferIndex[InstancedLineVertexAttributeBufferIndex[\"DASH\"] = 7] = \"DASH\";\n})(InstancedLineVertexAttributeBufferIndex || (InstancedLineVertexAttributeBufferIndex = {}));\nvar InstancedLineVertexAttributeLocation;\n(function (InstancedLineVertexAttributeLocation) {\n    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation[\"POSITION\"] = 8] = \"POSITION\";\n    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation[\"UV\"] = 10] = \"UV\";\n    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation[\"POINTA\"] = 9] = \"POINTA\";\n    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation[\"POINTB\"] = 11] = \"POINTB\";\n    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation[\"CAP\"] = 12] = \"CAP\";\n    InstancedLineVertexAttributeLocation[InstancedLineVertexAttributeLocation[\"DASH\"] = 13] = \"DASH\";\n})(InstancedLineVertexAttributeLocation || (InstancedLineVertexAttributeLocation = {}));\nvar LineCap_MAP = {\n    butt: 1,\n    round: 2,\n    square: 3,\n};\nvar InstancedLineDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(InstancedLineDrawcall, _super);\n    function InstancedLineDrawcall(renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) {\n        var _this = _super.call(this, renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) || this;\n        _this.renderHelper = renderHelper;\n        _this.texturePool = texturePool;\n        _this.lightPool = lightPool;\n        _this.gradientAttributeName = 'stroke';\n        return _this;\n    }\n    InstancedLineDrawcall.isLine = function (object, subpathIndex) {\n        if (object.nodeName === gLite.Shape.PATH) {\n            var absolutePath = object.parsedStyle.path.absolutePath;\n            var mSegmentCount = 0;\n            var mCommandIndex = 0;\n            for (var i = 0; i < absolutePath.length; i++) {\n                var segment = absolutePath[i];\n                if (segment[0] === 'M') {\n                    if (mSegmentCount === subpathIndex) {\n                        mCommandIndex = i;\n                        break;\n                    }\n                    mSegmentCount++;\n                }\n            }\n            // only contains M & L commands\n            if (absolutePath[mCommandIndex][0] === 'M' &&\n                absolutePath[mCommandIndex + 1][0] === 'L' &&\n                (absolutePath[mCommandIndex + 2] === undefined ||\n                    absolutePath[mCommandIndex + 2][0] === 'M')) {\n                return true;\n            }\n        }\n        else if (object.nodeName === gLite.Shape.POLYLINE) {\n            var points = object.parsedStyle.points.points;\n            var tangent = (points[1][0] - points[1][1]) / (points[0][0] - points[0][1]);\n            for (var i = 1; i < points.length - 1; i++) {\n                if ((points[i + 1][0] - points[i + 1][1]) /\n                    (points[i][0] - points[i][1]) !==\n                    tangent) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    InstancedLineDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        return true;\n    };\n    InstancedLineDrawcall.prototype.createMaterial = function (objects) {\n        this.material.vertexShader = vert$3;\n        this.material.fragmentShader = frag$3;\n        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(InstancedLineVertexAttributeLocation));\n    };\n    InstancedLineDrawcall.prototype.calcSubpathIndex = function (object) {\n        if (object.nodeName === gLite.Shape.PATH) {\n            var fillDrawcallCount = this.drawcallCtors.filter(function (ctor) { return ctor === InstancedFillDrawcall; }).length;\n            return this.index - fillDrawcallCount;\n        }\n        return 0;\n    };\n    InstancedLineDrawcall.prototype.createGeometry = function (objects) {\n        var _this = this;\n        // use default common attributes\n        _super.prototype.createGeometry.call(this, objects);\n        var interleaved = [];\n        var packedCap = [];\n        var packedDash = [];\n        var indices = [];\n        var offset = 0;\n        objects.forEach(function (object) {\n            var parsedLineStyleProps;\n            var totalLength;\n            if (object.nodeName === gLite.Shape.LINE) {\n                parsedLineStyleProps = object.parsedStyle;\n                totalLength = object.getTotalLength();\n            }\n            else if (object.nodeName === gLite.Shape.POLYLINE) {\n                var _a = object.parsedStyle, points = _a.points.points, defX_1 = _a.defX, defY_1 = _a.defY, lineCap_1 = _a.lineCap, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, isBillboard_1 = _a.isBillboard, \n                // @ts-ignore\n                isSizeAttenuation_1 = _a.isSizeAttenuation;\n                parsedLineStyleProps = {\n                    x1: points[0][0],\n                    y1: points[0][1],\n                    x2: points[points.length - 1][0],\n                    y2: points[points.length - 1][1],\n                    z1: 0,\n                    z2: 0,\n                    defX: defX_1,\n                    defY: defY_1,\n                    lineCap: lineCap_1,\n                    lineDash: lineDash,\n                    lineDashOffset: lineDashOffset,\n                    isBillboard: isBillboard_1,\n                    isSizeAttenuation: isSizeAttenuation_1,\n                    markerStart: markerStart,\n                    markerEnd: markerEnd,\n                    markerStartOffset: markerStartOffset,\n                    markerEndOffset: markerEndOffset,\n                };\n                totalLength = object.getTotalLength();\n            }\n            else if (object.nodeName === gLite.Shape.PATH) {\n                var _b = object.parsedStyle, absolutePath = _b.path.absolutePath, defX_2 = _b.defX, defY_2 = _b.defY, lineCap_2 = _b.lineCap, lineDash = _b.lineDash, lineDashOffset = _b.lineDashOffset, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerStartOffset = _b.markerStartOffset, markerEndOffset = _b.markerEndOffset, isBillboard_2 = _b.isBillboard, isSizeAttenuation_2 = _b.isSizeAttenuation;\n                var mSegmentCount = 0;\n                var mCommandIndex = 0;\n                var index = _this.calcSubpathIndex(object);\n                for (var i = 0; i < absolutePath.length; i++) {\n                    var segment = absolutePath[i];\n                    if (segment[0] === 'M') {\n                        if (mSegmentCount === index) {\n                            mCommandIndex = i;\n                            break;\n                        }\n                        mSegmentCount++;\n                    }\n                }\n                parsedLineStyleProps = {\n                    x1: absolutePath[mCommandIndex][1],\n                    y1: absolutePath[mCommandIndex][2],\n                    x2: absolutePath[mCommandIndex + 1][1],\n                    y2: absolutePath[mCommandIndex + 1][2],\n                    z1: 0,\n                    z2: 0,\n                    defX: defX_2,\n                    defY: defY_2,\n                    lineCap: lineCap_2,\n                    lineDash: lineDash,\n                    lineDashOffset: lineDashOffset,\n                    isBillboard: isBillboard_2,\n                    isSizeAttenuation: isSizeAttenuation_2,\n                    markerStart: markerStart,\n                    markerEnd: markerEnd,\n                    markerStartOffset: markerStartOffset,\n                    markerEndOffset: markerEndOffset,\n                };\n                totalLength = object.getTotalLength();\n            }\n            var x1 = parsedLineStyleProps.x1, y1 = parsedLineStyleProps.y1, x2 = parsedLineStyleProps.x2, y2 = parsedLineStyleProps.y2, z1 = parsedLineStyleProps.z1, z2 = parsedLineStyleProps.z2, defX = parsedLineStyleProps.defX, defY = parsedLineStyleProps.defY, lineCap = parsedLineStyleProps.lineCap, isBillboard = parsedLineStyleProps.isBillboard, isSizeAttenuation = parsedLineStyleProps.isSizeAttenuation;\n            var _c = _this.calcOffset(parsedLineStyleProps), startOffsetX = _c.startOffsetX, startOffsetY = _c.startOffsetY, endOffsetX = _c.endOffsetX, endOffsetY = _c.endOffsetY;\n            var _d = _this.calcDash(parsedLineStyleProps, totalLength), dashOffset = _d.dashOffset, dashSegmentPercent = _d.dashSegmentPercent, dashRatioInEachSegment = _d.dashRatioInEachSegment;\n            packedCap.push(\n            // caps\n            LineCap_MAP[lineCap]);\n            packedDash.push(dashOffset, dashSegmentPercent, dashRatioInEachSegment, \n            // isSizeAttenuation\n            isBillboard || isSizeAttenuation ? 1 : 0);\n            interleaved.push(x1 - defX + startOffsetX, y1 - defY + startOffsetY, z1, x2 - defX + endOffsetX, y2 - defY + endOffsetY, z2);\n            indices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);\n            offset += 4;\n        });\n        this.geometry.setIndexBuffer(new Uint32Array(indices));\n        this.geometry.vertexCount = 6;\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,\n            byteStride: 4 * 5,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGB,\n                    bufferByteOffset: 4 * 0,\n                    location: InstancedLineVertexAttributeLocation.POSITION,\n                    divisor: 0,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 3,\n                    location: InstancedLineVertexAttributeLocation.UV,\n                    divisor: 0,\n                },\n            ],\n            data: new Float32Array(segmentInstanceGeometry),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: InstancedLineVertexAttributeBufferIndex.POINT,\n            byteStride: 4 * (3 + 3),\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGB,\n                    bufferByteOffset: 4 * 0,\n                    location: InstancedLineVertexAttributeLocation.POINTA,\n                    divisor: 1,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGB,\n                    bufferByteOffset: 4 * 3,\n                    location: InstancedLineVertexAttributeLocation.POINTB,\n                    divisor: 1,\n                },\n            ],\n            data: new Float32Array(interleaved),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: InstancedLineVertexAttributeBufferIndex.CAP,\n            byteStride: 4 * 1,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_R,\n                    bufferByteOffset: 4 * 0,\n                    location: InstancedLineVertexAttributeLocation.CAP,\n                    divisor: 1,\n                },\n            ],\n            data: new Float32Array(packedCap),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: InstancedLineVertexAttributeBufferIndex.DASH,\n            byteStride: 4 * 4,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: InstancedLineVertexAttributeLocation.DASH,\n                    divisor: 1,\n                },\n            ],\n            data: new Float32Array(packedDash),\n        });\n    };\n    InstancedLineDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        var _this = this;\n        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);\n        this.updateBatchedAttribute(objects, startIndex, name, value);\n        if (name === 'x1' ||\n            name === 'y1' ||\n            name === 'x2' ||\n            name === 'y2' ||\n            name === 'z1' ||\n            name === 'z2' ||\n            name === 'markerStartOffset' ||\n            name === 'markerEndOffset' ||\n            name === 'markerStart' ||\n            name === 'markerEnd' ||\n            name === 'points' ||\n            name === 'path') {\n            var packed_1 = [];\n            objects.forEach(function (object) {\n                var parsedLineStyleProps;\n                if (object.nodeName === gLite.Shape.LINE) {\n                    parsedLineStyleProps = object.parsedStyle;\n                }\n                else if (object.nodeName === gLite.Shape.POLYLINE) {\n                    var _a = object.parsedStyle, points = _a.points.points, defX_3 = _a.defX, defY_3 = _a.defY, lineCap = _a.lineCap, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, isBillboard = _a.isBillboard, \n                    // @ts-ignore\n                    isSizeAttenuation = _a.isSizeAttenuation;\n                    parsedLineStyleProps = {\n                        x1: points[0][0],\n                        y1: points[0][1],\n                        x2: points[points.length - 1][0],\n                        y2: points[points.length - 1][1],\n                        z1: 0,\n                        z2: 0,\n                        defX: defX_3,\n                        defY: defY_3,\n                        lineCap: lineCap,\n                        isSizeAttenuation: isSizeAttenuation,\n                        isBillboard: isBillboard,\n                        markerStart: markerStart,\n                        markerEnd: markerEnd,\n                        markerStartOffset: markerStartOffset,\n                        markerEndOffset: markerEndOffset,\n                    };\n                }\n                else if (object.nodeName === gLite.Shape.PATH) {\n                    var _b = object.parsedStyle, absolutePath = _b.path.absolutePath, defX_4 = _b.defX, defY_4 = _b.defY, lineCap = _b.lineCap, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerStartOffset = _b.markerStartOffset, markerEndOffset = _b.markerEndOffset, isBillboard = _b.isBillboard, isSizeAttenuation = _b.isSizeAttenuation;\n                    parsedLineStyleProps = {\n                        x1: absolutePath[0][1],\n                        y1: absolutePath[0][2],\n                        x2: absolutePath[1][1],\n                        y2: absolutePath[1][2],\n                        z1: 0,\n                        z2: 0,\n                        defX: defX_4,\n                        defY: defY_4,\n                        lineCap: lineCap,\n                        isBillboard: isBillboard,\n                        isSizeAttenuation: isSizeAttenuation,\n                        markerStart: markerStart,\n                        markerEnd: markerEnd,\n                        markerStartOffset: markerStartOffset,\n                        markerEndOffset: markerEndOffset,\n                    };\n                }\n                var x1 = parsedLineStyleProps.x1, y1 = parsedLineStyleProps.y1, x2 = parsedLineStyleProps.x2, y2 = parsedLineStyleProps.y2, z1 = parsedLineStyleProps.z1, z2 = parsedLineStyleProps.z2, defX = parsedLineStyleProps.defX, defY = parsedLineStyleProps.defY;\n                var _c = _this.calcOffset(parsedLineStyleProps), startOffsetX = _c.startOffsetX, startOffsetY = _c.startOffsetY, endOffsetX = _c.endOffsetX, endOffsetY = _c.endOffsetY;\n                packed_1.push(x1 - defX + startOffsetX, y1 - defY + startOffsetY, z1, x2 - defX + endOffsetX, y2 - defY + endOffsetY, z2);\n            });\n            this.geometry.updateVertexBuffer(InstancedLineVertexAttributeBufferIndex.POINT, InstancedLineVertexAttributeLocation.POINTA, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));\n        }\n        else if (name === 'lineDashOffset' ||\n            name === 'lineDash' ||\n            name === 'isSizeAttenuation' ||\n            name === 'isBillboard') {\n            var packed_2 = [];\n            objects.forEach(function (object) {\n                var totalLength = object.getTotalLength();\n                var _a = _this.calcDash(object.parsedStyle, totalLength), dashOffset = _a.dashOffset, dashSegmentPercent = _a.dashSegmentPercent, dashRatioInEachSegment = _a.dashRatioInEachSegment;\n                packed_2.push(dashOffset, dashSegmentPercent, dashRatioInEachSegment, object.parsedStyle.isBillboard || object.parsedStyle.isSizeAttenuation\n                    ? 1\n                    : 0);\n            });\n            this.geometry.updateVertexBuffer(InstancedLineVertexAttributeBufferIndex.DASH, InstancedLineVertexAttributeLocation.DASH, startIndex, new Uint8Array(new Float32Array(packed_2).buffer));\n        }\n        else if (name === 'lineCap') {\n            var packed_3 = [];\n            objects.forEach(function (object) {\n                var lineCap = object.parsedStyle.lineCap;\n                packed_3.push(LineCap_MAP[lineCap]);\n            });\n            this.geometry.updateVertexBuffer(InstancedLineVertexAttributeBufferIndex.CAP, InstancedLineVertexAttributeLocation.CAP, startIndex, new Uint8Array(new Float32Array(packed_3).buffer));\n        }\n    };\n    InstancedLineDrawcall.prototype.calcOffset = function (parsedStyle) {\n        var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n        var startOffsetX = 0;\n        var startOffsetY = 0;\n        var endOffsetX = 0;\n        var endOffsetY = 0;\n        var rad = 0;\n        var x;\n        var y;\n        if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n            x = x2 - x1;\n            y = y2 - y1;\n            rad = Math.atan2(y, x);\n            startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n            startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n        }\n        if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n            x = x1 - x2;\n            y = y1 - y2;\n            rad = Math.atan2(y, x);\n            endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n            endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n        }\n        return {\n            startOffsetX: startOffsetX,\n            startOffsetY: startOffsetY,\n            endOffsetX: endOffsetX,\n            endOffsetY: endOffsetY,\n        };\n    };\n    InstancedLineDrawcall.prototype.calcDash = function (parsedLineStyle, totalLength) {\n        var lineDash = parsedLineStyle.lineDash, lineDashOffset = parsedLineStyle.lineDashOffset;\n        var dashOffset = 0;\n        var dashSegmentPercent = 1;\n        var dashRatioInEachSegment = 0;\n        if (lineDash && lineDash.length) {\n            dashOffset = (lineDashOffset || 0) / totalLength;\n            var segmentsLength = lineDash.reduce(function (cur, prev) { return cur + prev; }, 0);\n            if (segmentsLength === 0) {\n                dashSegmentPercent = 1;\n                dashRatioInEachSegment = 0;\n            }\n            else {\n                dashSegmentPercent = segmentsLength / totalLength;\n                dashRatioInEachSegment = lineDash[1] / segmentsLength;\n            }\n        }\n        return {\n            dashOffset: dashOffset,\n            dashSegmentPercent: dashSegmentPercent,\n            dashRatioInEachSegment: dashRatioInEachSegment,\n        };\n    };\n    return InstancedLineDrawcall;\n}(Instanced));\n\nvar frag$1 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\n\\nin vec4 v_PickingResult;\\nin vec4 v_Color;\\nin vec4 v_StrokeColor;\\nin vec4 v_StylePacked1;\\nin vec4 v_StylePacked2;\\n#ifdef USE_UV\\n  in vec2 v_Uv;\\n#endif\\n#ifdef USE_MAP\\n  uniform sampler2D u_Map;\\n#endif\\n\\nout vec4 outputColor;\\n\\nfloat epsilon = 0.000001;\\n\\nvoid main() {\\n  vec4 u_Color = v_Color;\\nvec4 u_StrokeColor = v_StrokeColor;\\nfloat u_Opacity = v_StylePacked1.x;\\nfloat u_FillOpacity = v_StylePacked1.y;\\nfloat u_StrokeOpacity = v_StylePacked1.z;\\nfloat u_StrokeWidth = v_StylePacked1.w;\\nfloat u_Visible = v_StylePacked2.x;\\nvec3 u_PickingColor = v_PickingResult.xyz;\\n\\nif (u_Visible < 0.5) {\\n    discard;\\n}\\n  #ifdef USE_MAP\\n  #ifdef USE_PATTERN\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #else\\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\\n    u_Color = texelColor;\\n  #endif\\n#endif\\n\\n  if (u_IsPicking > 0.5) {\\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\\n      discard;\\n    }\\n\\n    // TODO: pointer-events: non-transparent-pixel\\n    // if (u_Color.x == 0.0 && u_Color.y == 0.0 && u_Color.z == 0.0) {\\n    //   discard;\\n    // }\\n    outputColor = vec4(u_PickingColor, 1.0);\\n  } else {\\n    outputColor = u_Color;\\n    outputColor.a = outputColor.a * u_Opacity;\\n\\n    if (outputColor.a < epsilon) {\\n      discard;\\n    }\\n  }\\n}\"; // eslint-disable-line\n\nvar vert$1 = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\\n\\nout vec4 v_PickingResult;\\nout vec4 v_Color;\\nout vec4 v_StrokeColor;\\nout vec4 v_StylePacked1;\\nout vec4 v_StylePacked2;\\n\\n#define COLOR_SCALE 1. / 255.\\nvoid setPickingColor(vec3 pickingColor) {\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nvec2 unpack_float(const float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\nvec4 decode_color(const vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\\n  return pm * vm * mm * pos;\\n}\\n\\nbool isPerspectiveMatrix(mat4 m) {\\n  return m[2][3] == -1.0;\\n}\\n\\nvec4 billboard(vec2 offset, float rotation, bool isSizeAttenuation, mat4 pm, mat4 vm, mat4 mm) {\\n  vec4 mvPosition = vm * mm * vec4(0.0, 0.0, 0.0, 1.0);\\n  vec2 scale;\\n  scale.x = length(vec3(mm[0][0], mm[0][1], mm[0][2]));\\n  scale.y = length(vec3(mm[1][0], mm[1][1], mm[1][2]));\\n\\n  if (isSizeAttenuation) {\\n    bool isPerspective = isPerspectiveMatrix(pm);\\n    if (isPerspective) {\\n      scale *= -mvPosition.z / 250.0;\\n    }\\n  }\\n\\n  vec2 alignedPosition = offset * scale;\\n  vec2 rotatedPosition;\\n  rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\\n  rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\\n\\n  mvPosition.xy += rotatedPosition;\\n  return pm * mvPosition;\\n}\\n\\nlayout(location = POSITION) in vec2 a_Size;\\nlayout(location = PACKED_STYLE3) in vec4 a_StylePacked3;\\n\\n#ifdef USE_UV\\n  layout(location = UV) in vec2 a_Uv;\\n  out vec2 v_Uv;\\n#endif\\n\\nvoid main() {\\n  vec4 a_Color = decode_color(a_PackedColor.xy);\\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\\n\\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\\nvec4 u_StrokeColor = a_StrokeColor;\\nfloat u_Opacity = a_StylePacked1.x;\\nfloat u_FillOpacity = a_StylePacked1.y;\\nfloat u_StrokeOpacity = a_StylePacked1.z;\\nfloat u_StrokeWidth = a_StylePacked1.w;\\nfloat u_ZIndex = a_PickingColor.w;\\nvec2 u_Anchor = a_StylePacked2.yz;\\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\\n\\nsetPickingColor(a_PickingColor.xyz);\\n\\nv_Color = a_Color;\\nv_StrokeColor = a_StrokeColor;\\nv_StylePacked1 = a_StylePacked1;\\nv_StylePacked2 = a_StylePacked2;\\n\\n// #ifdef CLIPSPACE_NEAR_ZERO\\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\\n// #endif\\n\\n  vec2 offset = (a_Uv - u_Anchor.xy) * a_Size;\\n\\n  bool isBillboard = a_StylePacked3.x > 0.5;\\n  if (isBillboard) {\\n    float rotation = a_StylePacked3.y;\\n    bool isSizeAttenuation = a_StylePacked3.z > 0.5;\\n    gl_Position = billboard(offset, rotation, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  } else {\\n    gl_Position = project(vec4(offset, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  }\\n\\n  #ifdef USE_UV\\n  v_Uv = a_Uv;\\n#endif\\n\\n}\"; // eslint-disable-line\n\nvar ImageVertexAttributeBufferIndex;\n(function (ImageVertexAttributeBufferIndex) {\n    ImageVertexAttributeBufferIndex[ImageVertexAttributeBufferIndex[\"PACKED_STYLE\"] = 5] = \"PACKED_STYLE\";\n})(ImageVertexAttributeBufferIndex || (ImageVertexAttributeBufferIndex = {}));\nvar ImageVertexAttributeLocation;\n(function (ImageVertexAttributeLocation) {\n    ImageVertexAttributeLocation[ImageVertexAttributeLocation[\"PACKED_STYLE3\"] = 12] = \"PACKED_STYLE3\";\n})(ImageVertexAttributeLocation || (ImageVertexAttributeLocation = {}));\nvar ImageDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(ImageDrawcall, _super);\n    function ImageDrawcall() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImageDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        if (this.instance.parsedStyle.img !== object.parsedStyle.img) {\n            return false;\n        }\n        return true;\n    };\n    ImageDrawcall.prototype.createMaterial = function (objects) {\n        var instance = objects[0];\n        var img = instance.parsedStyle.img;\n        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(ImageVertexAttributeLocation));\n        this.material.vertexShader = vert$1;\n        this.material.fragmentShader = frag$1;\n        var map = this.texturePool.getOrCreateTexture(this.context.device, img);\n        this.material.setUniforms({\n            u_Map: map,\n        });\n    };\n    ImageDrawcall.prototype.createGeometry = function (objects) {\n        // use default common attributes\n        _super.prototype.createGeometry.call(this, objects);\n        var instanced = [];\n        var packedStyle = [];\n        objects.forEach(function (object, i) {\n            var image = object;\n            var _a = image.parsedStyle, width = _a.width, height = _a.height, isBillboard = _a.isBillboard, billboardRotation = _a.billboardRotation, isSizeAttenuation = _a.isSizeAttenuation;\n            instanced.push(width, height);\n            packedStyle.push(isBillboard ? 1 : 0, billboardRotation !== null && billboardRotation !== void 0 ? billboardRotation : 0, isSizeAttenuation ? 1 : 0, 0);\n        });\n        this.geometry.setIndexBuffer(new Uint32Array([0, 2, 1, 0, 3, 2]));\n        this.geometry.vertexCount = 6;\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.POSITION,\n            byteStride: 4 * 2,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.POSITION,\n                },\n            ],\n            data: new Float32Array(instanced),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: ImageVertexAttributeBufferIndex.PACKED_STYLE,\n            byteStride: 4 * 4,\n            stepMode: gDeviceApi.VertexStepMode.INSTANCE,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: ImageVertexAttributeLocation.PACKED_STYLE3,\n                    divisor: 1,\n                },\n            ],\n            data: new Float32Array(packedStyle),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: exports.VertexAttributeBufferIndex.UV,\n            byteStride: 4 * 2,\n            stepMode: gDeviceApi.VertexStepMode.VERTEX,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.UV,\n                },\n            ],\n            data: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n        });\n    };\n    ImageDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);\n        this.updateBatchedAttribute(objects, startIndex, name, value);\n        if (name === 'width' || name === 'height' || name === 'z') {\n            var packed_1 = [];\n            objects.forEach(function (object) {\n                var image = object;\n                var _a = image.parsedStyle, width = _a.width, height = _a.height;\n                packed_1.push(width, height);\n            });\n            this.geometry.updateVertexBuffer(exports.VertexAttributeBufferIndex.POSITION, exports.VertexAttributeLocation.POSITION, startIndex, new Uint8Array(new Float32Array(packed_1).buffer));\n        }\n        else if (name === 'isBillboard' ||\n            name === 'billboardRotation' ||\n            name === 'isSizeAttenuation') {\n            var packed_2 = [];\n            objects.forEach(function (object) {\n                var image = object;\n                var _a = image.parsedStyle, isBillboard = _a.isBillboard, billboardRotation = _a.billboardRotation, isSizeAttenuation = _a.isSizeAttenuation;\n                packed_2.push(isBillboard ? 1 : 0, billboardRotation !== null && billboardRotation !== void 0 ? billboardRotation : 0, isSizeAttenuation ? 1 : 0, 0);\n            });\n            this.geometry.updateVertexBuffer(ImageVertexAttributeBufferIndex.PACKED_STYLE, ImageVertexAttributeLocation.PACKED_STYLE3, startIndex, new Uint8Array(new Float32Array(packed_2).buffer));\n        }\n        else if (name === 'img') {\n            var map = this.texturePool.getOrCreateTexture(this.context.device, value);\n            this.material.setUniforms({\n                u_Map: map,\n            });\n        }\n    };\n    return ImageDrawcall;\n}(Instanced));\n\nvar frag = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\nin vec4 v_PickingResult;\\nin vec4 v_Color;\\nin vec4 v_StrokeColor;\\nin vec4 v_StylePacked1;\\nin vec4 v_StylePacked2;\\nlayout(std140) uniform ub_ObjectParams {\\n  vec2 u_SDFMapSize;\\n  float u_FontSize;\\n  float u_GammaScale;\\n  float u_StrokeBlur;\\n  float u_HasStroke;\\n};\\n#ifdef USE_UV\\n  in vec2 v_Uv;\\n#endif\\n\\nuniform sampler2D u_SDFMap;\\n\\n#define SDF_PX 8.0\\n\\nout vec4 outputColor;\\nfloat epsilon = 0.000001;\\n\\nvoid main() {\\n  vec4 u_Color = v_Color;\\nvec4 u_StrokeColor = v_StrokeColor;\\nfloat u_Opacity = v_StylePacked1.x;\\nfloat u_FillOpacity = v_StylePacked1.y;\\nfloat u_StrokeOpacity = v_StylePacked1.z;\\nfloat u_StrokeWidth = v_StylePacked1.w;\\nfloat u_Visible = v_StylePacked2.x;\\nvec3 u_PickingColor = v_PickingResult.xyz;\\n\\nif (u_Visible < 0.5) {\\n    discard;\\n}\\n\\n  float dist = texture(SAMPLER_2D(u_SDFMap), v_Uv).a;\\n\\n  float fontScale = u_FontSize / 24.0;\\n  lowp vec4 color = u_Color;\\n  lowp float buff = (256.0 - 64.0) / 256.0;\\n  float opacity = u_FillOpacity;\\n  if (u_HasStroke > 0.5 && u_StrokeWidth > 0.0) {\\n    color = u_StrokeColor;\\n    buff = (6.0 - u_StrokeWidth / fontScale / 2.0) / SDF_PX;\\n    opacity = u_StrokeOpacity;\\n  }\\n\\n  highp float gamma_scaled = fwidth(dist);\\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\\n\\n  opacity *= alpha * u_Opacity;\\n\\n  if (u_IsPicking > 0.5) {\\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\\n      discard;\\n    }\\n    outputColor = vec4(u_PickingColor, 1.0);\\n  } else {\\n\\n    if (opacity < epsilon) {\\n      discard;\\n    }\\n\\n    outputColor = color;\\n    outputColor.a *= opacity;\\n  }\\n}\"; // eslint-disable-line\n\nvar vert = \"#define GLSLIFY 1\\nlayout(std140) uniform ub_SceneParams {\\n  mat4 u_ProjectionMatrix;\\n  mat4 u_ViewMatrix;\\n  vec3 u_CameraPosition;\\n  float u_DevicePixelRatio;\\n  vec2 u_Viewport;\\n  float u_IsOrtho;\\n  float u_IsPicking;\\n};\\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\\n\\nout vec4 v_PickingResult;\\nout vec4 v_Color;\\nout vec4 v_StrokeColor;\\nout vec4 v_StylePacked1;\\nout vec4 v_StylePacked2;\\n\\n#define COLOR_SCALE 1. / 255.\\nvoid setPickingColor(vec3 pickingColor) {\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nvec2 unpack_float(const float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\nvec4 decode_color(const vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\n\\nlayout(std140) uniform ub_ObjectParams {\\n  vec2 u_SDFMapSize;\\n  float u_FontSize;\\n  float u_GammaScale;\\n  float u_StrokeBlur;\\n  float u_HasStroke;\\n};\\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\\n  return pm * vm * mm * pos;\\n}\\n\\nbool isPerspectiveMatrix(mat4 m) {\\n  return m[2][3] == -1.0;\\n}\\n\\nvec4 billboard(vec2 offset, float rotation, bool isSizeAttenuation, mat4 pm, mat4 vm, mat4 mm) {\\n  vec4 mvPosition = vm * mm * vec4(0.0, 0.0, 0.0, 1.0);\\n  vec2 scale;\\n  scale.x = length(vec3(mm[0][0], mm[0][1], mm[0][2]));\\n  scale.y = length(vec3(mm[1][0], mm[1][1], mm[1][2]));\\n\\n  if (isSizeAttenuation) {\\n    bool isPerspective = isPerspectiveMatrix(pm);\\n    if (isPerspective) {\\n      scale *= -mvPosition.z / 250.0;\\n    }\\n  }\\n\\n  vec2 alignedPosition = offset * scale;\\n  vec2 rotatedPosition;\\n  rotatedPosition.x = cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y;\\n  rotatedPosition.y = sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y;\\n\\n  mvPosition.xy += rotatedPosition;\\n  return pm * mvPosition;\\n}\\n\\nlayout(location = TEX) in vec2 a_Tex;\\nlayout(location = OFFSET) in vec2 a_Offset;\\n\\nout vec2 v_Uv;\\n\\nvoid main() {\\n  vec4 a_Color = decode_color(a_PackedColor.xy);\\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\\n\\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\\nvec4 u_StrokeColor = a_StrokeColor;\\nfloat u_Opacity = a_StylePacked1.x;\\nfloat u_FillOpacity = a_StylePacked1.y;\\nfloat u_StrokeOpacity = a_StylePacked1.z;\\nfloat u_StrokeWidth = a_StylePacked1.w;\\nfloat u_ZIndex = a_PickingColor.w;\\nvec2 u_Anchor = a_StylePacked2.yz;\\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\\n\\nsetPickingColor(a_PickingColor.xyz);\\n\\nv_Color = a_Color;\\nv_StrokeColor = a_StrokeColor;\\nv_StylePacked1 = a_StylePacked1;\\nv_StylePacked2 = a_StylePacked2;\\n\\n// #ifdef CLIPSPACE_NEAR_ZERO\\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\\n// #endif\\n\\n  v_Uv = a_Tex / u_SDFMapSize;\\n  float fontScale = u_FontSize / 24.;\\n\\n  vec2 bufferOffset = vec2(0.7, 2.0);\\n  vec2 offset = a_Offset * fontScale + bufferOffset;\\n\\n  bool isBillboard = a_StylePacked2.y > 0.5;\\n  if (isBillboard) {\\n    float rotation =  a_StylePacked2.w;\\n    bool isSizeAttenuation = a_StylePacked2.z > 0.5;\\n    gl_Position = billboard(offset, rotation, isSizeAttenuation, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  } else {\\n    gl_Position = project(vec4((a_Offset) * fontScale + bufferOffset, u_ZIndex, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\\n  }\\n}\"; // eslint-disable-line\n\n// borrow from mapbox/src/symbol\nfunction createImage(image, _a, channels, data) {\n    var width = _a.width, height = _a.height;\n    if (!data) {\n        data = new Uint8Array(width * height * channels);\n    }\n    else if (data.length !== width * height * channels) {\n        throw new RangeError('mismatched image size');\n    }\n    image.width = width;\n    image.height = height;\n    image.data = data;\n    return image;\n}\nfunction resizeImage(image, _a, channels) {\n    var width = _a.width, height = _a.height;\n    if (width === image.width && height === image.height) {\n        return;\n    }\n    var newImage = createImage({}, { width: width, height: height }, channels);\n    copyImage(image, newImage, { x: 0, y: 0 }, { x: 0, y: 0 }, {\n        width: Math.min(image.width, width),\n        height: Math.min(image.height, height),\n    }, channels);\n    image.width = width;\n    image.height = height;\n    image.data = newImage.data;\n}\nfunction copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {\n    if (size.width === 0 || size.height === 0) {\n        return dstImg;\n    }\n    if (size.width > srcImg.width ||\n        size.height > srcImg.height ||\n        srcPt.x > srcImg.width - size.width ||\n        srcPt.y > srcImg.height - size.height) {\n        throw new RangeError('out of range source coordinates for image copy');\n    }\n    if (size.width > dstImg.width ||\n        size.height > dstImg.height ||\n        dstPt.x > dstImg.width - size.width ||\n        dstPt.y > dstImg.height - size.height) {\n        throw new RangeError('out of range destination coordinates for image copy');\n    }\n    var srcData = srcImg.data;\n    var dstData = dstImg.data;\n    for (var y = 0; y < size.height; y++) {\n        var srcOffset = ((srcPt.y + y) * srcImg.width + srcPt.x) * channels;\n        var dstOffset = ((dstPt.y + y) * dstImg.width + dstPt.x) * channels;\n        for (var i = 0; i < size.width * channels; i++) {\n            dstData[dstOffset + i] = srcData[srcOffset + i];\n        }\n    }\n    return dstImg;\n}\nvar AlphaImage = /** @class */ (function () {\n    function AlphaImage(size, data) {\n        createImage(this, size, 1, data);\n    }\n    AlphaImage.prototype.resize = function (size) {\n        resizeImage(this, size, 1);\n    };\n    AlphaImage.prototype.clone = function () {\n        return new AlphaImage({ width: this.width, height: this.height }, new Uint8Array(this.data));\n    };\n    AlphaImage.copy = function (srcImg, dstImg, srcPt, dstPt, size) {\n        copyImage(srcImg, dstImg, srcPt, dstPt, size, 1);\n    };\n    return AlphaImage;\n}());\n\n// borrow from https://github.com/mapbox/potpack/blob/master/index.mjs\n// @see https://github.com/antvis/g/issues/836\nfunction potpack(boxes) {\n    var e_1, _a, e_2, _b;\n    // calculate total box area and maximum box width\n    var area = 0;\n    var maxWidth = 0;\n    try {\n        for (var boxes_1 = tslib.__values(boxes), boxes_1_1 = boxes_1.next(); !boxes_1_1.done; boxes_1_1 = boxes_1.next()) {\n            var box = boxes_1_1.value;\n            area += box.w * box.h;\n            maxWidth = Math.max(maxWidth, box.w);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (boxes_1_1 && !boxes_1_1.done && (_a = boxes_1.return)) _a.call(boxes_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // sort the boxes for insertion by height, descending\n    boxes.sort(function (a, b) { return b.h - a.h; });\n    // aim for a squarish resulting container,\n    // slightly adjusted for sub-100% space utilization\n    var startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);\n    // start with a single empty space, unbounded at the bottom\n    var spaces = [{ x: 0, y: 0, w: startWidth, h: Infinity }];\n    var width = 0;\n    var height = 0;\n    try {\n        for (var boxes_2 = tslib.__values(boxes), boxes_2_1 = boxes_2.next(); !boxes_2_1.done; boxes_2_1 = boxes_2.next()) {\n            var box = boxes_2_1.value;\n            // look through spaces backwards so that we check smaller spaces first\n            for (var i = spaces.length - 1; i >= 0; i--) {\n                var space = spaces[i];\n                // look for empty spaces that can accommodate the current box\n                if (box.w > space.w || box.h > space.h)\n                    continue;\n                // found the space; add the box to its top-left corner\n                // |-------|-------|\n                // |  box  |       |\n                // |_______|       |\n                // |         space |\n                // |_______________|\n                box.x = space.x;\n                box.y = space.y;\n                height = Math.max(height, box.y + box.h);\n                width = Math.max(width, box.x + box.w);\n                if (box.w === space.w && box.h === space.h) {\n                    // space matches the box exactly; remove it\n                    var last = spaces.pop();\n                    if (i < spaces.length)\n                        spaces[i] = last;\n                }\n                else if (box.h === space.h) {\n                    // space matches the box height; update it accordingly\n                    // |-------|---------------|\n                    // |  box  | updated space |\n                    // |_______|_______________|\n                    space.x += box.w;\n                    space.w -= box.w;\n                }\n                else if (box.w === space.w) {\n                    // space matches the box width; update it accordingly\n                    // |---------------|\n                    // |      box      |\n                    // |_______________|\n                    // | updated space |\n                    // |_______________|\n                    space.y += box.h;\n                    space.h -= box.h;\n                }\n                else {\n                    // otherwise the box splits the space into two spaces\n                    // |-------|-----------|\n                    // |  box  | new space |\n                    // |_______|___________|\n                    // | updated space     |\n                    // |___________________|\n                    spaces.push({\n                        x: space.x + box.w,\n                        y: space.y,\n                        w: space.w - box.w,\n                        h: box.h,\n                    });\n                    space.y += box.h;\n                    space.h -= box.h;\n                }\n                break;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (boxes_2_1 && !boxes_2_1.done && (_b = boxes_2.return)) _b.call(boxes_2);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return {\n        w: width, // container width\n        h: height, // container height\n        fill: area / (width * height) || 0, // space utilization\n    };\n}\nvar padding = 1;\n/**\n * Merge SDFs into a large squared atlas with `potpack`,\n * because on WebGL1 context, all textures are resized to a power of two to produce the best quality.\n *\n * @see https://doc.babylonjs.com/advanced_topics/webGL2#power-of-two-textures\n */\nvar GlyphAtlas = /** @class */ (function () {\n    function GlyphAtlas(stacks) {\n        var positions = {};\n        var bins = [];\n        for (var stack in stacks) {\n            var glyphs = stacks[stack];\n            // @ts-ignore\n            var stackPositions = (positions[stack] = {});\n            for (var id in glyphs) {\n                var src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0)\n                    continue;\n                var bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding,\n                };\n                bins.push(bin);\n                // @ts-ignore\n                stackPositions[id] = { rect: bin, metrics: src.metrics };\n            }\n        }\n        var _a = potpack(bins), w = _a.w, h = _a.h;\n        var image = new AlphaImage({ width: w || 1, height: h || 1 });\n        for (var stack in stacks) {\n            var glyphs = stacks[stack];\n            for (var id in glyphs) {\n                var src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0)\n                    continue;\n                // @ts-ignore\n                var bin = positions[stack][id].rect;\n                AlphaImage.copy(src.bitmap, image, { x: 0, y: 0 }, { x: bin.x + padding, y: bin.y + padding }, src.bitmap);\n            }\n        }\n        this.image = image;\n        this.positions = positions;\n    }\n    return GlyphAtlas;\n}());\n\nvar BASE_FONT_WIDTH = 24;\nvar BASE_FONT_BUFFER = 3;\nvar fontSize = BASE_FONT_WIDTH; // Font size in pixels\nvar buffer = BASE_FONT_BUFFER; // Whitespace buffer around a glyph in pixels\nvar radius = 8; // How many pixels around the glyph shape to use for encoding distance\nvar cutoff = 0.25; // How much of the radius (relative) is used for the inside part the glyph\nfunction getDefaultCharacterSet() {\n    var charSet = [];\n    for (var i = 32; i < 128; i++) {\n        charSet.push(String.fromCharCode(i));\n    }\n    return charSet;\n}\n/**\n * TODO: use one atlas for all fontstacks, each fontstack has one texture now\n */\nvar GlyphManager = /** @class */ (function () {\n    function GlyphManager(runtime) {\n        this.runtime = runtime;\n        this.sdfGeneratorCache = {};\n        this.textMetricsCache = {};\n        this.glyphMap = {};\n    }\n    GlyphManager.prototype.getMap = function () {\n        return this.glyphMap;\n    };\n    GlyphManager.prototype.getAtlas = function () {\n        return this.glyphAtlas;\n    };\n    GlyphManager.prototype.getAtlasTexture = function () {\n        return this.glyphAtlasTexture;\n    };\n    GlyphManager.prototype.layout = function (lines, fontStack, lineHeight, textAlign, letterSpacing, offsetX, offsetY) {\n        var _this = this;\n        var positionedGlyphs = [];\n        var x = offsetX;\n        var y = offsetY;\n        var justify = textAlign === 'right' || textAlign === 'end'\n            ? 1\n            : textAlign === 'left' || textAlign === 'start'\n                ? 0\n                : 0.5;\n        lines.forEach(function (line) {\n            var lineStartIndex = positionedGlyphs.length;\n            Array.from(line).forEach(function (char) {\n                // fontStack\n                var positions = _this.glyphMap[fontStack];\n                var charCode = char.charCodeAt(0);\n                var glyph = positions && positions[charCode];\n                if (glyph) {\n                    positionedGlyphs.push({\n                        glyph: charCode,\n                        x: x,\n                        y: y,\n                        scale: 1,\n                        fontStack: fontStack,\n                    });\n                    x += glyph.metrics.advance + letterSpacing;\n                }\n            });\n            var lineWidth = x - letterSpacing;\n            for (var i = lineStartIndex; i < positionedGlyphs.length; i++) {\n                positionedGlyphs[i].x = positionedGlyphs[i].x - justify * lineWidth;\n            }\n            x = 0;\n            y += lineHeight;\n        });\n        return positionedGlyphs;\n    };\n    GlyphManager.prototype.generateAtlas = function (canvas, fontStack, fontFamily, fontWeight, fontStyle, text, device) {\n        var _this = this;\n        if (fontStack === void 0) { fontStack = ''; }\n        if (fontStyle === void 0) { fontStyle = ''; }\n        var newChars = [];\n        if (!this.glyphMap[fontStack]) {\n            newChars = getDefaultCharacterSet();\n        }\n        var existedChars = Object.keys(this.glyphMap[fontStack] || {});\n        Array.from(new Set(text.split(''))).forEach(function (char) {\n            if (existedChars.indexOf(char.charCodeAt(0).toString()) === -1) {\n                newChars.push(char);\n            }\n        });\n        if (newChars.length) {\n            var glyphMap = newChars\n                .map(function (char) {\n                return _this.generateSDF(canvas, fontStack, fontFamily, fontWeight, fontStyle, char);\n            })\n                .reduce(function (prev, cur) {\n                // @ts-ignore\n                prev[cur.id] = cur;\n                return prev;\n            }, {});\n            this.glyphMap[fontStack] = tslib.__assign(tslib.__assign({}, this.glyphMap[fontStack]), glyphMap);\n            this.glyphAtlas = new GlyphAtlas(this.glyphMap);\n            var _a = this.glyphAtlas.image, atlasWidth = _a.width, atlasHeight = _a.height, data = _a.data;\n            if (this.glyphAtlasTexture) {\n                this.glyphAtlasTexture.destroy();\n            }\n            this.glyphAtlasTexture = device.createTexture(tslib.__assign(tslib.__assign({}, gDeviceApi.makeTextureDescriptor2D(gDeviceApi.Format.ALPHA, atlasWidth, atlasHeight, 1)), { pixelStore: {\n                    unpackFlipY: false,\n                    unpackAlignment: 1,\n                } }));\n            this.glyphAtlasTexture.setImageData([data]);\n        }\n    };\n    GlyphManager.prototype.generateSDF = function (canvas, fontStack, fontFamily, fontWeight, fontStyle, char) {\n        if (fontStack === void 0) { fontStack = ''; }\n        var charCode = char.charCodeAt(0);\n        var sdfGenerator = this.sdfGeneratorCache[fontStack];\n        if (!sdfGenerator) {\n            //  SDF\n            sdfGenerator = this.sdfGeneratorCache[fontStack] =\n                // TODO: use OffscreenCanvas in TextService\n                new TinySDF({\n                    canvas: canvas,\n                    fontSize: fontSize,\n                    fontFamily: fontFamily,\n                    fontWeight: fontWeight,\n                    fontStyle: fontStyle,\n                    buffer: buffer,\n                    radius: radius,\n                    cutoff: cutoff,\n                }, this.runtime);\n        }\n        if (!this.textMetricsCache[fontStack]) {\n            this.textMetricsCache[fontStack] = {};\n        }\n        if (!this.textMetricsCache[fontStack][char]) {\n            //  mapbox/tiny-sdf  context\n            // @see https://stackoverflow.com/questions/46126565/how-to-get-font-glyphs-metrics-details-in-javascript\n            this.textMetricsCache[fontStack][char] =\n                // @ts-ignore\n                sdfGenerator.ctx.measureText(char).width;\n        }\n        // use sdf 2.x @see https://github.com/mapbox/tiny-sdf\n        var _a = sdfGenerator.draw(char), data = _a.data, width = _a.width, height = _a.height, glyphWidth = _a.glyphWidth, glyphHeight = _a.glyphHeight, glyphLeft = _a.glyphLeft, glyphTop = _a.glyphTop, glyphAdvance = _a.glyphAdvance;\n        return {\n            id: charCode,\n            //  canvas  Uint8Array  30*30 sdf \n            bitmap: new AlphaImage({\n                width: width,\n                height: height,\n            }, data),\n            metrics: {\n                width: glyphWidth,\n                height: glyphHeight,\n                left: glyphLeft,\n                top: glyphTop - BASE_FONT_WIDTH + BASE_FONT_BUFFER,\n                advance: glyphAdvance,\n            },\n        };\n    };\n    return GlyphManager;\n}());\n\n/**\n * Create the quads used for rendering a text label.\n */\nfunction getGlyphQuads(positionedGlyphs, positions) {\n    var quads = [];\n    for (var k = 0; k < positionedGlyphs.length; k++) {\n        var positionedGlyph = positionedGlyphs[k];\n        var glyphPositions = positions[positionedGlyph.fontStack];\n        var glyph = glyphPositions && glyphPositions[positionedGlyph.glyph];\n        if (!glyph)\n            continue;\n        var rect = glyph.rect;\n        if (!rect)\n            continue;\n        // The rects have an addditional buffer that is not included in their size.\n        var glyphPadding = 1.0;\n        // const glyphPadding = 0.0;\n        var rectBuffer = BASE_FONT_BUFFER + glyphPadding;\n        var halfAdvance = (glyph.metrics.advance * positionedGlyph.scale) / 2;\n        var glyphOffset = [0, 0];\n        var builtInOffset = [positionedGlyph.x + halfAdvance, positionedGlyph.y];\n        var x1 = (glyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n        var y1 = (-glyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n        var x2 = x1 + rect.w * positionedGlyph.scale;\n        var y2 = y1 + rect.h * positionedGlyph.scale;\n        var tl = { x: x1, y: y1 };\n        var tr = { x: x2, y: y1 };\n        var bl = { x: x1, y: y2 };\n        var br = { x: x2, y: y2 };\n        quads.push({ tl: tl, tr: tr, bl: bl, br: br, tex: rect, glyphOffset: glyphOffset });\n    }\n    return quads;\n}\n\nvar TextVertexAttributeBufferIndex;\n(function (TextVertexAttributeBufferIndex) {\n    TextVertexAttributeBufferIndex[TextVertexAttributeBufferIndex[\"INSTANCED\"] = 5] = \"INSTANCED\";\n    TextVertexAttributeBufferIndex[TextVertexAttributeBufferIndex[\"TEX\"] = 6] = \"TEX\";\n})(TextVertexAttributeBufferIndex || (TextVertexAttributeBufferIndex = {}));\nvar TextVertexAttributeLocation;\n(function (TextVertexAttributeLocation) {\n    TextVertexAttributeLocation[TextVertexAttributeLocation[\"TEX\"] = 12] = \"TEX\";\n    TextVertexAttributeLocation[TextVertexAttributeLocation[\"OFFSET\"] = 13] = \"OFFSET\";\n})(TextVertexAttributeLocation || (TextVertexAttributeLocation = {}));\nexports.TextUniform = void 0;\n(function (TextUniform) {\n    TextUniform[\"SDF_MAP\"] = \"u_SDFMap\";\n    TextUniform[\"SDF_MAP_SIZE\"] = \"u_SDFMapSize\";\n    TextUniform[\"FONT_SIZE\"] = \"u_FontSize\";\n    TextUniform[\"GAMMA_SCALE\"] = \"u_GammaScale\";\n    TextUniform[\"STROKE_BLUR\"] = \"u_StrokeBlur\";\n    TextUniform[\"HAS_STROKE\"] = \"u_HasStroke\";\n})(exports.TextUniform || (exports.TextUniform = {}));\nvar TextDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(TextDrawcall, _super);\n    function TextDrawcall(renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) {\n        var _this = _super.call(this, renderHelper, texturePool, lightPool, object, drawcallCtors, index, context) || this;\n        _this.renderHelper = renderHelper;\n        _this.texturePool = texturePool;\n        _this.lightPool = lightPool;\n        _this.packedBufferObjectMap = new WeakMap();\n        _this.tmpMat4 = glMatrix.mat4.create();\n        _this.fontHash = _this.calcFontHash(object);\n        _this.glyphManager = new GlyphManager(_this.context);\n        return _this;\n    }\n    TextDrawcall.prototype.calcFontHash = function (object) {\n        var instancedAttributes = [\n            'fontSize',\n            'fontFamily',\n            'fontWeight',\n            'textBaseline',\n            'letterSpacing',\n        ];\n        return (object.parsedStyle.metrics.font +\n            instancedAttributes.reduce(function (prev, cur) {\n                return prev + object.parsedStyle[cur];\n            }, ''));\n    };\n    TextDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        if (this.index !== index) {\n            return false;\n        }\n        return this.fontHash === this.calcFontHash(object);\n    };\n    TextDrawcall.prototype.createGeometry = function (objects) {\n        var _this = this;\n        var object = this.instance;\n        var _a = object.parsedStyle, textBaseline = _a.textBaseline, fontSize = _a.fontSize, letterSpacing = _a.letterSpacing;\n        // scale current font size to base(24)\n        var fontScale = BASE_FONT_WIDTH / fontSize;\n        var indices = [];\n        var uvOffsets = [];\n        var packed = [];\n        var indicesOff = 0;\n        objects.forEach(function (object) {\n            var _a = object.parsedStyle, metrics = _a.metrics, dx = _a.dx, dy = _a.dy;\n            var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight;\n            // account for dx & dy\n            var offsetX = dx || 0;\n            var offsetY = dy || 0;\n            var linePositionY = 0;\n            // handle vertical text baseline\n            if (textBaseline === 'middle') {\n                linePositionY = -height / 2;\n            }\n            else if (textBaseline === 'bottom') {\n                linePositionY = -height;\n            }\n            else if (textBaseline === 'top' || textBaseline === 'hanging') {\n                linePositionY = 0;\n            }\n            else if (textBaseline === 'alphabetic') {\n                linePositionY = -height + lineHeight * 0.25;\n                if (!_this.context.enableCSSParsing) {\n                    linePositionY = -height;\n                }\n                // linePositionY = -height + fontProperties.ascent;\n            }\n            else if (textBaseline === 'ideographic') {\n                linePositionY = -height;\n            }\n            var glyphAtlas = _this.glyphManager.getAtlas();\n            var _b = _this.buildTextBuffers({\n                object: object,\n                lines: lines,\n                fontStack: font,\n                lineHeight: fontScale * lineHeight,\n                offsetX: fontScale * offsetX,\n                offsetY: fontScale * (linePositionY + offsetY),\n                letterSpacing: fontScale * letterSpacing,\n                glyphAtlas: glyphAtlas,\n                indicesOffset: indicesOff,\n            }), indicesOffset = _b.indicesOffset, indexBuffer = _b.indexBuffer, charUVOffsetBuffer = _b.charUVOffsetBuffer, charPackedBuffer = _b.charPackedBuffer;\n            indicesOff = indicesOffset;\n            var start = packed.length;\n            packed.push.apply(packed, tslib.__spreadArray([], tslib.__read(charPackedBuffer), false));\n            var end = packed.length;\n            _this.packedBufferObjectMap.set(object, [start, end]);\n            uvOffsets.push.apply(uvOffsets, tslib.__spreadArray([], tslib.__read(charUVOffsetBuffer), false));\n            indices.push.apply(indices, tslib.__spreadArray([], tslib.__read(indexBuffer), false));\n        });\n        this.geometry.vertexCount = indices.length;\n        this.geometry.setIndexBuffer(new Uint32Array(indices));\n        this.geometry.setVertexBuffer({\n            bufferIndex: TextVertexAttributeBufferIndex.INSTANCED,\n            byteStride: 4 * (4 * 4 + 4 + 4 + 4 + 4), // 32\n            stepMode: gDeviceApi.VertexStepMode.VERTEX,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 0,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX0,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 4,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX1,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 8,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX2,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 12,\n                    location: exports.VertexAttributeLocation.MODEL_MATRIX3,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 16,\n                    location: exports.VertexAttributeLocation.PACKED_COLOR,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 20,\n                    location: exports.VertexAttributeLocation.PACKED_STYLE1,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 24,\n                    location: exports.VertexAttributeLocation.PACKED_STYLE2,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RGBA,\n                    bufferByteOffset: 4 * 28,\n                    location: exports.VertexAttributeLocation.PICKING_COLOR,\n                },\n            ],\n            data: new Float32Array(packed),\n        });\n        this.geometry.setVertexBuffer({\n            bufferIndex: TextVertexAttributeBufferIndex.TEX,\n            byteStride: 4 * (2 + 2),\n            stepMode: gDeviceApi.VertexStepMode.VERTEX,\n            attributes: [\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 0,\n                    location: TextVertexAttributeLocation.TEX,\n                },\n                {\n                    format: gDeviceApi.Format.F32_RG,\n                    bufferByteOffset: 4 * 2,\n                    location: TextVertexAttributeLocation.OFFSET,\n                },\n            ],\n            data: new Float32Array(uvOffsets),\n        });\n    };\n    TextDrawcall.prototype.createMaterial = function (objects) {\n        var _a;\n        this.material.vertexShader = vert;\n        this.material.fragmentShader = frag;\n        this.material.cullMode = gDeviceApi.CullMode.BACK;\n        this.material.defines = tslib.__assign(tslib.__assign({}, this.material.defines), enumToObject(TextVertexAttributeLocation));\n        var object = this.instance;\n        var _b = object.parsedStyle, fontSize = _b.fontSize, _c = _b.fontFamily, fontFamily = _c === void 0 ? '' : _c, _d = _b.fontWeight, fontWeight = _d === void 0 ? '' : _d, fontStyle = _b.fontStyle, metrics = _b.metrics;\n        var font = metrics.font;\n        var allText = objects.map(function (object) { return object.parsedStyle.text; }).join('');\n        this.glyphManager.generateAtlas(this.texturePool.context.config.offscreenCanvas, font, fontFamily, fontWeight.toString(), fontStyle, allText, this.context.device);\n        var glyphAtlasTexture = this.glyphManager.getAtlasTexture();\n        var glyphAtlas = this.glyphManager.getAtlas();\n        this.context.device.setResourceName(glyphAtlasTexture, 'TextSDF Texture');\n        var _e = glyphAtlas.image, atlasWidth = _e.width, atlasHeight = _e.height;\n        this.material.setUniforms((_a = {},\n            _a[exports.TextUniform.SDF_MAP] = glyphAtlasTexture,\n            _a[exports.TextUniform.SDF_MAP_SIZE] = [atlasWidth, atlasHeight],\n            _a[exports.TextUniform.FONT_SIZE] = fontSize,\n            _a[exports.TextUniform.GAMMA_SCALE] = 1,\n            _a[exports.TextUniform.STROKE_BLUR] = 0.2,\n            _a[exports.TextUniform.HAS_STROKE] = this.index,\n            _a));\n    };\n    TextDrawcall.prototype.changeRenderOrder = function (object, renderOrder) {\n        var vertice = this.geometry.vertices[TextVertexAttributeBufferIndex.INSTANCED];\n        var arrayStride = this.geometry.inputLayoutDescriptor.vertexBufferDescriptors[TextVertexAttributeBufferIndex.INSTANCED].arrayStride;\n        var bytes = arrayStride / 4;\n        var _a = tslib.__read(this.packedBufferObjectMap.get(object), 2), start = _a[0], end = _a[1];\n        var sliced = vertice.slice(start, end);\n        for (var i = 0; i < end - start; i += bytes) {\n            sliced[i + bytes - 1] = renderOrder * RENDER_ORDER_SCALE;\n        }\n        this.geometry.updateVertexBuffer(TextVertexAttributeBufferIndex.INSTANCED, exports.VertexAttributeLocation.MODEL_MATRIX0, start / bytes, new Uint8Array(sliced.buffer));\n    };\n    TextDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        var _this = this;\n        if (name === 'text' ||\n            name === 'fontFamily' ||\n            name === 'fontSize' ||\n            name === 'fontWeight' ||\n            name === 'fontStyle' ||\n            name === 'fontVariant' ||\n            name === 'textBaseline' ||\n            name === 'letterSpacing' ||\n            name === 'wordWrapWidth' ||\n            name === 'lineHeight' ||\n            name === 'wordWrap' ||\n            name === 'textAlign' ||\n            name === 'dx' ||\n            name === 'dy') {\n            this.material.programDirty = true;\n            this.material.geometryDirty = true;\n            // need re-upload SDF texture\n            this.material.textureDirty = true;\n        }\n        else if (name === 'modelMatrix' ||\n            name === 'fill' ||\n            name === 'fillOpacity' ||\n            name === 'stroke' ||\n            name === 'strokeOpacity' ||\n            name === 'opacity' ||\n            name === 'lineWidth' ||\n            name === 'visibility' ||\n            name === 'pointerEvents' ||\n            name === 'isBillboard' ||\n            name === 'billboardRotation' ||\n            name === 'isSizeAttenuation') {\n            var vertice_1 = this.geometry.vertices[TextVertexAttributeBufferIndex.INSTANCED];\n            var arrayStride = this.geometry.inputLayoutDescriptor.vertexBufferDescriptors[TextVertexAttributeBufferIndex.INSTANCED].arrayStride;\n            var bytes_1 = arrayStride / 4;\n            objects.forEach(function (object) {\n                var _a;\n                var _b = object.parsedStyle, fill = _b.fill, stroke = _b.stroke, opacity = _b.opacity, fillOpacity = _b.fillOpacity, strokeOpacity = _b.strokeOpacity, lineWidth = _b.lineWidth, visibility = _b.visibility, isBillboard = _b.isBillboard, billboardRotation = _b.billboardRotation, isSizeAttenuation = _b.isSizeAttenuation;\n                var fillColor = [0, 0, 0, 0];\n                if (gLite.isCSSRGB(fill)) {\n                    fillColor = [\n                        Number(fill.r),\n                        Number(fill.g),\n                        Number(fill.b),\n                        Number(fill.alpha) * 255,\n                    ];\n                }\n                var strokeColor = [0, 0, 0, 0];\n                if (gLite.isCSSRGB(stroke)) {\n                    strokeColor = [\n                        Number(stroke.r),\n                        Number(stroke.g),\n                        Number(stroke.b),\n                        Number(stroke.alpha) * 255,\n                    ];\n                }\n                var encodedPickingColor = (object.isInteractive() &&\n                    (\n                    // @ts-ignore\n                    (_a = object.renderable3D) === null || _a === void 0 ? void 0 : _a.encodedPickingColor)) || [0, 0, 0];\n                var modelMatrix = glMatrix.mat4.copy(_this.tmpMat4, object.getWorldTransform());\n                var _c = tslib.__read(_this.packedBufferObjectMap.get(object), 2), start = _c[0], end = _c[1];\n                var sliced = vertice_1.slice(start, end);\n                for (var i = 0; i < end - start; i += bytes_1) {\n                    // if (name === 'modelMatrix') {\n                    sliced[i + 0] = modelMatrix[0];\n                    sliced[i + 1] = modelMatrix[1];\n                    sliced[i + 2] = modelMatrix[2];\n                    sliced[i + 3] = modelMatrix[3];\n                    sliced[i + 4] = modelMatrix[4];\n                    sliced[i + 5] = modelMatrix[5];\n                    sliced[i + 6] = modelMatrix[6];\n                    sliced[i + 7] = modelMatrix[7];\n                    sliced[i + 8] = modelMatrix[8];\n                    sliced[i + 9] = modelMatrix[9];\n                    sliced[i + 10] = modelMatrix[10];\n                    sliced[i + 11] = modelMatrix[11];\n                    sliced[i + 12] = modelMatrix[12];\n                    sliced[i + 13] = modelMatrix[13];\n                    sliced[i + 14] = modelMatrix[14];\n                    sliced[i + 15] = modelMatrix[15];\n                    // } else if (name === 'fill') {\n                    sliced[i + 16] = packUint8ToFloat(fillColor[0], fillColor[1]);\n                    sliced[i + 17] = packUint8ToFloat(fillColor[2], fillColor[3]);\n                    // } else if (name === 'stroke') {\n                    sliced[i + 18] = packUint8ToFloat(strokeColor[0], strokeColor[1]);\n                    sliced[i + 19] = packUint8ToFloat(strokeColor[2], strokeColor[3]);\n                    // }\n                    sliced[i + 20] = opacity;\n                    sliced[i + 21] = fillOpacity;\n                    sliced[i + 22] = strokeOpacity;\n                    sliced[i + 23] = lineWidth;\n                    sliced[i + 24] = visibility === 'visible' ? 1 : 0;\n                    sliced[i + 25] = isBillboard ? 1 : 0;\n                    sliced[i + 26] = isSizeAttenuation ? 1 : 0;\n                    sliced[i + 27] = billboardRotation !== null && billboardRotation !== void 0 ? billboardRotation : 0;\n                    sliced[i + 28] = encodedPickingColor[0];\n                    sliced[i + 29] = encodedPickingColor[1];\n                    sliced[i + 30] = encodedPickingColor[2];\n                    // sliced[i + 31] = object.sortable.renderOrder * RENDER_ORDER_SCALE;\n                }\n                _this.geometry.updateVertexBuffer(TextVertexAttributeBufferIndex.INSTANCED, exports.VertexAttributeLocation.MODEL_MATRIX0, start / bytes_1, new Uint8Array(sliced.buffer));\n            });\n        }\n    };\n    TextDrawcall.prototype.buildTextBuffers = function (_a) {\n        var _b;\n        var object = _a.object, lines = _a.lines, fontStack = _a.fontStack, lineHeight = _a.lineHeight, letterSpacing = _a.letterSpacing, offsetX = _a.offsetX, offsetY = _a.offsetY, glyphAtlas = _a.glyphAtlas, indicesOffset = _a.indicesOffset;\n        var _c = object.parsedStyle, textAlign = _c.textAlign, fill = _c.fill, stroke = _c.stroke, opacity = _c.opacity, fillOpacity = _c.fillOpacity, strokeOpacity = _c.strokeOpacity, lineWidth = _c.lineWidth, visibility = _c.visibility, isBillboard = _c.isBillboard, billboardRotation = _c.billboardRotation, isSizeAttenuation = _c.isSizeAttenuation;\n        var fillColor = [0, 0, 0, 0];\n        if (gLite.isCSSRGB(fill)) {\n            fillColor = [\n                Number(fill.r),\n                Number(fill.g),\n                Number(fill.b),\n                Number(fill.alpha) * 255,\n            ];\n        }\n        var strokeColor = [0, 0, 0, 0];\n        if (gLite.isCSSRGB(stroke)) {\n            strokeColor = [\n                Number(stroke.r),\n                Number(stroke.g),\n                Number(stroke.b),\n                Number(stroke.alpha) * 255,\n            ];\n        }\n        var encodedPickingColor = (object.isInteractive() &&\n            (\n            // @ts-ignore\n            (_b = object.renderable3D) === null || _b === void 0 ? void 0 : _b.encodedPickingColor)) || [0, 0, 0];\n        var modelMatrix = glMatrix.mat4.copy(this.tmpMat4, object.getWorldTransform());\n        var charPackedBuffer = [];\n        var charUVOffsetBuffer = [];\n        var indexBuffer = [];\n        var i = indicesOffset;\n        var positionedGlyphs = this.glyphManager.layout(lines, fontStack, lineHeight, textAlign, letterSpacing, offsetX, offsetY);\n        // \n        var glyphQuads = getGlyphQuads(positionedGlyphs, glyphAtlas.positions);\n        glyphQuads.forEach(function (quad) {\n            // rollup will use `concat`\n            var temp = [];\n            temp.push.apply(temp, tslib.__spreadArray([], tslib.__read(modelMatrix), false));\n            var packed = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(temp), false), [\n                packUint8ToFloat(fillColor[0], fillColor[1]),\n                packUint8ToFloat(fillColor[2], fillColor[3]),\n                packUint8ToFloat(strokeColor[0], strokeColor[1]),\n                packUint8ToFloat(strokeColor[2], strokeColor[3]),\n                opacity,\n                fillOpacity,\n                strokeOpacity,\n                lineWidth,\n                visibility === 'visible' ? 1 : 0,\n                isBillboard ? 1 : 0,\n                isSizeAttenuation ? 1 : 0,\n                billboardRotation !== null && billboardRotation !== void 0 ? billboardRotation : 0\n            ], false), tslib.__read(encodedPickingColor), false), [\n                object.sortable.renderOrder * RENDER_ORDER_SCALE,\n            ], false);\n            // Can't use instanced here since the total number of each Text can be different.\n            charPackedBuffer.push.apply(charPackedBuffer, tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(packed), false), tslib.__read(packed), false), tslib.__read(packed), false), tslib.__read(packed), false));\n            // interleaved uv & offsets\n            charUVOffsetBuffer.push(quad.tex.x, quad.tex.y, quad.tl.x, quad.tl.y);\n            charUVOffsetBuffer.push(quad.tex.x + quad.tex.w, quad.tex.y, quad.tr.x, quad.tr.y);\n            charUVOffsetBuffer.push(quad.tex.x + quad.tex.w, quad.tex.y + quad.tex.h, quad.br.x, quad.br.y);\n            charUVOffsetBuffer.push(quad.tex.x, quad.tex.y + quad.tex.h, quad.bl.x, quad.bl.y);\n            indexBuffer.push(0 + i, 2 + i, 1 + i);\n            indexBuffer.push(2 + i, 0 + i, 3 + i);\n            i += 4;\n        });\n        return {\n            indexBuffer: indexBuffer,\n            charUVOffsetBuffer: charUVOffsetBuffer,\n            charPackedBuffer: charPackedBuffer,\n            indicesOffset: i,\n        };\n    };\n    return TextDrawcall;\n}(Instanced));\n\nvar MeshDrawcall = /** @class */ (function (_super) {\n    tslib.__extends(MeshDrawcall, _super);\n    function MeshDrawcall() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MeshDrawcall.prototype.shouldMerge = function (object, index) {\n        var shouldMerge = _super.prototype.shouldMerge.call(this, object, index);\n        if (!shouldMerge) {\n            return false;\n        }\n        if (this.instance.nodeName === gLite.Shape.MESH) {\n            if (this.instance.parsedStyle.material !== object.parsedStyle.material ||\n                this.instance.parsedStyle.geometry !== object.parsedStyle.geometry) {\n                return false;\n            }\n        }\n        return true;\n    };\n    MeshDrawcall.prototype.updateAttribute = function (objects, startIndex, name, value) {\n        _super.prototype.updateAttribute.call(this, objects, startIndex, name, value);\n        this.updateBatchedAttribute(objects, startIndex, name, value);\n    };\n    MeshDrawcall.prototype.createMaterial = function (objects) {\n        var material = this.instance.parsedStyle.material;\n        this.material = material;\n        this.observeMaterialChanged();\n    };\n    MeshDrawcall.prototype.createGeometry = function (objects) {\n        var geometry = this.instance.parsedStyle.geometry;\n        this.geometry = geometry;\n        // use default common attributes\n        _super.prototype.createGeometry.call(this, objects);\n        this.geometry.build(objects);\n        // TODO: clear dirty listener\n        this.observeGeometryChanged();\n    };\n    return MeshDrawcall;\n}(Instanced));\n\n/**\n * Use 2 meshes:\n * * SDF to draw fill & simple stroke if needed.\n * * InstancedPathDrawcall to draw stroke separately.\n */\nvar CircleRenderer = /** @class */ (function (_super) {\n    tslib.__extends(CircleRenderer, _super);\n    function CircleRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CircleRenderer.prototype.getDrawcallCtors = function (object) {\n        var drawcalls = [];\n        var fill = object.parsedStyle.fill;\n        if (!fill.isNone) {\n            drawcalls.push(SDFDrawcall);\n        }\n        if (this.needDrawStrokeSeparately(object)) {\n            drawcalls.push(InstancedPathDrawcall);\n        }\n        return drawcalls;\n    };\n    /**\n     * need an additional mesh to draw stroke:\n     * 1. strokeOpacity < 1\n     * 2. lineDash used\n     * 3. stroke is not 'none'\n     */\n    CircleRenderer.prototype.needDrawStrokeSeparately = function (object) {\n        var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke, lineDash = _a.lineDash, lineWidth = _a.lineWidth, strokeOpacity = _a.strokeOpacity;\n        var hasFill = fill && !fill.isNone;\n        var hasStroke = stroke && !stroke.isNone;\n        var hasDash = lineDash &&\n            lineDash.length &&\n            lineDash.every(function (item) { return item !== 0; });\n        return (!hasFill || (hasStroke && lineWidth > 0 && (strokeOpacity < 1 || hasDash)));\n    };\n    return CircleRenderer;\n}(Batch));\n\n/**\n * Use the following perf enhancements:\n * * Downgrading the \"simple\" Path / Polyline to {@link InstancedLineDrawcall}, e.g. 'M 0 0 L 100 0'\n * * Merge the Path into {@link InstancedPathDrawcall} which contains only one curve command, e.g 'M 0 0 Q 10 10 100 100'\n * @see https://github.com/antvis/G/issues/1113\n */\nvar PathRenderer = /** @class */ (function (_super) {\n    tslib.__extends(PathRenderer, _super);\n    function PathRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // meshes = [\n    //   InstancedFillDrawcall ?,\n    //   (InstancedLineDrawcall | InstancedPathDrawcall) *, // sub paths\n    // ];\n    PathRenderer.prototype.getDrawcallCtors = function (object) {\n        var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, lineWidth = _a.lineWidth;\n        var hasStroke = stroke && !stroke.isNone;\n        var subpathNum = InstancedPathDrawcall.calcSubpathNum(object);\n        var drawcalls = [];\n        // Polyline don't need fill\n        if (!(object.nodeName === gLite.Shape.POLYLINE || fill.isNone)) {\n            for (var i = 0; i < subpathNum; i++) {\n                drawcalls.push(InstancedFillDrawcall);\n            }\n        }\n        for (var i = 0; i < subpathNum; i++) {\n            if (!(strokeOpacity === 0 || opacity === 0 || lineWidth === 0 || !hasStroke)) {\n                var isLine = InstancedLineDrawcall.isLine(object, i);\n                if (isLine) {\n                    drawcalls.push(InstancedLineDrawcall);\n                }\n                else {\n                    drawcalls.push(InstancedPathDrawcall);\n                }\n            }\n        }\n        return drawcalls;\n    };\n    return PathRenderer;\n}(Batch));\n\n/** @class */ ((function (_super) {\n    tslib.__extends(GroupRenderer, _super);\n    function GroupRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    GroupRenderer.prototype.getDrawcallCtors = function () {\n        return [];\n    };\n    return GroupRenderer;\n})(Batch));\n\nvar ImageRenderer = /** @class */ (function (_super) {\n    tslib.__extends(ImageRenderer, _super);\n    function ImageRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImageRenderer.prototype.getDrawcallCtors = function () {\n        return [ImageDrawcall];\n    };\n    return ImageRenderer;\n}(Batch));\n\nvar TextRenderer = /** @class */ (function (_super) {\n    tslib.__extends(TextRenderer, _super);\n    function TextRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * one for fill, one for stroke\n     */\n    TextRenderer.prototype.getDrawcallCtors = function (object) {\n        var drawcalls = [];\n        var _a = object.parsedStyle, stroke = _a.stroke, lineWidth = _a.lineWidth;\n        var hasStroke = !!(stroke && !stroke.isNone && lineWidth);\n        if (hasStroke) {\n            drawcalls.push(TextDrawcall);\n        }\n        drawcalls.push(TextDrawcall);\n        return drawcalls;\n    };\n    TextRenderer.prototype.beforeUploadUBO = function (renderInst, mesh) {\n        var _a;\n        var drawcallNum = mesh.instance.renderable3D\n            .drawcalls.length;\n        mesh.material.setUniforms((_a = {},\n            _a[exports.TextUniform.HAS_STROKE] = drawcallNum === 1 ? 0 : 1 - mesh.index,\n            _a));\n    };\n    return TextRenderer;\n}(Batch));\n\n/**\n * use instanced for each segment\n * @see https://blog.scottlogic.com/2019/11/18/drawing-lines-with-webgl.html\n *\n * support dash array\n * TODO: joint & cap\n */\nvar LineRenderer = /** @class */ (function (_super) {\n    tslib.__extends(LineRenderer, _super);\n    function LineRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineRenderer.prototype.getDrawcallCtors = function () {\n        return [InstancedLineDrawcall];\n    };\n    return LineRenderer;\n}(Batch));\n\nvar MeshRenderer = /** @class */ (function (_super) {\n    tslib.__extends(MeshRenderer, _super);\n    function MeshRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MeshRenderer.prototype.getDrawcallCtors = function () {\n        return [MeshDrawcall];\n    };\n    return MeshRenderer;\n}(Batch));\n\n/**\n * Use 2 meshes:\n * * For simple Rect with fill & simple stroke, we use SDFDrawcall to draw which has a better performance.\n * * FillMesh & LineMesh to draw rounded rect with different radius.\n */\nvar RectRenderer = /** @class */ (function (_super) {\n    tslib.__extends(RectRenderer, _super);\n    function RectRenderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    RectRenderer.prototype.getDrawcallCtors = function (object) {\n        var drawcalls = [];\n        var _a = object.parsedStyle, fill = _a.fill, radius = _a.radius;\n        var hasDifferentRadius = radius && radius.length && radius.some(function (r) { return r !== radius[0]; });\n        if (!(fill.isNone || hasDifferentRadius)) {\n            drawcalls.push(SDFDrawcall);\n        }\n        if (hasDifferentRadius) {\n            drawcalls.push(InstancedFillDrawcall);\n        }\n        if (hasDifferentRadius\n            ? hasDifferentRadius\n            : this.needDrawStrokeSeparately(object)) {\n            drawcalls.push(InstancedPathDrawcall);\n        }\n        return drawcalls;\n    };\n    /**\n     * need an additional mesh to draw stroke:\n     * 1. strokeOpacity < 1\n     * 2. lineDash used\n     * 3. stroke is not 'none'\n     */\n    RectRenderer.prototype.needDrawStrokeSeparately = function (object) {\n        var _a = object.parsedStyle, fill = _a.fill, stroke = _a.stroke, lineDash = _a.lineDash, lineWidth = _a.lineWidth, strokeOpacity = _a.strokeOpacity;\n        var hasFill = fill && !fill.isNone;\n        var hasStroke = stroke && !stroke.isNone;\n        var hasDash = lineDash && lineDash.length && lineDash.every(function (item) { return item !== 0; });\n        return (!hasFill || (hasStroke && lineWidth > 0 && (strokeOpacity < 1 || hasDash)));\n    };\n    return RectRenderer;\n}(Batch));\n\nvar stencilRefCounter = 1;\nvar BatchManager = /** @class */ (function () {\n    function BatchManager(renderHelper, rendererFactory, texturePool, lightPool) {\n        this.renderHelper = renderHelper;\n        this.rendererFactory = rendererFactory;\n        this.texturePool = texturePool;\n        this.lightPool = lightPool;\n        /**\n         * draw calls\n         */\n        this.drawcalls = [];\n        /**\n         * update patches which can be merged before rendering\n         */\n        this.pendingUpdatePatches = {};\n        this.stencilRefCache = {};\n    }\n    BatchManager.prototype.destroy = function () {\n        this.drawcalls.forEach(function (drawcall) {\n            drawcall.destroy();\n        });\n        this.drawcalls = [];\n        this.pendingUpdatePatches = {};\n    };\n    BatchManager.prototype.render = function (list, isPicking) {\n        var _this = this;\n        if (isPicking === void 0) { isPicking = false; }\n        if (!isPicking) {\n            this.updatePendingPatches();\n        }\n        this.drawcalls.forEach(function (mesh) {\n            // init rendering service, create geometry & material\n            mesh.init();\n            var objects = mesh.objects;\n            if (mesh.clipPathTarget) {\n                objects = [mesh.clipPath];\n            }\n            // new render instance\n            var renderInst = _this.renderHelper.renderInstManager.newRenderInst();\n            renderInst.setAllowSkippingIfPipelineNotReady(false);\n            mesh.applyRenderInst(renderInst, objects);\n            _this.renderHelper.renderInstManager.submitRenderInst(renderInst, list);\n            // console.log('submit: ', mesh);\n            if (!isPicking) {\n                // finish rendering...\n                mesh.objects.forEach(function (object) {\n                    object.renderable.dirty = false;\n                });\n            }\n        });\n    };\n    /**\n     * get called in RenderGraphPlugin\n     */\n    BatchManager.prototype.attach = function (context) {\n        this.context = context;\n    };\n    BatchManager.prototype.add = function (object) {\n        var _this = this;\n        var renderable3D = object.renderable3D;\n        if (renderable3D && !renderable3D.drawcalls.length) {\n            var renderer_1 = this.rendererFactory[object.nodeName];\n            if (renderer_1) {\n                // A complex Path can be splitted into multple sub paths.\n                renderer_1\n                    .getDrawcallCtors(object)\n                    .forEach(function (drawcallCtor, i, drawcallCtors) {\n                    var existedDrawcall = _this.drawcalls.find(function (mesh) {\n                        return drawcallCtor === mesh.constructor &&\n                            mesh.index === i &&\n                            mesh.objects.length < mesh.maxInstances &&\n                            mesh.shouldMerge(object, i);\n                    });\n                    if (!existedDrawcall ||\n                        existedDrawcall.key !== object.parsedStyle.batchKey) {\n                        existedDrawcall = new drawcallCtor(_this.renderHelper, _this.texturePool, _this.lightPool, object, drawcallCtors, i, _this.context);\n                        existedDrawcall.renderer = renderer_1;\n                        _this.drawcalls.push(existedDrawcall);\n                        if (object.parsedStyle.batchKey) {\n                            existedDrawcall.key = object.parsedStyle.batchKey;\n                        }\n                    }\n                    if (existedDrawcall) {\n                        existedDrawcall.objects.push(object);\n                        renderable3D.drawcalls[i] = existedDrawcall;\n                        existedDrawcall.geometryDirty = true;\n                    }\n                });\n            }\n        }\n    };\n    BatchManager.prototype.remove = function (object) {\n        var _this = this;\n        // @ts-ignore\n        var renderable3D = object.renderable3D;\n        if (renderable3D) {\n            renderable3D.drawcalls.forEach(function (mesh) {\n                if (mesh) {\n                    // remove from mesh\n                    var index = mesh.objects.indexOf(object);\n                    if (index > -1) {\n                        mesh.objects.splice(index, 1);\n                        mesh.geometryDirty = true;\n                    }\n                    if (mesh.objects.length === 0) {\n                        var deletedDrawcalls = _this.drawcalls.splice(_this.drawcalls.indexOf(mesh), 1);\n                        deletedDrawcalls.forEach(function (deletedDrawcall) {\n                            deletedDrawcall.destroy();\n                        });\n                    }\n                }\n            });\n            renderable3D.drawcalls = [];\n        }\n    };\n    BatchManager.prototype.updateAttribute = function (object, attributeName, newValue, immediately) {\n        var _this = this;\n        if (immediately === void 0) { immediately = false; }\n        var renderable3D = object.renderable3D;\n        var renderer = this.rendererFactory[object.nodeName];\n        if (renderer) {\n            var drawcallCtors = renderer.getDrawcallCtors(object);\n            drawcallCtors.forEach(function (drawcallCtor, i, drawcallCtors) {\n                var existedDrawcall = renderable3D.drawcalls.find(function (mesh) {\n                    return mesh && mesh.index === i && mesh.constructor === drawcallCtor;\n                });\n                if (!existedDrawcall) {\n                    // Clear invalid drawcall.\n                    existedDrawcall = renderable3D.drawcalls[i];\n                    if (existedDrawcall) {\n                        // remove from mesh\n                        existedDrawcall.objects.splice(existedDrawcall.objects.indexOf(object), 1);\n                        existedDrawcall.geometryDirty = true;\n                        if (existedDrawcall.objects.length === 0) {\n                            _this.drawcalls.splice(_this.drawcalls.indexOf(existedDrawcall), 1);\n                        }\n                        renderable3D.drawcalls[renderable3D.drawcalls.indexOf(existedDrawcall)] = undefined;\n                    }\n                    // We should create a new drawcall from scratch.\n                    existedDrawcall = _this.drawcalls.find(function (mesh) {\n                        return drawcallCtor === mesh.constructor &&\n                            mesh.index === i &&\n                            mesh.objects.length < mesh.maxInstances &&\n                            mesh.shouldMerge(object, i);\n                    });\n                    if (!existedDrawcall) {\n                        // @ts-ignore\n                        existedDrawcall = new drawcallCtor(_this.renderHelper, _this.texturePool, _this.lightPool, object, drawcallCtors, i, _this.context);\n                        existedDrawcall.renderer = renderer;\n                        existedDrawcall.init();\n                        _this.drawcalls.push(existedDrawcall);\n                    }\n                    else {\n                        existedDrawcall.geometryDirty = true;\n                    }\n                    existedDrawcall.objects.push(object);\n                    renderable3D.drawcalls[i] = existedDrawcall;\n                }\n                if (existedDrawcall.inited && !existedDrawcall.geometryDirty) {\n                    var shouldMerge = existedDrawcall.shouldMerge(object, i);\n                    if (shouldMerge) {\n                        var objectIdx = existedDrawcall.objects.indexOf(object);\n                        if (immediately) {\n                            object.parsedStyle[attributeName] = newValue;\n                            existedDrawcall.updateAttribute([object], objectIdx, attributeName, newValue);\n                        }\n                        else {\n                            var patchKey = existedDrawcall.id + attributeName;\n                            if (!_this.pendingUpdatePatches[patchKey]) {\n                                _this.pendingUpdatePatches[patchKey] = {\n                                    instance: existedDrawcall,\n                                    objectIndices: [],\n                                    name: attributeName,\n                                    value: newValue,\n                                };\n                            }\n                            if (_this.pendingUpdatePatches[patchKey].objectIndices.indexOf(objectIdx) === -1) {\n                                _this.pendingUpdatePatches[patchKey].objectIndices.push(objectIdx);\n                            }\n                        }\n                    }\n                    else {\n                        _this.remove(object);\n                        _this.add(object);\n                    }\n                }\n                else {\n                    _this.remove(object);\n                    _this.add(object);\n                }\n            });\n            // Clear redundant drawcalls.\n            if (renderable3D.drawcalls.length > drawcallCtors.length) {\n                var drawcallNum = renderable3D.drawcalls.length;\n                for (var i = drawcallNum - 1; i >= drawcallCtors.length; i--) {\n                    var existedDrawcall = renderable3D.drawcalls[i];\n                    // remove from mesh\n                    existedDrawcall.objects.splice(existedDrawcall.objects.indexOf(object), 1);\n                    existedDrawcall.geometryDirty = true;\n                    if (existedDrawcall.objects.length === 0) {\n                        this.drawcalls.splice(this.drawcalls.indexOf(existedDrawcall), 1);\n                    }\n                    renderable3D.drawcalls.pop();\n                }\n            }\n        }\n    };\n    BatchManager.prototype.changeRenderOrder = function (object, renderOrder) {\n        // @ts-ignore\n        var renderable3D = object.renderable3D;\n        if (renderable3D && renderable3D.drawcalls.length) {\n            renderable3D.drawcalls.forEach(function (mesh) {\n                if (mesh && mesh.inited && !mesh.geometryDirty) {\n                    if (mesh.inited) {\n                        mesh.changeRenderOrder(object, renderOrder);\n                    }\n                }\n            });\n        }\n    };\n    BatchManager.prototype.getStencilRef = function (object) {\n        if (!this.stencilRefCache[object.entity]) {\n            this.stencilRefCache[object.entity] = stencilRefCounter++;\n        }\n        return this.stencilRefCache[object.entity];\n    };\n    BatchManager.prototype.updatePendingPatches = function () {\n        var _this = this;\n        // merge update patches to reduce `setSubData` calls\n        Object.keys(this.pendingUpdatePatches).forEach(function (patchKey) {\n            var _a = _this.pendingUpdatePatches[patchKey], instance = _a.instance, objectIndices = _a.objectIndices, name = _a.name, value = _a.value;\n            objectIndices.sort(function (a, b) { return a - b; });\n            var updatePatches = [];\n            objectIndices.forEach(function (i) {\n                var lastUpdateBatch = updatePatches[updatePatches.length - 1];\n                if (!lastUpdateBatch ||\n                    i !== lastUpdateBatch[lastUpdateBatch.length - 1] + 1) {\n                    updatePatches.push([i]);\n                }\n                else {\n                    lastUpdateBatch.push(i);\n                }\n            });\n            updatePatches.forEach(function (indices) {\n                instance.updateAttribute(instance.objects.slice(indices[0], indices[0] + indices.length), indices[0], name, value);\n            });\n        });\n        this.pendingUpdatePatches = {};\n    };\n    return BatchManager;\n}());\n\nvar TexturePool = /** @class */ (function () {\n    function TexturePool(context, runtime) {\n        this.context = context;\n        this.runtime = runtime;\n        this.textureCache = {};\n    }\n    TexturePool.prototype.getOrCreateTexture = function (device, src, descriptor, successCallback) {\n        var _this = this;\n        // use Image URL or src as cache key\n        // @ts-ignore\n        var id = typeof src === 'string' ? src : src.src || '';\n        var texture;\n        if (!id || !this.textureCache[id]) {\n            texture = device.createTexture(tslib.__assign({ format: gDeviceApi.Format.U8_RGBA_NORM, width: 1, height: 1, depthOrArrayLayers: 1, mipLevelCount: 1, dimension: gDeviceApi.TextureDimension.TEXTURE_2D, usage: gDeviceApi.TextureUsage.SAMPLED, pixelStore: {\n                    unpackFlipY: false,\n                } }, descriptor));\n            if (id) {\n                this.textureCache[id] = texture;\n            }\n            if (!util.isString(src)) {\n                texture.setImageData([src]);\n                texture.emit(gDeviceApi.TextureEvent.LOADED);\n                this.context.renderingService.dirtify();\n            }\n            else {\n                // @see https://github.com/antvis/g/issues/938\n                var createImage = this.context.config.createImage;\n                var image_1;\n                if (createImage) {\n                    image_1 = createImage(src);\n                }\n                else if (gLite.isBrowser) {\n                    image_1 = new window.Image();\n                }\n                if (image_1) {\n                    image_1.onload = function () {\n                        var onSuccess = function (bitmap) {\n                            _this.textureCache[id].setImageData([bitmap]);\n                            _this.textureCache[id].emit(gDeviceApi.TextureEvent.LOADED);\n                            _this.context.renderingService.dirtify();\n                            if (successCallback) {\n                                successCallback(_this.textureCache[id]);\n                            }\n                        };\n                        if (_this.runtime.globalThis.createImageBitmap) {\n                            _this.runtime.globalThis\n                                .createImageBitmap(image_1)\n                                .then(function (bitmap) { return onSuccess(bitmap); })\n                                .catch(function () {\n                                // Unhandled Rejection (InvalidStateError):\n                                // Failed to execute 'createImageBitmap' on 'Window':\n                                // The image element contains an SVG image without intrinsic dimensions,\n                                // and no resize options or crop region are specified.\n                                onSuccess(image_1);\n                            });\n                        }\n                        else {\n                            onSuccess(image_1);\n                        }\n                    };\n                    image_1.onerror = function () { };\n                    image_1.crossOrigin = 'Anonymous';\n                    image_1.src = src;\n                }\n            }\n        }\n        else {\n            texture = this.textureCache[id];\n            texture.emit(gDeviceApi.TextureEvent.LOADED);\n        }\n        return texture;\n    };\n    TexturePool.prototype.getOrCreateCanvas = function () {\n        return this.runtime.offscreenCanvasCreator.getOrCreateCanvas(this.context.config.offscreenCanvas);\n    };\n    TexturePool.prototype.getOrCreateGradient = function (params) {\n        var instance = params.instance, gradients = params.gradients;\n        var halfExtents = instance.getGeometryBounds().halfExtents;\n        var width = halfExtents[0] * 2 || 1;\n        var height = halfExtents[1] * 2 || 1;\n        var offscreenCanvas = this.context.config.offscreenCanvas;\n        var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);\n        canvas.width = width;\n        canvas.height = height;\n        // @ts-ignore\n        var imagePool = this.context.imagePool;\n        gradients.forEach(function (g) {\n            var gradient = imagePool.getOrCreateGradient(tslib.__assign(tslib.__assign({ type: g.type }, g.value), { width: width, height: height }), context);\n            // used as canvas' ID\n            // @ts-ignore\n            // canvas.src = key;\n            context.fillStyle = gradient;\n            context.fillRect(0, 0, width, height);\n        });\n    };\n    TexturePool.prototype.getOrCreatePattern = function (pattern, instance, callback) {\n        var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;\n        var halfExtents = instance.getGeometryBounds().halfExtents;\n        var width = halfExtents[0] * 2 || 1;\n        var height = halfExtents[1] * 2 || 1;\n        var offscreenCanvas = this.context.config.offscreenCanvas;\n        var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);\n        canvas.width = width;\n        canvas.height = height;\n        var src;\n        // Image URL\n        if (util.isString(image)) {\n            // @ts-ignore\n            src = this.context.imagePool.getImageSync(image, callback);\n        }\n        else {\n            src = image;\n        }\n        var canvasPattern = src && context.createPattern(src, repetition);\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern/setTransform\n        if (transform) {\n            var mat = gLite.parsedTransformToMat4(gLite.parseTransform(transform), new gLite.DisplayObject({}));\n            canvasPattern.setTransform({\n                a: mat[0],\n                b: mat[1],\n                c: mat[4],\n                d: mat[5],\n                e: mat[12],\n                f: mat[13],\n            });\n        }\n        context.fillStyle = canvasPattern;\n        context.fillRect(0, 0, width, height);\n    };\n    TexturePool.prototype.destroy = function () {\n        for (var key in this.textureCache) {\n            this.textureCache[key].destroy();\n        }\n        this.textureCache = {};\n    };\n    return TexturePool;\n}());\n\nvar Plugin = /** @class */ (function (_super) {\n    tslib.__extends(Plugin, _super);\n    function Plugin(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.options = options;\n        _this.name = 'device-renderer';\n        _this.parameters = {\n            /**\n             * ToneMapping is a renderer-level parameter, it will affect all materials.\n             * @see https://threejs.org/docs/#api/en/renderers/WebGLRenderer.toneMapping\n             */\n            toneMapping: exports.ToneMapping.NONE,\n            toneMappingExposure: 1,\n        };\n        return _this;\n    }\n    Plugin.prototype.init = function (runtime) {\n        var _a;\n        runtime.geometryUpdaterFactory[gLite.Shape.MESH] = new MeshUpdater();\n        var renderHelper = new RenderHelper(this.parameters);\n        var lightPool = new LightPool();\n        var texturePool = new TexturePool(this.context, runtime);\n        var pickingIdGenerator = new PickingIdGenerator();\n        var circleRenderer = new CircleRenderer();\n        var pathRenderer = new PathRenderer();\n        var rendererFactory = (_a = {},\n            _a[gLite.Shape.CIRCLE] = circleRenderer,\n            _a[gLite.Shape.ELLIPSE] = circleRenderer,\n            _a[gLite.Shape.POLYLINE] = pathRenderer,\n            _a[gLite.Shape.PATH] = pathRenderer,\n            _a[gLite.Shape.POLYGON] = pathRenderer,\n            _a[gLite.Shape.RECT] = new RectRenderer(),\n            _a[gLite.Shape.IMAGE] = new ImageRenderer(),\n            _a[gLite.Shape.LINE] = new LineRenderer(),\n            _a[gLite.Shape.TEXT] = new TextRenderer(),\n            _a[gLite.Shape.MESH] = new MeshRenderer(),\n            _a[gLite.Shape.GROUP] = undefined,\n            _a[gLite.Shape.HTML] = undefined,\n            _a);\n        var batchManager = new BatchManager(renderHelper, rendererFactory, texturePool, lightPool);\n        var renderGraphPlugin = new RenderGraphPlugin(renderHelper, lightPool, texturePool, batchManager, this.options);\n        this.addRenderingPlugin(renderGraphPlugin);\n        this.addRenderingPlugin(new PickingPlugin(renderHelper, renderGraphPlugin, pickingIdGenerator, batchManager));\n    };\n    Plugin.prototype.destroy = function (runtime) {\n        delete runtime.geometryUpdaterFactory[gLite.Shape.MESH];\n    };\n    Plugin.prototype.getRenderGraphPlugin = function () {\n        return this.plugins[0];\n    };\n    Plugin.prototype.getDevice = function () {\n        return this.getRenderGraphPlugin().getDevice();\n    };\n    Plugin.prototype.loadTexture = function (src, descriptor, successCallback) {\n        return this.getRenderGraphPlugin().loadTexture(src, descriptor, successCallback);\n    };\n    Plugin.prototype.toDataURL = function (options) {\n        return this.getRenderGraphPlugin().toDataURL(options);\n    };\n    Plugin.prototype.setParameters = function (parameters) {\n        this.parameters = tslib.__assign(tslib.__assign({}, this.parameters), parameters);\n    };\n    return Plugin;\n}(gLite.AbstractRendererPlugin));\n\nexports.Batch = Batch;\nexports.BufferGeometry = BufferGeometry;\nexports.DeviceProgram = DeviceProgram;\nexports.DynamicUniformBuffer = DynamicUniformBuffer;\nexports.FILL_TEXTURE_MAPPING = FILL_TEXTURE_MAPPING;\nexports.Fog = Fog;\nexports.HashMap = HashMap;\nexports.ImageDrawcall = ImageDrawcall;\nexports.Instanced = Instanced;\nexports.InstancedFillDrawcall = InstancedFillDrawcall;\nexports.InstancedLineDrawcall = InstancedLineDrawcall;\nexports.InstancedPathDrawcall = InstancedPathDrawcall;\nexports.Light = Light;\nexports.Material = Material;\nexports.Mesh = Mesh;\nexports.MeshDrawcall = MeshDrawcall;\nexports.Plugin = Plugin;\nexports.RenderCache = RenderCache;\nexports.RenderGraphPlugin = RenderGraphPlugin;\nexports.RenderHelper = RenderHelper;\nexports.RenderInst = RenderInst;\nexports.RenderInstList = RenderInstList;\nexports.RenderInstManager = RenderInstManager;\nexports.Renderable3D = Renderable3D;\nexports.SDFDrawcall = SDFDrawcall;\nexports.ShaderMaterial = ShaderMaterial;\nexports.SingleSampledTexture = SingleSampledTexture;\nexports.TemporalTexture = TemporalTexture;\nexports.TextDrawcall = TextDrawcall;\nexports.TextureMapping = TextureMapping;\nexports.TexturePool = TexturePool;\nexports.TinySDF = TinySDF;\nexports.bezierCurveTo = bezierCurveTo;\nexports.compareDefines = compareDefines;\nexports.definedProps = definedProps;\nexports.enumToObject = enumToObject;\nexports.fillColor = fillColor;\nexports.fillMatrix4x4 = fillMatrix4x4;\nexports.fillVec3v = fillVec3v;\nexports.fillVec4 = fillVec4;\nexports.fillVec4v = fillVec4v;\nexports.getSortKeyDepth = getSortKeyDepth;\nexports.getSortKeyLayer = getSortKeyLayer;\nexports.hashCodeNumberFinish = hashCodeNumberFinish;\nexports.hashCodeNumberUpdate = hashCodeNumberUpdate;\nexports.makeAttachmentClearDescriptor = makeAttachmentClearDescriptor;\nexports.makeBackbufferDescSimple = makeBackbufferDescSimple;\nexports.makeDataBuffer = makeDataBuffer;\nexports.makeDepthKey = makeDepthKey;\nexports.makeSortKey = makeSortKey;\nexports.makeSortKeyOpaque = makeSortKeyOpaque;\nexports.makeSortKeyTranslucent = makeSortKeyTranslucent;\nexports.nullHashFunc = nullHashFunc;\nexports.opaqueBlackFullClearRenderPassDescriptor = opaqueBlackFullClearRenderPassDescriptor;\nexports.opaqueWhiteFullClearRenderPassDescriptor = opaqueWhiteFullClearRenderPassDescriptor;\nexports.projectionMatrixConvertClipSpaceNearZ = projectionMatrixConvertClipSpaceNearZ;\nexports.pushFXAAPass = pushFXAAPass;\nexports.quadCurveTo = quadCurveTo;\nexports.renderInstCompareNone = renderInstCompareNone;\nexports.renderInstCompareSortKey = renderInstCompareSortKey;\nexports.segmentInstanceGeometry = segmentInstanceGeometry;\nexports.setBackbufferDescSimple = setBackbufferDescSimple;\nexports.setSortKeyBias = setSortKeyBias;\nexports.setSortKeyDepth = setSortKeyDepth;\nexports.setSortKeyDepthKey = setSortKeyDepthKey;\nexports.setSortKeyLayer = setSortKeyLayer;\nexports.setSortKeyOpaqueDepth = setSortKeyOpaqueDepth;\nexports.setSortKeyProgramKey = setSortKeyProgramKey;\nexports.setSortKeyTranslucentDepth = setSortKeyTranslucentDepth;\nexports.standardFullClearRenderPassDescriptor = standardFullClearRenderPassDescriptor;\nexports.updateBuffer = updateBuffer;\n//# sourceMappingURL=index.js.map\n"]}