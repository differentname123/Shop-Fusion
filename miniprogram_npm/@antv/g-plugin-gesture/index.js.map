{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\n\n/**\n * TODO: use clock from g later.\n */\nvar clock = typeof performance === 'object' && performance.now ? performance : Date;\n// 计算滑动的方向\nvar calcDirection = function (start, end) {\n    var xDistance = end.x - start.x;\n    var yDistance = end.y - start.y;\n    // x 的距离大于y 说明是横向，否则就是纵向\n    if (Math.abs(xDistance) > Math.abs(yDistance)) {\n        return xDistance > 0 ? 'right' : 'left';\n    }\n    return yDistance > 0 ? 'down' : 'up';\n};\n// 计算2点之间的距离\nvar calcDistance = function (point1, point2) {\n    var xDistance = Math.abs(point2.x - point1.x);\n    var yDistance = Math.abs(point2.y - point1.y);\n    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n};\nvar getCenter = function (point1, point2) {\n    var x = point1.x + (point2.x - point1.x) / 2;\n    var y = point1.y + (point2.y - point1.y) / 2;\n    return { x: x, y: y };\n};\n\nvar PRESS_DELAY = 250;\nvar GesturePlugin = /** @class */ (function () {\n    function GesturePlugin(options) {\n        var _this = this;\n        this.options = options;\n        this.evCache = [];\n        this.startPoints = [];\n        // 用来记录当前触发的事件\n        this.processEvent = {};\n        this.throttleTimer = 0;\n        this.emitThrottles = [];\n        this._start = function (ev, target) {\n            var _a;\n            // 每次触点开始都重置事件\n            _this.reset();\n            // 记录touch start 的时间\n            _this.startTime = clock.now();\n            var _b = _this, evCache = _b.evCache, startPoints = _b.startPoints;\n            if (ev) {\n                var pointerId_1 = ev.pointerId, x = ev.x, y = ev.y;\n                // evcache 已经存在的 pointerId, 做替换\n                var existIdx = evCache.findIndex(function (item) { return pointerId_1 === item.pointerId; });\n                if (existIdx !== -1) {\n                    evCache.splice(existIdx, 1);\n                }\n                // evCache 不存在的 pointerId, 添加\n                evCache.push({\n                    pointerId: pointerId_1,\n                    x: x,\n                    y: y,\n                    ev: ev,\n                });\n                // @ts-ignore 对齐touches evCache 存在，touches 不存在，移除\n                var evTouches = tslib.__spreadArray([], tslib.__read((((_a = ev.nativeEvent) === null || _a === void 0 ? void 0 : _a.touches) || [])), false);\n                var _loop_1 = function (i) {\n                    var isInTouches = evTouches.find(function (touch) {\n                        return evCache[i].pointerId === touch.identifier;\n                    });\n                    // 在touches中存在\n                    if (isInTouches) {\n                        return \"continue\";\n                    }\n                    // 在touches中不存在\n                    evCache.splice(i, 1);\n                };\n                for (var i = evCache.length - 1; i > -1; i--) {\n                    _loop_1(i);\n                }\n            }\n            // 重置 startPoints\n            startPoints.length = evCache.length;\n            for (var i = 0; i < evCache.length; i++) {\n                var _c = evCache[i], x = _c.x, y = _c.y;\n                var point = { x: x, y: y };\n                startPoints[i] = point;\n            }\n            // 单指事件\n            if (startPoints.length === 1) {\n                var event_1 = evCache[0].ev;\n                // 如果touchstart后停顿250ms, 则也触发press事件\n                // @ts-ignore\n                _this.pressTimeout = setTimeout(function () {\n                    // 这里固定触发press事件\n                    var eventType = 'press';\n                    var direction = 'none';\n                    event_1.direction = direction;\n                    event_1.deltaX = 0;\n                    event_1.deltaY = 0;\n                    event_1.points = startPoints;\n                    _this.emitStart(eventType, event_1, target);\n                    event_1.type = eventType;\n                    target.dispatchEvent(event_1);\n                    _this.eventType = eventType;\n                    _this.direction = direction;\n                    _this.movingTarget = target;\n                }, PRESS_DELAY);\n                return;\n            }\n            // 目前只处理双指\n            _this.startDistance = calcDistance(startPoints[0], startPoints[1]);\n            _this.center = getCenter(startPoints[0], startPoints[1]);\n        };\n        this._move = function (ev, target) {\n            _this.clearPressTimeout();\n            var _a = _this, startPoints = _a.startPoints, evCache = _a.evCache;\n            if (!startPoints.length)\n                return;\n            var x = ev.x, y = ev.y, pointerId = ev.pointerId;\n            // Find this event in the cache and update its record with this event\n            for (var i = 0, len = evCache.length; i < len; i++) {\n                if (pointerId === evCache[i].pointerId) {\n                    evCache[i] = {\n                        pointerId: pointerId,\n                        x: x,\n                        y: y,\n                        ev: ev,\n                    };\n                    break;\n                }\n            }\n            var point = { x: x, y: y };\n            var points = evCache.map(function (ev) {\n                return { x: ev.x, y: ev.y };\n            });\n            // 记录最后2次move的时间和坐标，为了给swipe事件用\n            var now = clock.now();\n            _this.prevMoveTime = _this.lastMoveTime;\n            _this.prevMovePoint = _this.lastMovePoint;\n            _this.lastMoveTime = now;\n            _this.lastMovePoint = point;\n            if (startPoints.length === 1) {\n                var startPoint = startPoints[0];\n                var deltaX = x - startPoint.x;\n                var deltaY = y - startPoint.y;\n                var direction = _this.direction || calcDirection(startPoint, point);\n                _this.direction = direction;\n                // 获取press或者pan的事件类型\n                // press 按住滑动, pan表示平移\n                // 如果start后立刻move，则触发pan, 如果有停顿，则触发press\n                var eventType = _this.getEventType(point, target, ev);\n                ev.direction = direction;\n                ev.deltaX = deltaX;\n                ev.deltaY = deltaY;\n                ev.points = points;\n                _this.emitStart(eventType, ev, target);\n                ev.type = eventType;\n                _this.refreshAndGetTarget(target).dispatchEvent(ev);\n                return;\n            }\n            // 多指触控\n            var startDistance = _this.startDistance;\n            var currentDistance = calcDistance(points[0], points[1]);\n            // 缩放比例\n            ev.zoom = currentDistance / startDistance;\n            ev.center = _this.center;\n            ev.points = points;\n            // 触发缩放事件\n            _this.emitStart('pinch', ev, target);\n            // touch 多指会被拆成多个手指的 move, 会触发多次 move，所以这里需要做节流\n            _this._throttleEmit('pinch', ev, target);\n        };\n        this._end = function (ev, target) {\n            var _a = _this, evCache = _a.evCache, startPoints = _a.startPoints;\n            var points = evCache.map(function (ev) {\n                return { x: ev.x, y: ev.y };\n            });\n            ev.points = points;\n            _this.emitEnd(ev, _this.refreshAndGetTarget(target));\n            // 单指\n            if (evCache.length === 1) {\n                // swipe事件处理, 在end之后触发\n                var now = clock.now();\n                var lastMoveTime = _this.lastMoveTime;\n                // 做这个判断是为了最后一次touchmove后到end前，是否还有一个停顿的过程\n                // 100 是拍的一个值，理论这个值会很短，一般不卡顿的话在10ms以内\n                if (now - lastMoveTime < 100) {\n                    var prevMoveTime = _this.prevMoveTime || _this.startTime;\n                    var intervalTime = lastMoveTime - prevMoveTime;\n                    // 时间间隔一定要大于0, 否则计算没意义\n                    if (intervalTime > 0) {\n                        var prevMovePoint = _this.prevMovePoint || startPoints[0];\n                        var lastMovePoint = _this.lastMovePoint || startPoints[0];\n                        // move速率\n                        var velocity = calcDistance(prevMovePoint, lastMovePoint) / intervalTime;\n                        // 0.3 是参考hammerjs的设置\n                        if (velocity > 0.3) {\n                            ev.velocity = velocity;\n                            ev.direction = calcDirection(prevMovePoint, lastMovePoint);\n                            ev.type = 'swipe';\n                            target.dispatchEvent(ev);\n                        }\n                    }\n                }\n            }\n            // remove event from cache\n            for (var i = 0, len = evCache.length; i < len; i++) {\n                if (evCache[i].pointerId === ev.pointerId) {\n                    evCache.splice(i, 1);\n                    startPoints.splice(i, 1);\n                    break;\n                }\n            }\n            _this.reset();\n            // 多指离开 1 指后，重新触发一次start\n            if (evCache.length > 0) {\n                _this._start(undefined, target);\n            }\n        };\n        this._cancel = function (ev, target) {\n            var evCache = _this.evCache;\n            var points = evCache.map(function (ev) {\n                return { x: ev.x, y: ev.y };\n            });\n            ev.points = points;\n            _this.emitEnd(ev, _this.refreshAndGetTarget(target));\n            _this.evCache = [];\n            _this.reset();\n        };\n    }\n    GesturePlugin.prototype.apply = function (context) {\n        var _this = this;\n        var renderingService = context.renderingService, renderingContext = context.renderingContext;\n        var document = renderingContext.root.ownerDocument;\n        var canvas = document.defaultView;\n        this.canvas = canvas;\n        var getGestureEventTarget = function (target) {\n            var isDocument = target === document;\n            return isDocument && _this.options.isDocumentGestureEnabled\n                ? document\n                : target;\n        };\n        var handlePointermove = function (ev) {\n            var target = getGestureEventTarget(ev.target);\n            target && _this._move(ev, target);\n        };\n        var handlePointerdown = function (ev) {\n            var target = getGestureEventTarget(ev.target);\n            target && _this._start(ev, target);\n        };\n        var handlePointerup = function (ev) {\n            var target = getGestureEventTarget(ev.target);\n            target && _this._end(ev, target);\n        };\n        var handlePointercancel = function (ev) {\n            var target = getGestureEventTarget(ev.target);\n            target && _this._cancel(ev, target);\n        };\n        var handlePointercanceloutside = function (ev) {\n            var target = getGestureEventTarget(ev.target);\n            target && _this._end(ev, target);\n        };\n        renderingService.hooks.init.tap(GesturePlugin.tag, function () {\n            canvas.addEventListener('pointermove', handlePointermove);\n            canvas.addEventListener('pointerdown', handlePointerdown);\n            canvas.addEventListener('pointerup', handlePointerup);\n            canvas.addEventListener('pointercancel', handlePointercancel);\n            canvas.addEventListener('pointerupoutside', handlePointercanceloutside);\n        });\n        renderingService.hooks.destroy.tap(GesturePlugin.tag, function () {\n            canvas.removeEventListener('pointermove', handlePointermove);\n            canvas.removeEventListener('pointerdown', handlePointerdown);\n            canvas.removeEventListener('pointerup', handlePointerup);\n            canvas.removeEventListener('pointercancel', handlePointercancel);\n            canvas.removeEventListener('pointerupoutside', handlePointercanceloutside);\n        });\n    };\n    GesturePlugin.prototype.getEventType = function (point, target, ev) {\n        var _a = this, eventType = _a.eventType, startTime = _a.startTime, startPoints = _a.startPoints;\n        if (eventType) {\n            return eventType;\n        }\n        // move的时候缓存节点，后续move和end都会使用这个target派发事件\n        this.movingTarget = target;\n        // 冒泡路径中是否有pan事件\n        this.isPanListenerInPath = ev.path.some(function (ele) { var _a, _b; return !!((_b = (_a = ele.emitter) === null || _a === void 0 ? void 0 : _a.eventNames()) === null || _b === void 0 ? void 0 : _b.includes('pan')); });\n        var type;\n        // 如果没有pan事件的监听，默认都是press\n        if (!this.isPanListenerInPath) {\n            type = 'press';\n        }\n        else {\n            // 如果有pan事件的处理，press则需要停顿250ms, 且移动距离小于10\n            var now = clock.now();\n            if (now - startTime > PRESS_DELAY &&\n                calcDistance(startPoints[0], point) < 10) {\n                type = 'press';\n            }\n            else {\n                type = 'pan';\n            }\n        }\n        this.eventType = type;\n        return type;\n    };\n    GesturePlugin.prototype.enable = function (eventType) {\n        this.processEvent[eventType] = true;\n    };\n    // 是否进行中的事件\n    GesturePlugin.prototype.isProcess = function (eventType) {\n        return this.processEvent[eventType];\n    };\n    // 触发start事件\n    GesturePlugin.prototype.emitStart = function (type, ev, target) {\n        if (this.isProcess(type)) {\n            return;\n        }\n        this.enable(type);\n        ev.type = \"\".concat(type, \"start\");\n        target.dispatchEvent(ev);\n    };\n    // 触发事件\n    GesturePlugin.prototype._throttleEmit = function (type, ev, target) {\n        var _this = this;\n        // 主要是节流处理\n        this.pushEvent(type, ev);\n        var _a = this, throttleTimer = _a.throttleTimer, emitThrottles = _a.emitThrottles, processEvent = _a.processEvent;\n        if (throttleTimer) {\n            return;\n        }\n        this.throttleTimer = this.canvas.requestAnimationFrame(function () {\n            for (var i = 0, len = emitThrottles.length; i < len; i++) {\n                var _a = emitThrottles[i], type_1 = _a.type, ev_1 = _a.ev;\n                if (processEvent[type_1]) {\n                    ev_1.type = type_1;\n                    target.dispatchEvent(ev_1);\n                }\n            }\n            // 清空\n            _this.throttleTimer = 0;\n            _this.emitThrottles.length = 0;\n        });\n    };\n    // 触发end事件\n    GesturePlugin.prototype.emitEnd = function (ev, target) {\n        var processEvent = this.processEvent;\n        Object.keys(processEvent).forEach(function (type) {\n            ev.type = \"\".concat(type, \"end\");\n            target.dispatchEvent(ev);\n            delete processEvent[type];\n        });\n    };\n    GesturePlugin.prototype.pushEvent = function (type, ev) {\n        var emitThrottles = this.emitThrottles;\n        var newEvent = { type: type, ev: ev };\n        for (var i = 0, len = emitThrottles.length; i < len; i++) {\n            if (emitThrottles[i].type === type) {\n                emitThrottles.splice(i, 1, newEvent);\n                return;\n            }\n        }\n        emitThrottles.push(newEvent);\n    };\n    GesturePlugin.prototype.clearPressTimeout = function () {\n        if (this.pressTimeout) {\n            clearTimeout(this.pressTimeout);\n            this.pressTimeout = null;\n        }\n    };\n    GesturePlugin.prototype.refreshAndGetTarget = function (target) {\n        if (this.movingTarget) {\n            // @ts-ignore\n            if (this.movingTarget && !this.movingTarget.isConnected) {\n                this.movingTarget = target;\n            }\n            return this.movingTarget;\n        }\n        return target;\n    };\n    GesturePlugin.prototype.reset = function () {\n        this.clearPressTimeout();\n        this.startTime = 0;\n        this.startDistance = 0;\n        this.direction = null;\n        this.eventType = null;\n        this.prevMoveTime = 0;\n        this.prevMovePoint = null;\n        this.lastMoveTime = 0;\n        this.lastMovePoint = null;\n        this.movingTarget = null;\n        this.isPanListenerInPath = null;\n    };\n    GesturePlugin.tag = 'Gesture';\n    return GesturePlugin;\n}());\n\nvar Plugin = /** @class */ (function (_super) {\n    tslib.__extends(Plugin, _super);\n    function Plugin(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.options = options;\n        _this.name = 'gesture';\n        return _this;\n    }\n    Plugin.prototype.init = function () {\n        this.addRenderingPlugin(new GesturePlugin(tslib.__assign({ isDocumentGestureEnabled: false }, this.options)));\n    };\n    Plugin.prototype.destroy = function () {\n        this.removeAllRenderingPlugins();\n    };\n    return Plugin;\n}(gLite.AbstractRendererPlugin));\n\nexports.Plugin = Plugin;\n//# sourceMappingURL=index.js.map\n"]}