{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\nvar util = require('@antv/util');\nvar glMatrix = require('gl-matrix');\n\nvar ElementSVG = /** @class */ (function () {\n    function ElementSVG() {\n    }\n    ElementSVG.tag = 'c-svg-element';\n    return ElementSVG;\n}());\n\nfunction updateImageElementAttribute($el, parsedStyle) {\n    var _a = parsedStyle.img, img = _a === void 0 ? '' : _a, width = parsedStyle.width, height = parsedStyle.height;\n    $el.setAttribute('x', '0');\n    $el.setAttribute('y', '0');\n    if (util.isString(img)) {\n        $el.setAttribute('href', img);\n    }\n    else if (img instanceof Image) {\n        if (!width) {\n            $el.setAttribute('width', \"\".concat(img.width));\n            // TODO: set renderable.boundsDirty\n            // this.attr('width', img.width);\n        }\n        if (!height) {\n            $el.setAttribute('height', \"\".concat(img.height));\n            // this.attr('height', img.height);\n        }\n        $el.setAttribute('href', img.src);\n    }\n    else if (\n    // @ts-ignore\n    img instanceof HTMLElement &&\n        util.isString(img.nodeName) &&\n        img.nodeName.toUpperCase() === 'CANVAS') {\n        $el.setAttribute('href', img.toDataURL());\n        // @ts-ignore\n    }\n    else if (img instanceof ImageData) {\n        var canvas = document.createElement('canvas');\n        // @ts-ignore\n        canvas.setAttribute('width', \"\".concat(img.width));\n        // @ts-ignore\n        canvas.setAttribute('height', \"\".concat(img.height));\n        var context = canvas.getContext('2d');\n        if (context) {\n            context.putImageData(img, 0, 0);\n            if (!width) {\n                // @ts-ignore\n                $el.setAttribute('width', \"\".concat(img.width));\n                // this.attr('width', img.width);\n            }\n            if (!height) {\n                // @ts-ignore\n                $el.setAttribute('height', \"\".concat(img.height));\n                // this.attr('height', img.height);\n            }\n            $el.setAttribute('href', canvas.toDataURL());\n        }\n    }\n}\n\nfunction updateLineElementAttribute($el, parsedStyle) {\n    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n    var startOffsetX = 0;\n    var startOffsetY = 0;\n    var endOffsetX = 0;\n    var endOffsetY = 0;\n    var rad = 0;\n    var x;\n    var y;\n    if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n        x = x2 - x1;\n        y = y2 - y1;\n        rad = Math.atan2(y, x);\n        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n    }\n    if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n        x = x1 - x2;\n        y = y1 - y2;\n        rad = Math.atan2(y, x);\n        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n    }\n    // @see https://github.com/antvis/g/issues/1038\n    $el.setAttribute('x1', \"\".concat(x1 - defX + startOffsetX));\n    $el.setAttribute('y1', \"\".concat(y1 - defY + startOffsetY));\n    $el.setAttribute('x2', \"\".concat(x2 - defX + endOffsetX));\n    $el.setAttribute('y2', \"\".concat(y2 - defY + endOffsetY));\n}\n\nfunction updatePathElementAttribute($el, parsedStyle) {\n    var path = parsedStyle.path, _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n    var startOffsetX = 0;\n    var startOffsetY = 0;\n    var endOffsetX = 0;\n    var endOffsetY = 0;\n    var rad = 0;\n    var x;\n    var y;\n    if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n        var _c = tslib.__read(markerStart.parentNode.getStartTangent(), 2), p1 = _c[0], p2 = _c[1];\n        x = p1[0] - p2[0];\n        y = p1[1] - p2[1];\n        rad = Math.atan2(y, x);\n        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n    }\n    if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n        var _d = tslib.__read(markerEnd.parentNode.getEndTangent(), 2), p1 = _d[0], p2 = _d[1];\n        x = p1[0] - p2[0];\n        y = p1[1] - p2[1];\n        rad = Math.atan2(y, x);\n        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n    }\n    $el.setAttribute('d', gLite.translatePathToString(path.absolutePath, defX, defY, startOffsetX, startOffsetY, endOffsetX, endOffsetY));\n}\n\nfunction updatePolylineElementAttribute($el, parsedStyle) {\n    var points = parsedStyle.points.points, _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerStartOffset = parsedStyle.markerStartOffset, markerEnd = parsedStyle.markerEnd, markerEndOffset = parsedStyle.markerEndOffset;\n    var length = points.length;\n    if (points && length >= 2) {\n        var startOffsetX_1 = 0;\n        var startOffsetY_1 = 0;\n        var endOffsetX_1 = 0;\n        var endOffsetY_1 = 0;\n        var rad = 0;\n        var x = void 0;\n        var y = void 0;\n        if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n            x = points[1][0] - points[0][0];\n            y = points[1][1] - points[0][1];\n            rad = Math.atan2(y, x);\n            startOffsetX_1 = Math.cos(rad) * (markerStartOffset || 0);\n            startOffsetY_1 = Math.sin(rad) * (markerStartOffset || 0);\n        }\n        if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n            x = points[length - 2][0] - points[length - 1][0];\n            y = points[length - 2][1] - points[length - 1][1];\n            rad = Math.atan2(y, x);\n            endOffsetX_1 = Math.cos(rad) * (markerEndOffset || 0);\n            endOffsetY_1 = Math.sin(rad) * (markerEndOffset || 0);\n        }\n        $el.setAttribute('points', points\n            .map(function (point, i) {\n            var offsetX = 0;\n            var offsetY = 0;\n            if (i === 0) {\n                offsetX = startOffsetX_1;\n                offsetY = startOffsetY_1;\n            }\n            else if (i === length - 1) {\n                offsetX = endOffsetX_1;\n                offsetY = endOffsetY_1;\n            }\n            return \"\".concat(point[0] - defX + offsetX, \",\").concat(point[1] - defY + offsetY);\n        })\n            .join(' '));\n    }\n}\n\nfunction updateRectElementAttribute($el, parsedStyle) {\n    var radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;\n    // CSSKeyword: auto\n    if (!isFinite(width) || !isFinite(height)) {\n        return;\n    }\n    var hasRadius = radius && radius.some(function (r) { return r !== 0; });\n    var d = '';\n    if (!hasRadius) {\n        d = \"M 0,0 l \".concat(width, \",0 l 0,\").concat(height, \" l\").concat(-width, \" 0 z\");\n    }\n    else {\n        var _a = tslib.__read(radius.map(function (r) {\n            return util.clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));\n        }), 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];\n        var signX = width > 0 ? 1 : -1;\n        var signY = height > 0 ? 1 : -1;\n        // sweep-flag @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths#arcs\n        var sweepFlag = signX + signY !== 0 ? 1 : 0;\n        d = [\n            [\"M \".concat(signX * tlr, \",0\")],\n            [\"l \".concat(width - signX * (tlr + trr), \",0\")],\n            [\"a \".concat(trr, \",\").concat(trr, \",0,0,\").concat(sweepFlag, \",\").concat(signX * trr, \",\").concat(signY * trr)],\n            [\"l 0,\".concat(height - signY * (trr + brr))],\n            [\"a \".concat(brr, \",\").concat(brr, \",0,0,\").concat(sweepFlag, \",\").concat(-signX * brr, \",\").concat(signY * brr)],\n            [\"l \".concat(signX * (brr + blr) - width, \",0\")],\n            [\"a \".concat(blr, \",\").concat(blr, \",0,0,\").concat(sweepFlag, \",\").concat(-signX * blr, \",\").concat(-signY * blr)],\n            [\"l 0,\".concat(signY * (blr + tlr) - height)],\n            [\"a \".concat(tlr, \",\").concat(tlr, \",0,0,\").concat(sweepFlag, \",\").concat(signX * tlr, \",\").concat(-signY * tlr)],\n            ['z'],\n        ].join(' ');\n    }\n    $el.setAttribute('d', d);\n}\n\nfunction createSVGElement(type, doc) {\n    return (doc || document).createElementNS('http://www.w3.org/2000/svg', type);\n}\n\nvar FILTER_PREFIX = 'g-filter-';\n/**\n * use SVG filters, eg. blur, brightness, contrast...\n * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/filter\n */\nfunction createOrUpdateFilter(document, $def, object, $el, filters) {\n    // eg. filter=\"url(#f1) url(#f2)\"\n    var filterName = FILTER_PREFIX + object.entity;\n    var $existedFilters = $def.querySelectorAll(\"[name=\".concat(filterName, \"]\"));\n    if ($existedFilters.length) {\n        $existedFilters.forEach(function ($filter) {\n            $def.removeChild($filter);\n        });\n    }\n    if (filters.length === 0) {\n        // 'none'\n        $el === null || $el === void 0 ? void 0 : $el.removeAttribute('filter');\n    }\n    else {\n        var filterIds_1 = filters.map(function (_a, i) {\n            var name = _a.name, params = _a.params;\n            var $filter = createSVGElement('filter', document);\n            // @see https://github.com/antvis/g/issues/1025\n            $filter.setAttribute('filterUnits', 'userSpaceOnUse');\n            if (name === 'blur') {\n                createBlur(document, $filter, params);\n            }\n            else if (name === 'brightness') {\n                createBrightness(document, $filter, params);\n            }\n            else if (name === 'drop-shadow') {\n                createDropShadow(document, $filter, params);\n            }\n            else if (name === 'contrast') {\n                createContrast(document, $filter, params);\n            }\n            else if (name === 'grayscale') {\n                createGrayscale(document, $filter, params);\n            }\n            else if (name === 'sepia') {\n                createSepia(document, $filter, params);\n            }\n            else if (name === 'saturate') {\n                createSaturate(document, $filter, params);\n            }\n            else if (name === 'hue-rotate') {\n                createHueRotate(document, $filter, params);\n            }\n            else if (name === 'invert') {\n                createInvert(document, $filter, params);\n            }\n            $filter.id = \"\".concat(filterName, \"-\").concat(i);\n            $filter.setAttribute('name', filterName);\n            $def.appendChild($filter);\n            return $filter.id;\n        });\n        // @see https://github.com/antvis/G/issues/1114\n        setTimeout(function () {\n            $el === null || $el === void 0 ? void 0 : $el.setAttribute('filter', filterIds_1.map(function (filterId) { return \"url(#\".concat(filterId, \")\"); }).join(' '));\n        });\n    }\n}\nfunction convertToAbsoluteValue(param) {\n    return param.unit === gLite.UnitType.kPercentage ? param.value / 100 : param.value;\n}\n/**\n * @see https://drafts.fxtf.org/filter-effects/#blurEquivalent\n */\nfunction createBlur(document, $filter, params) {\n    var $feGaussianBlur = createSVGElement('feGaussianBlur', document);\n    $feGaussianBlur.setAttribute('in', 'SourceGraphic');\n    $feGaussianBlur.setAttribute('stdDeviation', \"\".concat(params[0].value));\n    $filter.appendChild($feGaussianBlur);\n}\nfunction createFeComponentTransfer(document, $filter, _a) {\n    var type = _a.type, slope = _a.slope, intercept = _a.intercept, tableValues = _a.tableValues;\n    var $feComponentTransfer = createSVGElement('feComponentTransfer', document);\n    [\n        createSVGElement('feFuncR', document),\n        createSVGElement('feFuncG', document),\n        createSVGElement('feFuncB', document),\n    ].forEach(function ($feFunc) {\n        $feFunc.setAttribute('type', type);\n        if (type === 'table') {\n            $feFunc.setAttribute('tableValues', \"\".concat(tableValues));\n        }\n        else {\n            $feFunc.setAttribute('slope', \"\".concat(slope));\n            $feFunc.setAttribute('intercept', \"\".concat(intercept));\n        }\n        $feComponentTransfer.appendChild($feFunc);\n    });\n    $filter.appendChild($feComponentTransfer);\n}\nfunction createContrast(document, $filter, params) {\n    var slope = convertToAbsoluteValue(params[0]);\n    createFeComponentTransfer(document, $filter, {\n        type: 'linear',\n        slope: slope,\n        intercept: -(0.5 * slope) + 0.5,\n    });\n}\nfunction createInvert(document, $filter, params) {\n    var amount = convertToAbsoluteValue(params[0]);\n    createFeComponentTransfer(document, $filter, {\n        type: 'table',\n        tableValues: \"\".concat(amount, \" \").concat(1 - amount),\n    });\n}\nfunction createBrightness(document, $filter, params) {\n    var slope = convertToAbsoluteValue(params[0]);\n    createFeComponentTransfer(document, $filter, {\n        type: 'linear',\n        slope: slope,\n        intercept: 0,\n    });\n}\nfunction createSaturate(document, $filter, params) {\n    var amount = convertToAbsoluteValue(params[0]);\n    var $feColorMatrix = createSVGElement('feColorMatrix', document);\n    $feColorMatrix.setAttribute('type', 'saturate');\n    $feColorMatrix.setAttribute('values', \"\".concat(amount));\n    $filter.appendChild($feColorMatrix);\n}\nfunction createHueRotate(document, $filter, params) {\n    var $feColorMatrix = createSVGElement('feColorMatrix', document);\n    $feColorMatrix.setAttribute('type', 'hueRotate');\n    // $feColorMatrix.setAttribute('values', `${params[0].to(UnitType.kDegrees).value}`);\n    // FIXME: convert to degrees\n    $feColorMatrix.setAttribute('values', \"\".concat(params[0].value));\n    $filter.appendChild($feColorMatrix);\n}\nfunction createDropShadow(document, $filter, params) {\n    var shadowOffsetX = params[0].value;\n    var shadowOffsetY = params[1].value;\n    var shadowBlur = params[2].value;\n    // @ts-ignore\n    var shadowColor = params[3].formatted;\n    var $feGaussianBlur = createSVGElement('feGaussianBlur', document);\n    $feGaussianBlur.setAttribute('in', 'SourceAlpha');\n    $feGaussianBlur.setAttribute('stdDeviation', \"\".concat(shadowBlur));\n    $filter.appendChild($feGaussianBlur);\n    var $feOffset = createSVGElement('feOffset', document);\n    $feOffset.setAttribute('dx', \"\".concat(shadowOffsetX));\n    $feOffset.setAttribute('dy', \"\".concat(shadowOffsetY));\n    $feOffset.setAttribute('result', 'offsetblur');\n    $filter.appendChild($feOffset);\n    var $feFlood = createSVGElement('feFlood', document);\n    $feFlood.setAttribute('flood-color', shadowColor);\n    $filter.appendChild($feFlood);\n    var $feComposite = createSVGElement('feComposite', document);\n    $feComposite.setAttribute('in2', 'offsetblur');\n    $feComposite.setAttribute('operator', 'in');\n    $filter.appendChild($feComposite);\n    var $feMerge = createSVGElement('feMerge', document);\n    $filter.appendChild($feMerge);\n    var $feMergeNode1 = createSVGElement('feMergeNode', document);\n    var $feMergeNode2 = createSVGElement('feMergeNode', document);\n    $feMergeNode2.setAttribute('in', 'SourceGraphic');\n    $feMerge.appendChild($feMergeNode1);\n    $feMerge.appendChild($feMergeNode2);\n}\nfunction createFeColorMatrix(document, $filter, matrix) {\n    var $feColorMatrix = createSVGElement('feColorMatrix', document);\n    $feColorMatrix.setAttribute('type', 'matrix');\n    $feColorMatrix.setAttribute('values', matrix.join(' '));\n    $filter.appendChild($feColorMatrix);\n}\n/**\n * @see https://drafts.fxtf.org/filter-effects/#grayscaleEquivalent\n */\nfunction createGrayscale(document, $filter, params) {\n    var amount = convertToAbsoluteValue(params[0]);\n    createFeColorMatrix(document, $filter, [\n        0.2126 + 0.7874 * (1 - amount),\n        0.7152 - 0.7152 * (1 - amount),\n        0.0722 - 0.0722 * (1 - amount),\n        0,\n        0,\n        0.2126 - 0.2126 * (1 - amount),\n        0.7152 + 0.2848 * (1 - amount),\n        0.0722 - 0.0722 * (1 - amount),\n        0,\n        0,\n        0.2126 - 0.2126 * (1 - amount),\n        0.7152 - 0.7152 * (1 - amount),\n        0.0722 + 0.9278 * (1 - amount),\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n    ]);\n}\n/**\n * @see https://drafts.fxtf.org/filter-effects/#sepiaEquivalent\n */\nfunction createSepia(document, $filter, params) {\n    var amount = convertToAbsoluteValue(params[0]);\n    createFeColorMatrix(document, $filter, [\n        0.393 + 0.607 * (1 - amount),\n        0.769 - 0.769 * (1 - amount),\n        0.189 - 0.189 * (1 - amount),\n        0,\n        0,\n        0.349 - 0.349 * (1 - amount),\n        0.686 + 0.314 * (1 - amount),\n        0.168 - 0.168 * (1 - amount),\n        0,\n        0,\n        0.272 - 0.272 * (1 - amount),\n        0.534 - 0.534 * (1 - amount),\n        0.131 + 0.869 * (1 - amount),\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n    ]);\n}\n\nvar PATTERN_PREFIX = 'g-pattern-';\nvar cacheKey2IDMap = {};\nvar counter = 0;\nfunction resetPatternCounter() {\n    counter = 0;\n    cacheKey2IDMap = {};\n}\nfunction createOrUpdateGradientAndPattern(document, $def, object, $el, parsedColor, name, createImage, plugin) {\n    // eg. clipPath don't have fill/stroke\n    if (!parsedColor) {\n        return '';\n    }\n    if (gLite.isCSSRGB(parsedColor)) {\n        // keep using currentColor @see https://github.com/d3/d3-axis/issues/49\n        if (object.style[name] === 'currentColor') {\n            $el === null || $el === void 0 ? void 0 : $el.setAttribute(name, 'currentColor');\n        }\n        else {\n            // constant value, eg. '#fff'\n            $el === null || $el === void 0 ? void 0 : $el.setAttribute(name, parsedColor.isNone ? 'none' : parsedColor.toString());\n        }\n    }\n    else if (gLite.isPattern(parsedColor)) {\n        var patternId = createOrUpdatePattern(document, $def, object, parsedColor, createImage, plugin);\n        // use style instead of attribute when applying <pattern>\n        // @see https://stackoverflow.com/a/7723115\n        $el.style[name] = \"url(#\".concat(patternId, \")\");\n        return patternId;\n    }\n    else {\n        if (parsedColor.length === 1) {\n            var gradientId = createOrUpdateGradient(document, object, $def, $el, parsedColor[0]);\n            $el === null || $el === void 0 ? void 0 : $el.setAttribute(name, \"url(#\".concat(gradientId, \")\"));\n            return gradientId;\n        }\n        else {\n            // @see https://stackoverflow.com/questions/20671502/can-i-blend-gradients-in-svg\n            var filterId = createOrUpdateMultiGradient(document, object, $def, $el, parsedColor);\n            $el === null || $el === void 0 ? void 0 : $el.setAttribute('filter', \"url(#\".concat(filterId, \")\"));\n            $el === null || $el === void 0 ? void 0 : $el.setAttribute('fill', 'black');\n            return filterId;\n        }\n    }\n    return '';\n}\nfunction generateCacheKey(src, options) {\n    if (options === void 0) { options = {}; }\n    var cacheKey = '';\n    if (gLite.isCSSGradientValue(src)) {\n        var type = src.type, value = src.value;\n        if (type === gLite.GradientType.LinearGradient ||\n            type === gLite.GradientType.RadialGradient) {\n            // @ts-ignore\n            var _a = tslib.__assign(tslib.__assign({}, value), options), type_1 = _a.type, width = _a.width, height = _a.height, steps = _a.steps, angle = _a.angle, cx = _a.cx, cy = _a.cy, size = _a.size;\n            cacheKey = \"gradient-\".concat(type_1, \"-\").concat((angle === null || angle === void 0 ? void 0 : angle.toString()) || 0, \"-\").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, \"-\").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, \"-\").concat((size === null || size === void 0 ? void 0 : size.toString()) || 0, \"-\").concat(width, \"-\").concat(height, \"-\").concat(steps\n                .map(function (_a) {\n                var offset = _a.offset, color = _a.color;\n                return \"\".concat(offset).concat(color);\n            })\n                .join('-'));\n        }\n    }\n    else if (gLite.isPattern(src)) {\n        if (util.isString(src.image)) {\n            cacheKey = \"pattern-\".concat(src.image, \"-\").concat(src.repetition);\n        }\n        else if (src.image.nodeName === 'rect') {\n            // use rect's entity as key\n            cacheKey = \"pattern-rect-\".concat(src.image.entity);\n        }\n        else {\n            cacheKey = \"pattern-\".concat(counter);\n        }\n    }\n    if (cacheKey) {\n        if (!cacheKey2IDMap[cacheKey]) {\n            cacheKey2IDMap[cacheKey] = PATTERN_PREFIX + \"\".concat(counter++);\n        }\n    }\n    return cacheKey2IDMap[cacheKey];\n}\nfunction formatTransform(transform) {\n    // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/patternTransform\n    // should remove unit: rotate(20deg) -> rotate(20)\n    return gLite.parseTransform(transform)\n        .map(function (parsed) {\n        var t = parsed.t, d = parsed.d;\n        if (t === 'translate') {\n            return \"translate(\".concat(d[0].value, \" \").concat(d[1].value, \")\");\n        }\n        else if (t === 'translatex') {\n            return \"translate(\".concat(d[0].value, \" 0)\");\n        }\n        else if (t === 'translatey') {\n            return \"translate(0 \".concat(d[0].value, \")\");\n        }\n        else if (t === 'rotate') {\n            return \"rotate(\".concat(d[0].value, \")\");\n        }\n        else if (t === 'scale') {\n            // scale(1) scale(1, 1)\n            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1, 1];\n            return \"scale(\".concat(newScale[0], \", \").concat(newScale[1], \")\");\n        }\n        else if (t === 'scalex') {\n            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1];\n            return \"scale(\".concat(newScale[0], \", 1)\");\n        }\n        else if (t === 'scaley') {\n            var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [1];\n            return \"scale(1, \".concat(newScale[0], \")\");\n        }\n        else if (t === 'skew') {\n            var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [0, 0];\n            return \"skewX(\".concat(newSkew[0], \") skewY(\").concat(newSkew[1], \")\");\n        }\n        else if (t === 'skewx') {\n            var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [0];\n            return \"skewX(\".concat(newSkew[0], \")\");\n        }\n        else if (t === 'skewy') {\n            var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) { return s.value; })) || [0];\n            return \"skewY(\".concat(newSkew[0], \")\");\n        }\n        else if (t === 'matrix') {\n            var _a = tslib.__read(d.map(function (s) { return s.value; }), 6), a = _a[0], b = _a[1], c = _a[2], dd = _a[3], tx = _a[4], ty = _a[5];\n            return \"matrix(\".concat(a, \" \").concat(b, \" \").concat(c, \" \").concat(dd, \" \").concat(tx, \" \").concat(ty, \")\");\n        }\n    })\n        .join(' ');\n}\nfunction create$Pattern(document, $def, object, pattern, patternId, width, height) {\n    var repetition = pattern.repetition, transform = pattern.transform;\n    // @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/pattern\n    var $pattern = createSVGElement('pattern', document);\n    if (transform) {\n        $pattern.setAttribute('patternTransform', formatTransform(transform));\n    }\n    $pattern.setAttribute('patternUnits', 'userSpaceOnUse');\n    $pattern.id = patternId;\n    $def.appendChild($pattern);\n    $pattern.setAttribute('x', '0');\n    $pattern.setAttribute('y', '0');\n    var halfExtents = object.getGeometryBounds().halfExtents;\n    // There is no equivalent to CSS no-repeat for SVG patterns\n    // @see https://stackoverflow.com/a/33481956\n    var patternWidth = width;\n    var patternHeight = height;\n    if (repetition === 'repeat-x') {\n        patternHeight = halfExtents[1] * 2;\n    }\n    else if (repetition === 'repeat-y') {\n        patternWidth = halfExtents[0] * 2;\n    }\n    else if (repetition === 'no-repeat') {\n        patternWidth = halfExtents[0] * 2;\n        patternHeight = halfExtents[1] * 2;\n    }\n    $pattern.setAttribute('width', \"\".concat(patternWidth));\n    $pattern.setAttribute('height', \"\".concat(patternHeight));\n    return $pattern;\n}\nfunction createOrUpdatePattern(document, $def, object, pattern, createImage, plugin) {\n    var patternId = generateCacheKey(pattern);\n    var $existed = $def.querySelector(\"#\".concat(patternId));\n    if (!$existed) {\n        var image = pattern.image;\n        var imageURL = '';\n        if (util.isString(image)) {\n            imageURL = image;\n        }\n        else {\n            if (gLite.isBrowser) {\n                if (image instanceof HTMLImageElement) {\n                    imageURL = image.src;\n                }\n                else if (image instanceof HTMLCanvasElement) {\n                    imageURL = image.toDataURL();\n                }\n                else ;\n            }\n        }\n        if (imageURL) {\n            var $image_1 = createSVGElement('image', document);\n            // use href instead of xlink:href\n            // @see https://stackoverflow.com/a/13379007\n            $image_1.setAttribute('href', imageURL);\n            var img_1;\n            if (createImage) {\n                img_1 = createImage(imageURL);\n            }\n            else if (gLite.isBrowser) {\n                img_1 = new window.Image();\n            }\n            if (!imageURL.match(/^data:/i)) {\n                img_1.crossOrigin = 'Anonymous';\n                $image_1.setAttribute('crossorigin', 'anonymous');\n            }\n            img_1.src = imageURL;\n            var onload_1 = function () {\n                var $pattern = create$Pattern(document, $def, object, pattern, patternId, img_1.width, img_1.height);\n                $def.appendChild($pattern);\n                $pattern.appendChild($image_1);\n                $image_1.setAttribute('x', '0');\n                $image_1.setAttribute('y', '0');\n                $image_1.setAttribute('width', \"\".concat(img_1.width));\n                $image_1.setAttribute('height', \"\".concat(img_1.height));\n            };\n            if (img_1.complete) {\n                onload_1();\n            }\n            else {\n                img_1.onload = onload_1;\n                // Fix onload() bug in IE9\n                // img.src = img.src;\n            }\n        }\n        if (image.nodeName === 'rect') {\n            var _a = image.parsedStyle, width = _a.width, height = _a.height;\n            var $pattern = create$Pattern(document, $def, image, pattern, patternId, width, height);\n            // traverse subtree of pattern\n            image.forEach(function (object) {\n                plugin.createSVGDom(document, object, null);\n                // @ts-ignore\n                var svgElement = object.elementSVG;\n                // apply local RTS transformation to <group> wrapper\n                // account for anchor\n                var localTransform = object.getLocalTransform();\n                plugin.applyTransform(svgElement.$groupEl, localTransform);\n            });\n            // @ts-ignore\n            var svgElement = image.elementSVG;\n            $pattern.appendChild(svgElement.$groupEl);\n        }\n    }\n    return patternId;\n}\nfunction createOrUpdateGradient(document, object, $def, $el, parsedColor) {\n    var bounds = object.getGeometryBounds();\n    var width = (bounds && bounds.halfExtents[0] * 2) || 0;\n    var height = (bounds && bounds.halfExtents[1] * 2) || 0;\n    var gradientId = generateCacheKey(parsedColor, { width: width, height: height });\n    var $existed = $def.querySelector(\"#\".concat(gradientId));\n    if (!$existed) {\n        // <linearGradient> <radialGradient>\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/linearGradient\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/radialGradient\n        $existed = createSVGElement(parsedColor.type === gLite.GradientType.LinearGradient\n            ? 'linearGradient'\n            : 'radialGradient', document);\n        // @see https://github.com/antvis/g/issues/1025\n        $existed.setAttribute('gradientUnits', 'userSpaceOnUse');\n        // add stops\n        var innerHTML_1 = '';\n        parsedColor.value.steps\n            // sort by offset @see https://github.com/antvis/G/issues/1171\n            .sort(function (a, b) { return a.offset.value - b.offset.value; })\n            .forEach(function (_a) {\n            var offset = _a.offset, color = _a.color;\n            // TODO: support absolute unit like `px`\n            innerHTML_1 += \"<stop offset=\\\"\".concat(offset.value / 100, \"\\\" stop-color=\\\"\").concat(color, \"\\\"></stop>\");\n        });\n        $existed.innerHTML = innerHTML_1;\n        $existed.id = gradientId;\n        $def.appendChild($existed);\n    }\n    if (parsedColor.type === gLite.GradientType.LinearGradient) {\n        var angle = parsedColor.value.angle;\n        var _a = gLite.computeLinearGradient(width, height, angle), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\n        $existed.setAttribute('x1', \"\".concat(x1));\n        $existed.setAttribute('y1', \"\".concat(y1));\n        $existed.setAttribute('x2', \"\".concat(x2));\n        $existed.setAttribute('y2', \"\".concat(y2));\n        // $existed.setAttribute('gradientTransform', `rotate(${angle})`);\n    }\n    else {\n        var _b = parsedColor.value, cx = _b.cx, cy = _b.cy, size = _b.size;\n        var _c = gLite.computeRadialGradient(width, height, cx, cy, size), x = _c.x, y = _c.y, r = _c.r;\n        $existed.setAttribute('cx', \"\".concat(x));\n        $existed.setAttribute('cy', \"\".concat(y));\n        $existed.setAttribute('r', \"\".concat(r));\n    }\n    return gradientId;\n}\nfunction createOrUpdateMultiGradient(document, object, $def, $el, gradients) {\n    var filterId = FILTER_PREFIX + object.entity + '-gradient';\n    var $existed = $def.querySelector(\"#\".concat(filterId));\n    if (!$existed) {\n        $existed = createSVGElement('filter', document);\n        $existed.setAttribute('filterUnits', 'userSpaceOnUse');\n        // @see https://github.com/antvis/g/issues/1025\n        $existed.setAttribute('x', '0%');\n        $existed.setAttribute('y', '0%');\n        $existed.setAttribute('width', '100%');\n        $existed.setAttribute('height', '100%');\n        $existed.id = filterId;\n        $def.appendChild($existed);\n    }\n    /**\n     * <rect id=\"wave-rect\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"url(#wave)\"></rect>\n     * <filter id=\"blend-it\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\">\n          <feImage xlink:href=\"#wave-rect\" result=\"myWave\" x=\"100\" y=\"100\"/>\n          <feImage xlink:href=\"#ry-rect\" result=\"myRY\"  x=\"100\" y=\"100\"/>\n          <feBlend in=\"myWave\" in2=\"myRY\" mode=\"multiply\" result=\"blendedGrad\"/>\n          <feComposite in=\"blendedGrad\" in2=\"SourceGraphic\" operator=\"in\"/>\n      </filter>\n     */\n    var blended = 0;\n    gradients.forEach(function (gradient, i) {\n        var gradientId = createOrUpdateGradient(document, object, $def, $el, gradient);\n        var rectId = gradientId + '_rect';\n        var $rect = createSVGElement('rect', document);\n        $rect.setAttribute('x', '0');\n        $rect.setAttribute('y', '0');\n        $rect.setAttribute('width', '100%');\n        $rect.setAttribute('height', '100%');\n        $rect.setAttribute('fill', \"url(#\".concat(gradientId, \")\"));\n        $rect.id = rectId;\n        $def.appendChild($rect);\n        var $feImage = createSVGElement('feImage', document);\n        $feImage.setAttribute('href', \"#\".concat(rectId));\n        $feImage.setAttribute('result', \"\".concat(filterId, \"-\").concat(i));\n        $existed.appendChild($feImage);\n        if (i > 0) {\n            var $feBlend = createSVGElement('feBlend', document);\n            $feBlend.setAttribute('in', i === 1 ? \"\".concat(filterId, \"-\").concat(i - 1) : \"\".concat(filterId, \"-blended-\").concat(blended - 1));\n            $feBlend.setAttribute('in2', \"\".concat(filterId, \"-\").concat(i));\n            $feBlend.setAttribute('result', \"\".concat(filterId, \"-blended-\").concat(blended++));\n            // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode\n            $feBlend.setAttribute('mode', 'multiply');\n            $existed.appendChild($feBlend);\n        }\n    });\n    var $feComposite = createSVGElement('feComposite', document);\n    $feComposite.setAttribute('in', \"\".concat(filterId, \"-blended-\").concat(blended));\n    $feComposite.setAttribute('in2', 'SourceGraphic');\n    $feComposite.setAttribute('operator', 'in');\n    $existed.appendChild($feComposite);\n    return filterId;\n}\n\nvar FILTER_DROPSHADOW_PREFIX = 'g-filter-dropshadow-';\n/**\n * use SVG filters\n * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/filter\n */\nfunction createOrUpdateShadow(document, $def, object, $el, name) {\n    var _a = object.parsedStyle, shadowType = _a.shadowType, shadowBlur = _a.shadowBlur, shadowColor = _a.shadowColor, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY;\n    var hasShadow = !util.isNil(shadowColor) && shadowBlur > 0;\n    var shadowId = FILTER_DROPSHADOW_PREFIX + object.entity;\n    var $existedFilter = $def.querySelector(\"#\".concat(shadowId));\n    if ($existedFilter) {\n        var existedShadowType = $existedFilter.getAttribute('data-type');\n        if (existedShadowType !== shadowType || !hasShadow) {\n            // remove existed shadow\n            $existedFilter.remove();\n            $existedFilter = null;\n        }\n    }\n    // <Group> also has shadowType as its default value\n    // only apply shadow when blur > 0\n    if (hasShadow) {\n        // use filter <feDropShadow>\n        // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDropShadow\n        $el === null || $el === void 0 ? void 0 : $el.setAttribute('filter', \"url(#\".concat(shadowId, \")\"));\n    }\n    else {\n        $el === null || $el === void 0 ? void 0 : $el.removeAttribute('filter');\n        return;\n    }\n    if (!$existedFilter) {\n        $existedFilter = createSVGElement('filter', document);\n        $existedFilter.setAttribute('data-type', shadowType);\n        if (shadowType === 'outer') {\n            var $feDropShadow = createSVGElement('feDropShadow', document);\n            $feDropShadow.setAttribute('dx', \"\".concat((shadowOffsetX || 0) / 2));\n            $feDropShadow.setAttribute('dy', \"\".concat((shadowOffsetY || 0) / 2));\n            $feDropShadow.setAttribute('stdDeviation', \"\".concat((shadowBlur || 0) / 4));\n            $feDropShadow.setAttribute('flood-color', shadowColor.toString());\n            $existedFilter.appendChild($feDropShadow);\n        }\n        else if (shadowType === 'inner') {\n            var $feComponentTransfer = createSVGElement('feComponentTransfer', document);\n            $feComponentTransfer.setAttribute('in', 'SourceAlpha');\n            var $feFuncA = createSVGElement('feFuncA', document);\n            $feFuncA.setAttribute('type', 'table');\n            $feFuncA.setAttribute('tableValues', '1 0');\n            $feComponentTransfer.appendChild($feFuncA);\n            $existedFilter.appendChild($feComponentTransfer);\n            var $feGaussianBlur = createSVGElement('feGaussianBlur', document);\n            $feGaussianBlur.setAttribute('stdDeviation', \"\".concat((shadowBlur || 0) / 4));\n            $existedFilter.appendChild($feGaussianBlur);\n            var $feOffset = createSVGElement('feOffset', document);\n            $feOffset.setAttribute('dx', \"\".concat((shadowOffsetX || 0) / 2));\n            $feOffset.setAttribute('dy', \"\".concat((shadowOffsetY || 0) / 2));\n            $feOffset.setAttribute('result', 'offsetblur');\n            $existedFilter.appendChild($feOffset);\n            var $feFlood = createSVGElement('feFlood', document);\n            $feFlood.setAttribute('flood-color', shadowColor.toString());\n            $feFlood.setAttribute('result', 'color');\n            $existedFilter.appendChild($feFlood);\n            var $feComposite = createSVGElement('feComposite', document);\n            $feComposite.setAttribute('in2', 'offsetblur');\n            $feComposite.setAttribute('operator', 'in');\n            $existedFilter.appendChild($feComposite);\n            var $feComposite2 = createSVGElement('feComposite', document);\n            $feComposite2.setAttribute('in2', 'SourceAlpha');\n            $feComposite2.setAttribute('operator', 'in');\n            $existedFilter.appendChild($feComposite2);\n            var $feMerge = createSVGElement('feMerge', document);\n            $existedFilter.appendChild($feMerge);\n            var $feMergeNode = createSVGElement('feMergeNode', document);\n            $feMergeNode.setAttribute('in', 'SourceGraphic');\n            var $feMergeNode2 = createSVGElement('feMergeNode', document);\n            $feMerge.appendChild($feMergeNode);\n            $feMerge.appendChild($feMergeNode2);\n        }\n        $existedFilter.id = shadowId;\n        // @see https://github.com/antvis/g/issues/1025\n        $existedFilter.setAttribute('filterUnits', 'userSpaceOnUse');\n        $def.appendChild($existedFilter);\n        return;\n    }\n    if (shadowType === 'inner') {\n        var $feGaussianBlur = $existedFilter.children[1];\n        var $feOffset = $existedFilter.children[2];\n        var $feFlood = $existedFilter.children[3];\n        if (name === 'shadowColor') {\n            $feFlood.setAttribute('flood-color', shadowColor.toString());\n        }\n        else if (name === 'shadowBlur') {\n            // half the blur radius\n            // @see https://drafts.csswg.org/css-backgrounds/#shadow-blur\n            // @see https://css-tricks.com/breaking-css-box-shadow-vs-drop-shadow/\n            $feGaussianBlur.setAttribute('stdDeviation', \"\".concat((shadowBlur || 0) / 4));\n        }\n        else if (name === 'shadowOffsetX') {\n            $feOffset.setAttribute('dx', \"\".concat((shadowOffsetX || 0) / 2));\n        }\n        else if (name === 'shadowOffsetY') {\n            $feOffset.setAttribute('dy', \"\".concat((shadowOffsetY || 0) / 2));\n        }\n    }\n    else if (shadowType === 'outer') {\n        var $feDropShadow = $existedFilter.children[0];\n        if (name === 'shadowColor') {\n            $feDropShadow.setAttribute('flood-color', shadowColor.toString());\n        }\n        else if (name === 'shadowBlur') {\n            // half the blur radius\n            // @see https://drafts.csswg.org/css-backgrounds/#shadow-blur\n            // @see https://css-tricks.com/breaking-css-box-shadow-vs-drop-shadow/\n            $feDropShadow.setAttribute('stdDeviation', \"\".concat((shadowBlur || 0) / 4));\n        }\n        else if (name === 'shadowOffsetX') {\n            $feDropShadow.setAttribute('dx', \"\".concat((shadowOffsetX || 0) / 2));\n        }\n        else if (name === 'shadowOffsetY') {\n            $feDropShadow.setAttribute('dy', \"\".concat((shadowOffsetY || 0) / 2));\n        }\n    }\n}\n\nvar urlRegexp = /url\\(\"?#(.*)\\)/;\nvar DefElementManager = /** @class */ (function () {\n    function DefElementManager(context) {\n        this.context = context;\n        this.gradientCache = {};\n    }\n    DefElementManager.prototype.getDefElement = function () {\n        return this.$def;\n    };\n    DefElementManager.prototype.init = function () {\n        var document = this.context.config.document;\n        var $svg = this.context.contextService.getContext();\n        this.$def = createSVGElement('defs', document);\n        $svg.appendChild(this.$def);\n    };\n    DefElementManager.prototype.clear = function (entity) {\n        var _this = this;\n        Object.keys(this.gradientCache).forEach(function (id) {\n            _this.clearUnusedDefElement(_this.gradientCache, id, entity);\n        });\n    };\n    DefElementManager.prototype.clearUnusedDefElement = function (cache, id, entity) {\n        if (cache[id] && cache[id].size === 1 && cache[id].has(entity)) {\n            var targetElement = this.$def.querySelector(\"#\".concat(id));\n            if (targetElement) {\n                this.$def.removeChild(targetElement);\n            }\n        }\n    };\n    DefElementManager.prototype.createOrUpdateGradientAndPattern = function (object, $el, parsedColor, name, plugin) {\n        var _a = this.context.config, doc = _a.document, createImage = _a.createImage;\n        if ($el) {\n            var attributeValue = '';\n            if (gLite.isPattern(parsedColor)) {\n                // `fill: url(#${patternId})`\n                attributeValue = $el.style[name];\n            }\n            else {\n                // `url(#${gradientId})`\n                attributeValue = $el.getAttribute(name) || '';\n            }\n            var matches = attributeValue.match(urlRegexp);\n            if (matches && matches.length > 1) {\n                this.clearUnusedDefElement(this.gradientCache, matches[1].replace('\"', ''), object.entity);\n            }\n            var newDefElementId = createOrUpdateGradientAndPattern(doc || document, this.$def, object, $el, parsedColor, name, createImage, plugin);\n            if (newDefElementId) {\n                if (!this.gradientCache[newDefElementId]) {\n                    this.gradientCache[newDefElementId] = new Set();\n                }\n                this.gradientCache[newDefElementId].add(object.entity);\n            }\n        }\n    };\n    DefElementManager.prototype.createOrUpdateShadow = function (object, $el, name) {\n        var doc = this.context.config.document;\n        createOrUpdateShadow(doc || document, this.$def, object, $el, name);\n    };\n    DefElementManager.prototype.createOrUpdateFilter = function (object, $el, filters) {\n        var doc = this.context.config.document;\n        createOrUpdateFilter(doc || document, this.$def, object, $el, filters);\n    };\n    return DefElementManager;\n}());\n\nfunction numberToLongString(x) {\n    return x.toFixed(6).replace('.000000', '');\n}\nfunction convertHTML(str) {\n    var regex = /[&|<|>|\"|']/g;\n    return str.replace(regex, function (match) {\n        if (match === '&') {\n            return '&amp;';\n        }\n        else if (match === '<') {\n            return '&lt;';\n        }\n        else if (match === '>') {\n            return '&gt;';\n        }\n        else if (match === '\"') {\n            return '&quot;';\n        }\n        else {\n            return '&apos;';\n        }\n    });\n}\n\nvar SVG_ATTR_MAP = {\n    opacity: 'opacity',\n    fillStyle: 'fill',\n    fill: 'fill',\n    fillRule: 'fill-rule',\n    fillOpacity: 'fill-opacity',\n    strokeStyle: 'stroke',\n    strokeOpacity: 'stroke-opacity',\n    stroke: 'stroke',\n    clipPath: 'clip-path',\n    textPath: 'text-path',\n    r: 'r',\n    rx: 'rx',\n    ry: 'ry',\n    width: 'width',\n    height: 'height',\n    lineCap: 'stroke-linecap',\n    lineJoin: 'stroke-linejoin',\n    lineWidth: 'stroke-width',\n    lineDash: 'stroke-dasharray',\n    lineDashOffset: 'stroke-dashoffset',\n    miterLimit: 'stroke-miterlimit',\n    font: 'font',\n    fontSize: 'font-size',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    fontFamily: 'font-family',\n    letterSpacing: 'letter-spacing',\n    startArrow: 'marker-start',\n    endArrow: 'marker-end',\n    class: 'class',\n    id: 'id',\n    // style: 'style',\n    preserveAspectRatio: 'preserveAspectRatio',\n    visibility: 'visibility',\n    anchor: 'anchor',\n    shadowColor: 'flood-color',\n    shadowBlur: 'stdDeviation',\n    shadowOffsetX: 'dx',\n    shadowOffsetY: 'dy',\n    filter: 'filter',\n    innerHTML: 'innerHTML',\n    textAlign: 'text-anchor',\n    pointerEvents: 'pointer-events',\n};\nvar FORMAT_VALUE_MAP = {\n    textAlign: {\n        inherit: 'inherit',\n        left: 'left',\n        start: 'left',\n        center: 'middle',\n        right: 'end',\n        end: 'end',\n    },\n};\nvar DEFAULT_VALUE_MAP = {\n    textAlign: 'inherit',\n    // textBaseline: 'alphabetic',\n    // @see https://www.w3.org/TR/SVG/painting.html#LineCaps\n    lineCap: 'butt',\n    // @see https://www.w3.org/TR/SVG/painting.html#LineJoin\n    lineJoin: 'miter',\n    // @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/stroke-width\n    lineWidth: '1px',\n    opacity: '1',\n    fillOpacity: '1',\n    fillRule: 'nonzero',\n    strokeOpacity: '1',\n    strokeWidth: '0',\n    strokeMiterLimit: '4',\n    letterSpacing: '0',\n    fontSize: 'inherit',\n    fontFamily: 'inherit',\n    pointerEvents: 'auto',\n};\n/**\n * G_SVG_PREFIX + nodeName + entity\n *\n * eg. g_svg_circle_345\n */\nvar G_SVG_PREFIX = 'g-svg';\nvar CLIP_PATH_PREFIX = 'clip-path-';\nvar TEXT_PATH_PREFIX = 'text-path-';\nvar SVGRendererPlugin = /** @class */ (function () {\n    function SVGRendererPlugin(pluginOptions, defElementManager, context) {\n        this.pluginOptions = pluginOptions;\n        this.defElementManager = defElementManager;\n        this.context = context;\n        /**\n         * Will be used in g-plugin-svg-picker for finding relative SVG element of current DisplayObject.\n         */\n        this.svgElementMap = new WeakMap();\n        /**\n         * render at the end of frame\n         */\n        this.renderQueue = [];\n        /**\n         * dirty attributes at the end of frame\n         */\n        this.dirtyAttributes = new WeakMap();\n        /**\n         * reorder after mounted\n         */\n        this.pendingReorderQueue = new Set();\n        /**\n         * <use> elements in <clipPath>, which should be sync with clipPath\n         *\n         * @example\n         * <clipPath transform=\"matrix(1,0,0,1,-100,-155)\" id=\"clip-path-0-2\">\n         *  <use href=\"#g_svg_circle_0\" transform=\"matrix(1.477115,0,0,1.477115,150,150)\">\n         *  </use>\n         * </clipPath>\n         */\n        this.clipPathUseMap = new WeakMap();\n    }\n    SVGRendererPlugin.prototype.apply = function (context) {\n        var _this = this;\n        var renderingService = context.renderingService, renderingContext = context.renderingContext;\n        this.context = context;\n        // @ts-ignore\n        this.context.svgElementMap = this.svgElementMap;\n        var canvas = renderingContext.root.ownerDocument.defaultView;\n        var document = this.context.config.document;\n        var handleMounted = function (e) {\n            var object = e.target;\n            // should remove clipPath already existed in <defs>\n            var $useRefs = _this.clipPathUseMap.get(object);\n            if ($useRefs) {\n                var $def = _this.defElementManager.getDefElement();\n                var existed = $def.querySelector(\"#\".concat(_this.getId(object)));\n                if (existed) {\n                    existed.remove();\n                }\n            }\n            // create SVG DOM Node\n            _this.createSVGDom(document, object, _this.$camera);\n        };\n        var handleUnmounted = function (e) {\n            var object = e.target;\n            _this.defElementManager.clear(object.entity);\n            _this.clipPathUseMap.delete(object);\n            _this.removeSVGDom(object);\n        };\n        var reorderChildren = function (object) {\n            var _a, _b;\n            var parent = object.parentNode;\n            // @ts-ignore\n            var $groupEl = (_b = (_a = object.parentNode) === null || _a === void 0 ? void 0 : _a.elementSVG) === null || _b === void 0 ? void 0 : _b.$groupEl;\n            var children = ((parent === null || parent === void 0 ? void 0 : parent.children) || []).slice();\n            if ($groupEl) {\n                _this.reorderChildren(document, $groupEl, children);\n            }\n        };\n        var handleReparent = function (e) {\n            var object = e.target;\n            reorderChildren(object);\n        };\n        var handleAttributeChanged = function (e) {\n            var object = e.target;\n            // @see https://github.com/antvis/g/issues/994\n            // @ts-ignore\n            if (!object.elementSVG) {\n                return;\n            }\n            var attrName = e.attrName;\n            var attribtues = _this.dirtyAttributes.get(object);\n            if (!attribtues) {\n                _this.dirtyAttributes.set(object, []);\n                attribtues = _this.dirtyAttributes.get(object);\n            }\n            attribtues.push(attrName);\n        };\n        var handleGeometryBoundsChanged = function (e) {\n            var _a;\n            var object = e.target;\n            // @ts-ignore\n            var $el = (_a = object.elementSVG) === null || _a === void 0 ? void 0 : _a.$el;\n            var _b = object.parsedStyle, fill = _b.fill, stroke = _b.stroke, clipPath = _b.clipPath;\n            if (fill && !gLite.isCSSRGB(fill)) {\n                _this.defElementManager.createOrUpdateGradientAndPattern(object, $el, fill, 'fill', _this);\n            }\n            if (stroke && !gLite.isCSSRGB(stroke)) {\n                _this.defElementManager.createOrUpdateGradientAndPattern(object, $el, stroke, 'stroke', _this);\n            }\n            if (clipPath) {\n                var parentInvert = glMatrix.mat4.invert(glMatrix.mat4.create(), object.getWorldTransform());\n                var clipPathId = CLIP_PATH_PREFIX + clipPath.entity + '-' + object.entity;\n                var $def = _this.defElementManager.getDefElement();\n                var $existed = $def.querySelector(\"#\".concat(clipPathId));\n                if ($existed) {\n                    _this.applyTransform($existed, parentInvert);\n                }\n            }\n        };\n        renderingService.hooks.init.tap(SVGRendererPlugin.tag, function () {\n            var _a = _this.context.config, background = _a.background, document = _a.document;\n            // <defs>\n            _this.defElementManager.init();\n            var $svg = _this.context.contextService.getContext();\n            if (background) {\n                $svg.style.background = background;\n            }\n            // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/color-interpolation-filters\n            $svg.setAttribute('color-interpolation-filters', 'sRGB');\n            _this.$camera = createSVGElement('g', document);\n            _this.$camera.id = \"\".concat(G_SVG_PREFIX, \"-camera\");\n            _this.applyTransform(_this.$camera, _this.context.camera.getOrthoMatrix());\n            $svg.appendChild(_this.$camera);\n            canvas.addEventListener(gLite.ElementEvent.MOUNTED, handleMounted);\n            canvas.addEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n            canvas.addEventListener(gLite.ElementEvent.REPARENT, handleReparent);\n            canvas.addEventListener(gLite.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);\n            canvas.addEventListener(gLite.ElementEvent.BOUNDS_CHANGED, handleGeometryBoundsChanged);\n        });\n        renderingService.hooks.destroy.tap(SVGRendererPlugin.tag, function () {\n            canvas.removeEventListener(gLite.ElementEvent.MOUNTED, handleMounted);\n            canvas.removeEventListener(gLite.ElementEvent.UNMOUNTED, handleUnmounted);\n            canvas.removeEventListener(gLite.ElementEvent.REPARENT, handleReparent);\n            canvas.removeEventListener(gLite.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);\n            canvas.removeEventListener(gLite.ElementEvent.BOUNDS_CHANGED, handleGeometryBoundsChanged);\n            resetPatternCounter();\n        });\n        renderingService.hooks.render.tap(SVGRendererPlugin.tag, function (object) {\n            _this.renderQueue.push(object);\n        });\n        renderingService.hooks.beginFrame.tap(SVGRendererPlugin.tag, function () {\n            var doc = _this.context.config.document;\n            if (_this.pendingReorderQueue.size) {\n                _this.pendingReorderQueue.forEach(function (object) {\n                    var _a;\n                    var children = ((object === null || object === void 0 ? void 0 : object.children) || []).slice();\n                    var $parentGroupEl = \n                    // @ts-ignore\n                    (_a = object === null || object === void 0 ? void 0 : object.elementSVG) === null || _a === void 0 ? void 0 : _a.$groupEl;\n                    if ($parentGroupEl) {\n                        _this.reorderChildren(doc || document, $parentGroupEl, children || []);\n                    }\n                });\n                _this.pendingReorderQueue.clear();\n            }\n        });\n        renderingService.hooks.endFrame.tap(SVGRendererPlugin.tag, function () {\n            if (renderingContext.renderReasons.has(gLite.RenderReason.CAMERA_CHANGED)) {\n                _this.applyTransform(_this.$camera, _this.context.camera.getOrthoMatrix());\n            }\n            _this.renderQueue.forEach(function (object) {\n                var _a, _b;\n                var $el = (_a = object.elementSVG) === null || _a === void 0 ? void 0 : _a.$el;\n                var $groupEl = (_b = object.elementSVG) === null || _b === void 0 ? void 0 : _b.$groupEl;\n                if ($el && $groupEl) {\n                    // apply local RTS transformation to <group> wrapper\n                    // account for anchor\n                    var localTransform = object.getLocalTransform();\n                    _this.applyTransform($groupEl, localTransform);\n                    // clipped shapes should also be informed\n                    var $useRefs = _this.clipPathUseMap.get(object);\n                    if ($useRefs && $useRefs.length) {\n                        $useRefs.forEach(function ($use) {\n                            // <clipPath transform=\"matrix()\"><circle /></clipPath>\n                            _this.applyTransform($use, object.getWorldTransform());\n                            // const parentInvert = mat4.invert(\n                            //   mat4.create(),\n                            //   (object as DisplayObject).getWorldTransform(),\n                            // );\n                            // this.applyTransform($clipPath, parentInvert);\n                        });\n                    }\n                    // finish rendering, clear dirty flag\n                    object.renderable.dirty = false;\n                }\n                // update dirty attributes\n                var attributes = _this.dirtyAttributes.get(object);\n                if (attributes) {\n                    attributes.forEach(function (attrName) {\n                        if (attrName === 'zIndex') {\n                            reorderChildren(object);\n                        }\n                        else if (attrName === 'increasedLineWidthForHitTesting') {\n                            _this.createOrUpdateHitArea(object, $el, $groupEl);\n                        }\n                        _this.updateAttribute(object, [attrName]);\n                    });\n                    _this.dirtyAttributes.delete(object);\n                }\n            });\n            _this.renderQueue = [];\n        });\n    };\n    SVGRendererPlugin.prototype.getId = function (object) {\n        return object.id || \"\".concat(G_SVG_PREFIX, \"-\").concat(object.entity);\n    };\n    SVGRendererPlugin.prototype.reorderChildren = function (doc, $groupEl, children) {\n        // need to reorder parent's children\n        children.sort(function (a, b) { return a.sortable.renderOrder - b.sortable.renderOrder; });\n        if (children.length) {\n            // create empty fragment\n            var fragment_1 = (doc || document).createDocumentFragment();\n            children.forEach(function (child) {\n                if (child.isConnected) {\n                    var $el = child.elementSVG.$groupEl;\n                    if ($el) {\n                        fragment_1.appendChild($el);\n                    }\n                }\n            });\n            $groupEl.appendChild(fragment_1);\n        }\n    };\n    SVGRendererPlugin.prototype.applyTransform = function ($el, rts) {\n        // use proper precision avoiding too long string in `transform`\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations\n        $el.setAttribute('transform', \"matrix(\".concat(numberToLongString(rts[0]), \",\").concat(numberToLongString(rts[1]), \",\").concat(numberToLongString(rts[4]), \",\").concat(numberToLongString(rts[5]), \",\").concat(numberToLongString(rts[12]), \",\").concat(numberToLongString(rts[13]), \")\"));\n    };\n    SVGRendererPlugin.prototype.applyAttributes = function (object) {\n        var elementSVG = object.elementSVG;\n        var $el = elementSVG === null || elementSVG === void 0 ? void 0 : elementSVG.$el;\n        var $groupEl = elementSVG === null || elementSVG === void 0 ? void 0 : elementSVG.$groupEl;\n        if ($el && $groupEl) {\n            var nodeName = object.nodeName, attributes = object.attributes;\n            if (nodeName !== gLite.Shape.HTML) {\n                $el.setAttribute('fill', 'none');\n            }\n            if (nodeName === gLite.Shape.IMAGE) {\n                $el.setAttribute('preserveAspectRatio', 'none');\n            }\n            // apply attributes\n            this.updateAttribute(object, Object.keys(attributes));\n        }\n    };\n    SVGRendererPlugin.prototype.updateAttribute = function (object, attributes) {\n        var _this = this;\n        var enableCSSParsing = this.context.enableCSSParsing;\n        var document = this.context.config.document;\n        var _a = object\n            .elementSVG, $el = _a.$el, $groupEl = _a.$groupEl, $hitTestingEl = _a.$hitTestingEl;\n        var parsedStyle = object.parsedStyle, computedStyle = object.computedStyle, nodeName = object.nodeName;\n        var shouldUpdateElementAttribute = attributes.some(function (name) {\n            // @ts-ignore\n            return _this.context.SVGElementLifeCycleContribution.shouldUpdateElementAttribute(object, name);\n        });\n        // need re-generate path\n        if (shouldUpdateElementAttribute && $el) {\n            [$el, $hitTestingEl].forEach(function ($el) {\n                if ($el) {\n                    // @ts-ignore\n                    _this.context.SVGElementLifeCycleContribution.updateElementAttribute(object, $el, _this.svgElementMap);\n                    if (object.nodeName !== gLite.Shape.TEXT) {\n                        _this.updateAnchorWithTransform(object);\n                    }\n                }\n            });\n        }\n        // update common attributes\n        attributes.forEach(function (name) {\n            var _a, _b;\n            var usedName = SVG_ATTR_MAP[name];\n            var computedValue = enableCSSParsing\n                ? computedStyle[name]\n                : parsedStyle[name];\n            var computedValueStr = !util.isNil(computedValue) && computedValue.toString();\n            var formattedValueStr = ((_a = FORMAT_VALUE_MAP[name]) === null || _a === void 0 ? void 0 : _a[computedValueStr]) || computedValueStr;\n            var usedValue = parsedStyle[name];\n            var inherited = usedName && !!((_b = gLite.propertyMetadataCache[name]) === null || _b === void 0 ? void 0 : _b.inh);\n            // <foreignObject>\n            if (nodeName === gLite.Shape.HTML) {\n                if (name === 'fill') {\n                    $el.style.background = usedValue.toString();\n                }\n                else if (name === 'stroke') {\n                    $el.style['border-color'] = usedValue.toString();\n                    $el.style['border-style'] = 'solid';\n                }\n                else if (name === 'lineWidth') {\n                    $el.style['border-width'] = \"\".concat(usedValue || 0, \"px\");\n                }\n                else if (name === 'lineDash') {\n                    $el.style['border-style'] = 'dashed';\n                }\n                else if (name === 'innerHTML') {\n                    _this.createOrUpdateInnerHTML(document, $el, usedValue);\n                }\n                else if (name === 'width' || name === 'height' || name === 'class') {\n                    // width & height are both required for <foreignObject> and cannot be used as style.\n                    $el.setAttribute(name, usedValue.toString());\n                }\n                else if (name !== 'x' &&\n                    name !== 'y' &&\n                    !util.isNil(object.style[name]) &&\n                    object.style[name] !== '') {\n                    $el.style[name] = object.style[name];\n                }\n            }\n            else {\n                if (!usedName ||\n                    ((nodeName === gLite.Shape.GROUP || object.isCustomElement) &&\n                        !enableCSSParsing &&\n                        (inherited || usedName === 'fill' || usedName === 'stroke'))) {\n                    return;\n                }\n                if (name === 'fill') {\n                    _this.defElementManager.createOrUpdateGradientAndPattern(object, $el, usedValue, usedName, _this);\n                }\n                else if (name === 'stroke') {\n                    _this.defElementManager.createOrUpdateGradientAndPattern(object, $el, usedValue, usedName, _this);\n                }\n                else if (enableCSSParsing && inherited) {\n                    // use computed value\n                    // update `visibility` on <group>\n                    if (computedValueStr !== 'unset' &&\n                        computedValueStr !== DEFAULT_VALUE_MAP[name]) {\n                        $groupEl === null || $groupEl === void 0 ? void 0 : $groupEl.setAttribute(usedName, formattedValueStr);\n                    }\n                    else {\n                        $groupEl === null || $groupEl === void 0 ? void 0 : $groupEl.removeAttribute(usedName);\n                    }\n                }\n                else if (name === 'clipPath') {\n                    _this.createOrUpdateClipOrTextPath(document, usedValue, object);\n                }\n                else if (name === 'textPath') {\n                    _this.createOrUpdateClipOrTextPath(document, usedValue, object, true);\n                }\n                else if (name === 'shadowType' ||\n                    name === 'shadowColor' ||\n                    name === 'shadowBlur' ||\n                    name === 'shadowOffsetX' ||\n                    name === 'shadowOffsetY') {\n                    _this.defElementManager.createOrUpdateShadow(object, $el, name);\n                }\n                else if (name === 'filter') {\n                    _this.defElementManager.createOrUpdateFilter(object, $el, usedValue);\n                }\n                else if (name === 'anchor') {\n                    // text' anchor is controlled by `textAnchor` property\n                    if (nodeName !== gLite.Shape.TEXT) {\n                        _this.updateAnchorWithTransform(object);\n                    }\n                }\n                else {\n                    if (!util.isNil(computedValue)) {\n                        // use computed value so that we can use cascaded effect in SVG\n                        // ignore 'unset' and default value\n                        [$el, $hitTestingEl].forEach(function ($el) {\n                            if ($el && usedName) {\n                                if (computedValueStr !== 'unset' &&\n                                    computedValueStr !== DEFAULT_VALUE_MAP[name]) {\n                                    $el.setAttribute(usedName, formattedValueStr);\n                                }\n                                else {\n                                    $el.removeAttribute(usedName);\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        });\n    };\n    SVGRendererPlugin.prototype.createSVGDom = function (document, object, root, noWrapWithGroup) {\n        var _a;\n        if (noWrapWithGroup === void 0) { noWrapWithGroup = false; }\n        // create svg element\n        // @ts-ignore\n        object.elementSVG = new ElementSVG();\n        // @ts-ignore\n        var svgElement = object.elementSVG;\n        // use <group> as default, eg. CustomElement\n        var $el = \n        // @ts-ignore\n        this.context.SVGElementLifeCycleContribution.createElement(object, this.svgElementMap);\n        if ($el) {\n            var $groupEl = void 0;\n            // save $el on parsedStyle, which will be returned in getDomElement()\n            if (object.nodeName === gLite.Shape.HTML) {\n                object.parsedStyle.$el = $el;\n            }\n            if (this.pluginOptions.outputSVGElementId) {\n                // use user-defined id first.\n                $el.id = this.getId(object);\n            }\n            if (this.pluginOptions.outputSVGElementName && object.name) {\n                $el.setAttribute('name', object.name);\n            }\n            if (($el.hasAttribute('data-wrapgroup') || $el.nodeName !== 'g') &&\n                !noWrapWithGroup) {\n                $groupEl = createSVGElement('g', document);\n                // if (this.pluginOptions.outputSVGElementId) {\n                //   $groupEl.id = $el.id + '-g';\n                // }\n                $groupEl.appendChild($el);\n            }\n            else {\n                $groupEl = $el;\n            }\n            svgElement.$el = $el;\n            svgElement.$groupEl = $groupEl;\n            // apply attributes at first time\n            this.applyAttributes(object);\n            // create hitArea if necessary\n            this.createOrUpdateHitArea(object, $el, $groupEl);\n            var $parentGroupEl = root ||\n                // @ts-ignore\n                (object.parentNode && ((_a = object.parentNode.elementSVG) === null || _a === void 0 ? void 0 : _a.$groupEl));\n            if ($parentGroupEl) {\n                $parentGroupEl.appendChild($groupEl);\n                // need reorder children later\n                this.pendingReorderQueue.add(object.parentNode);\n            }\n        }\n    };\n    SVGRendererPlugin.prototype.removeSVGDom = function (object) {\n        var _a;\n        // @ts-ignore\n        var $groupEl = (_a = object.elementSVG) === null || _a === void 0 ? void 0 : _a.$groupEl;\n        if ($groupEl && $groupEl.parentNode) {\n            $groupEl.parentNode.removeChild($groupEl);\n            // @ts-ignore\n            this.context.SVGElementLifeCycleContribution.destroyElement(object, $groupEl);\n            // object.entity.removeComponent(ElementSVG, true);\n        }\n    };\n    SVGRendererPlugin.prototype.createOrUpdateHitArea = function (object, $el, $groupEl) {\n        var svgElement = object.elementSVG;\n        var $hitTestingEl = svgElement.$hitTestingEl;\n        var increasedLineWidthForHitTesting = Number(object.parsedStyle.increasedLineWidthForHitTesting);\n        // account for hitArea\n        if (increasedLineWidthForHitTesting) {\n            if (!$hitTestingEl) {\n                $hitTestingEl = $el.cloneNode();\n                // clear attributes like `filter` `font-size`\n                ['filter'].forEach(function (attribute) {\n                    $hitTestingEl.removeAttribute(attribute);\n                });\n                // hitArea should be 'transparent' but not 'none'\n                var hasFill = $el.getAttribute('fill') !== 'none';\n                $hitTestingEl.setAttribute('fill', hasFill ? 'transparent' : 'none');\n                $hitTestingEl.setAttribute('stroke', 'transparent');\n                $groupEl.appendChild($hitTestingEl);\n                svgElement.$hitTestingEl = $hitTestingEl;\n                // g-plugin-svg-picker will use this map to find target object\n                this.svgElementMap.set($hitTestingEl, object);\n            }\n            // increase interactive line width\n            $hitTestingEl.setAttribute('stroke-width', \"\".concat(increasedLineWidthForHitTesting + object.parsedStyle.lineWidth));\n        }\n        else {\n            if ($hitTestingEl) {\n                $groupEl.removeChild($hitTestingEl);\n                svgElement.$hitTestingEl = null;\n            }\n        }\n    };\n    SVGRendererPlugin.prototype.createOrUpdateInnerHTML = function (doc, $el, usedValue) {\n        var $div = (doc || document).createElement('div');\n        if (typeof usedValue === 'string') {\n            $div.innerHTML = usedValue;\n        }\n        else {\n            $div.appendChild(usedValue);\n        }\n        $el.innerHTML = '';\n        $el.appendChild($div);\n    };\n    SVGRendererPlugin.prototype.createOrUpdateClipOrTextPath = function (document, clipPath, object, isTextPath) {\n        if (isTextPath === void 0) { isTextPath = false; }\n        var $groupEl = object.elementSVG.$groupEl;\n        var PREFIX = isTextPath ? TEXT_PATH_PREFIX : CLIP_PATH_PREFIX;\n        var attributeNameCamel = isTextPath ? 'g' : 'clipPath';\n        var attributeNameHyphen = isTextPath ? 'text-path' : 'clip-path';\n        if (clipPath) {\n            var clipPathId = PREFIX + clipPath.entity + '-' + object.entity;\n            var $def = this.defElementManager.getDefElement();\n            var existed = $def.querySelector(\"#\".concat(clipPathId));\n            if (!existed) {\n                var $clipPath = void 0;\n                if (isTextPath) {\n                    // use <path> directly instead of wrapping with <g>\n                    this.createSVGDom(document, clipPath, null, true);\n                    // @ts-ignore\n                    $clipPath = clipPath.elementSVG.$el;\n                }\n                else {\n                    // the clipPath is allowed to be detached from canvas\n                    if (!clipPath.isConnected) {\n                        var $existedClipPath = $def.querySelector(\"#\".concat(this.getId(clipPath)));\n                        if (!$existedClipPath) {\n                            this.createSVGDom(document, clipPath, $def, true);\n                        }\n                    }\n                    // create <clipPath> dom node\n                    $clipPath = createSVGElement(attributeNameCamel, document);\n                    var $use = createSVGElement('use', document);\n                    // @ts-ignore\n                    $use.setAttribute('href', \"#\".concat(clipPath.elementSVG.$el.id));\n                    $clipPath.appendChild($use);\n                    var $useRefs = this.clipPathUseMap.get(clipPath);\n                    if (!$useRefs) {\n                        this.clipPathUseMap.set(clipPath, []);\n                        $useRefs = this.clipPathUseMap.get(clipPath);\n                    }\n                    $useRefs.push($use);\n                    // <clipPath transform=\"matrix()\"><circle /></clipPath>\n                    this.applyTransform($use, clipPath.getWorldTransform());\n                    var parentInvert = glMatrix.mat4.invert(glMatrix.mat4.create(), object.getWorldTransform());\n                    this.applyTransform($clipPath, parentInvert);\n                }\n                if (this.pluginOptions.outputSVGElementId) {\n                    $clipPath.id = clipPathId;\n                }\n                // append it to <defs>\n                $def.appendChild($clipPath);\n            }\n            // apply attributes\n            this.applyAttributes(clipPath);\n            if (!isTextPath) {\n                // apply clipPath to $group\n                // @see https://github.com/antvis/g/issues/961\n                $groupEl.setAttribute(attributeNameHyphen, \"url(#\".concat(clipPathId, \")\"));\n            }\n        }\n        else {\n            if (!isTextPath) {\n                // remove clip path\n                $groupEl.removeAttribute(attributeNameHyphen);\n            }\n        }\n    };\n    /**\n     * the origin is bounding box's top left corner\n     */\n    SVGRendererPlugin.prototype.updateAnchorWithTransform = function (object) {\n        var _a, _b;\n        var bounds = object.getGeometryBounds();\n        var width = (bounds && bounds.halfExtents[0] * 2) || 0;\n        var height = (bounds && bounds.halfExtents[1] * 2) || 0;\n        var anchor = (object.parsedStyle || {}).anchor;\n        [\n            (_a = object.elementSVG) === null || _a === void 0 ? void 0 : _a.$el,\n            (_b = object.elementSVG) === null || _b === void 0 ? void 0 : _b.$hitTestingEl,\n        ].forEach(function ($el) {\n            if ($el) {\n                var tx = -(anchor[0] * width);\n                var ty = -(anchor[1] * height);\n                if (tx !== 0 || ty !== 0) {\n                    // apply anchor to element's `transform` property\n                    $el.setAttribute('transform', \n                    // can't use percent unit like translate(-50%, -50%)\n                    // @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/transform#translate\n                    \"translate(\".concat(tx, \",\").concat(ty, \")\"));\n                }\n                if (object.nodeName === gLite.Shape.CIRCLE ||\n                    object.nodeName === gLite.Shape.ELLIPSE) {\n                    $el.setAttribute('cx', \"\".concat(width / 2));\n                    $el.setAttribute('cy', \"\".concat(height / 2));\n                }\n            }\n        });\n    };\n    SVGRendererPlugin.tag = 'SVGRenderer';\n    return SVGRendererPlugin;\n}());\n\n// @see https://github.com/plouc/nivo/issues/164\nvar BASELINE_MAP = {\n    top: 'hanging', // Use hanging here.\n    middle: 'central',\n    bottom: 'text-after-edge', // FIXME: It is not a standard property.\n    alphabetic: 'alphabetic',\n    ideographic: 'ideographic',\n    hanging: 'hanging',\n};\nfunction updateTextElementAttribute($el, parsedStyle, text, runtime) {\n    var lineWidth = parsedStyle.lineWidth, dx = parsedStyle.dx, dy = parsedStyle.dy, textPath = parsedStyle.textPath, _a = parsedStyle.textPathSide, textPathSide = _a === void 0 ? 'left' : _a, _b = parsedStyle.textPathStartOffset, textPathStartOffset = _b === void 0 ? 0 : _b, _c = parsedStyle.textDecorationLine, textDecorationLine = _c === void 0 ? '' : _c, _d = parsedStyle.textDecorationColor, textDecorationColor = _d === void 0 ? '' : _d, _e = parsedStyle.textDecorationStyle, textDecorationStyle = _e === void 0 ? '' : _e, metrics = parsedStyle.metrics;\n    var textBaseline = parsedStyle.textBaseline;\n    if (!runtime.enableCSSParsing && textBaseline === 'alphabetic') {\n        textBaseline = 'bottom';\n    }\n    $el.setAttribute('dominant-baseline', BASELINE_MAP[textBaseline]);\n    $el.setAttribute('paint-order', 'stroke');\n    var lines = metrics.lines, lineHeight = metrics.lineHeight, height = metrics.height;\n    var lineNum = lines.length;\n    var styleCSSText = '';\n    if (dx !== 0 || dy !== 0) {\n        styleCSSText += \"transform:translate(\".concat(dx, \"px, \").concat(dy, \"px);\");\n    }\n    if (textDecorationLine && textDecorationLine !== 'none') {\n        // use CSS text-decoration since the implementation in SVG is not good enough\n        styleCSSText += \"text-decoration:\".concat(textDecorationLine, \" \").concat(textDecorationStyle, \" \").concat(textDecorationColor, \";\");\n    }\n    if (styleCSSText) {\n        $el.setAttribute('style', styleCSSText);\n    }\n    if (lineNum === 1) {\n        var textContent = convertHTML(lines[0]);\n        $el.setAttribute('dx', \"\".concat(lineWidth / 2));\n        // Since `text-after-edge` is not a standard property value, we use `dy` instead.\n        if (textBaseline === 'bottom' || textBaseline === 'top') {\n            $el.setAttribute('dominant-baseline', BASELINE_MAP['middle']);\n            $el.setAttribute('dy', textBaseline === 'bottom' ? \"-\".concat(height / 2, \"px\") : \"\".concat(height / 2, \"px\"));\n        }\n        // <textPath> only support one line\n        // @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath\n        if (textPath) {\n            // clear existed text content first\n            $el.innerHTML = '';\n            // append <textPath href=\"#MyPath\">text</textPath>\n            var $textPath = createSVGElement('textPath', $el.ownerDocument);\n            $textPath.setAttribute('href', \"#\".concat(TEXT_PATH_PREFIX + textPath.entity));\n            if (textPathSide !== 'left') {\n                $textPath.setAttribute('side', textPathSide);\n            }\n            if (textPathStartOffset !== 0) {\n                $textPath.setAttribute('startOffset', \"\".concat(textPathStartOffset));\n            }\n            $textPath.innerHTML = textContent;\n            $el.appendChild($textPath);\n        }\n        else {\n            $el.innerHTML = textContent;\n        }\n    }\n    else {\n        $el.innerHTML = lines\n            .map(function (line, i) {\n            var dx = lineWidth / 2;\n            var dy = 0;\n            if (i === 0) {\n                // TODO: handle other textBaseline values\n                if (textBaseline === 'middle') {\n                    dy = lineHeight / 2 - height / 2;\n                }\n                else if (textBaseline === 'top' || textBaseline === 'hanging') {\n                    dy = 0;\n                }\n                else if (textBaseline === 'bottom' ||\n                    textBaseline === 'alphabetic' ||\n                    textBaseline === 'ideographic') {\n                    dy = -lineHeight * (lineNum - 1);\n                }\n            }\n            else {\n                dy = lineHeight;\n            }\n            return \"<tspan x=\\\"0\\\" dx=\\\"\".concat(dx, \"\\\" dy=\\\"\").concat(dy, \"\\\">\").concat(convertHTML(line), \"</tspan>\");\n        })\n            .join('');\n    }\n}\n\nvar _a, _b;\nvar SHAPE2TAGS = (_a = {},\n    _a[gLite.Shape.RECT] = 'path',\n    _a[gLite.Shape.CIRCLE] = 'circle',\n    _a[gLite.Shape.ELLIPSE] = 'ellipse',\n    _a[gLite.Shape.IMAGE] = 'image',\n    _a[gLite.Shape.GROUP] = 'g',\n    _a[gLite.Shape.LINE] = 'line',\n    _a[gLite.Shape.POLYLINE] = 'polyline',\n    _a[gLite.Shape.POLYGON] = 'polygon',\n    _a[gLite.Shape.TEXT] = 'text',\n    _a[gLite.Shape.PATH] = 'path',\n    _a[gLite.Shape.HTML] = 'foreignObject',\n    _a);\nvar SHAPE_UPDATE_DEPS = (_b = {},\n    _b[gLite.Shape.CIRCLE] = ['r'],\n    _b[gLite.Shape.ELLIPSE] = ['rx', 'ry'],\n    _b[gLite.Shape.RECT] = ['width', 'height', 'radius'],\n    _b[gLite.Shape.IMAGE] = ['img', 'width', 'height'],\n    _b[gLite.Shape.LINE] = [\n        'x1',\n        'y1',\n        'x2',\n        'y2',\n        'markerStart',\n        'markerEnd',\n        'markerStartOffset',\n        'markerEndOffset',\n    ],\n    _b[gLite.Shape.POLYLINE] = [\n        'points',\n        'markerStart',\n        'markerEnd',\n        'markerMid',\n        'markerStartOffset',\n        'markerEndOffset',\n    ],\n    _b[gLite.Shape.POLYGON] = [\n        'points',\n        'markerStart',\n        'markerEnd',\n        'markerMid',\n        'markerStartOffset',\n        'markerEndOffset',\n    ],\n    _b[gLite.Shape.PATH] = [\n        'path',\n        'markerStart',\n        'markerEnd',\n        'markerMid',\n        'markerStartOffset',\n        'markerEndOffset',\n    ],\n    _b[gLite.Shape.TEXT] = [\n        'text',\n        'font',\n        'fontSize',\n        'fontFamily',\n        'fontStyle',\n        'fontWeight',\n        'fontVariant',\n        'lineHeight',\n        'letterSpacing',\n        'wordWrap',\n        'wordWrapWidth',\n        'maxLines',\n        'leading',\n        'textBaseline',\n        'textAlign',\n        'textTransform',\n        'textOverflow',\n        'textPath',\n        'textPathSide',\n        'textPathStartOffset',\n        'textDecorationLine',\n        'textDecorationColor',\n        'textDecorationStyle',\n        // 'whiteSpace',\n        'dx',\n        'dy',\n    ],\n    _b);\nvar DefaultElementLifeCycleContribution = /** @class */ (function () {\n    function DefaultElementLifeCycleContribution(context, runtime) {\n        this.context = context;\n        this.runtime = runtime;\n    }\n    DefaultElementLifeCycleContribution.prototype.createElement = function (object, svgElementMap) {\n        var doc = this.context.config.document;\n        var type = SHAPE2TAGS[object.nodeName] || 'g';\n        var $el = createSVGElement(type, doc || document);\n        svgElementMap.set($el, object);\n        return $el;\n    };\n    DefaultElementLifeCycleContribution.prototype.destroyElement = function (object, $el) { };\n    DefaultElementLifeCycleContribution.prototype.shouldUpdateElementAttribute = function (object, attributeName) {\n        var nodeName = object.nodeName;\n        return (SHAPE_UPDATE_DEPS[nodeName] || []).indexOf(attributeName) > -1;\n    };\n    DefaultElementLifeCycleContribution.prototype.updateElementAttribute = function (object) {\n        // @ts-ignore\n        var $el = object.elementSVG.$el;\n        var nodeName = object.nodeName, parsedStyle = object.parsedStyle;\n        switch (nodeName) {\n            case gLite.Shape.IMAGE: {\n                updateImageElementAttribute($el, parsedStyle);\n                break;\n            }\n            case gLite.Shape.RECT: {\n                updateRectElementAttribute($el, parsedStyle);\n                break;\n            }\n            case gLite.Shape.LINE: {\n                updateLineElementAttribute($el, parsedStyle);\n                break;\n            }\n            case gLite.Shape.POLYGON:\n            case gLite.Shape.POLYLINE: {\n                updatePolylineElementAttribute($el, parsedStyle);\n                break;\n            }\n            case gLite.Shape.PATH: {\n                updatePathElementAttribute($el, parsedStyle);\n                break;\n            }\n            case gLite.Shape.TEXT: {\n                updateTextElementAttribute($el, parsedStyle, object, this.runtime);\n                break;\n            }\n        }\n    };\n    return DefaultElementLifeCycleContribution;\n}());\n\nvar Plugin = /** @class */ (function (_super) {\n    tslib.__extends(Plugin, _super);\n    function Plugin(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.options = options;\n        _this.name = 'svg-renderer';\n        return _this;\n    }\n    Plugin.prototype.init = function (runtime) {\n        var _a = this.options, outputSVGElementId = _a.outputSVGElementId, outputSVGElementName = _a.outputSVGElementName;\n        var defElementManager = new DefElementManager(this.context);\n        // default implementation\n        var defaultElementLifeCycleContribution = new DefaultElementLifeCycleContribution(this.context, runtime);\n        // @ts-ignore\n        this.context.defaultElementLifeCycleContribution =\n            defaultElementLifeCycleContribution;\n        // @ts-ignore\n        this.context.SVGElementLifeCycleContribution =\n            defaultElementLifeCycleContribution;\n        var SVGRendererPluginOptions = {\n            outputSVGElementId: !util.isNil(outputSVGElementId)\n                ? !!outputSVGElementId\n                : true,\n            outputSVGElementName: !util.isNil(outputSVGElementName)\n                ? !!outputSVGElementName\n                : true,\n        };\n        this.addRenderingPlugin(\n        // @ts-ignore\n        new SVGRendererPlugin(SVGRendererPluginOptions, defElementManager, this.context));\n    };\n    Plugin.prototype.destroy = function () {\n        this.removeAllRenderingPlugins();\n        // @ts-ignore\n        delete this.context.defaultElementLifeCycleContribution;\n        // @ts-ignore\n        delete this.context.SVGElementLifeCycleContribution;\n    };\n    return Plugin;\n}(gLite.AbstractRendererPlugin));\n\nexports.CLIP_PATH_PREFIX = CLIP_PATH_PREFIX;\nexports.DEFAULT_VALUE_MAP = DEFAULT_VALUE_MAP;\nexports.DefaultElementLifeCycleContribution = DefaultElementLifeCycleContribution;\nexports.ElementSVG = ElementSVG;\nexports.G_SVG_PREFIX = G_SVG_PREFIX;\nexports.Plugin = Plugin;\nexports.SHAPE2TAGS = SHAPE2TAGS;\nexports.SHAPE_UPDATE_DEPS = SHAPE_UPDATE_DEPS;\nexports.SVGRendererPlugin = SVGRendererPlugin;\nexports.SVG_ATTR_MAP = SVG_ATTR_MAP;\nexports.TEXT_PATH_PREFIX = TEXT_PATH_PREFIX;\nexports.createSVGElement = createSVGElement;\nexports.updateImageElementAttribute = updateImageElementAttribute;\nexports.updateLineElementAttribute = updateLineElementAttribute;\nexports.updatePathElementAttribute = updatePathElementAttribute;\nexports.updatePolylineElementAttribute = updatePolylineElementAttribute;\nexports.updateRectElementAttribute = updateRectElementAttribute;\nexports.updateTextElementAttribute = updateTextElementAttribute;\n//# sourceMappingURL=index.js.map\n"]}