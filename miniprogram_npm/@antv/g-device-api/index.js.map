{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar util = require('@antv/util');\nvar tslib = require('tslib');\nvar EventEmitter = require('eventemitter3');\n\n/**\n * ported from @luma.gl/constants\n *\n * Standard WebGL and WebGL2 constants\n * These constants are also defined on the WebGLRenderingContext interface.\n */\nexports.GL = void 0;\n(function (GL) {\n    // Clearing buffers\n    // Constants passed to clear() to clear buffer masks.\n    GL[GL[\"DEPTH_BUFFER_BIT\"] = 256] = \"DEPTH_BUFFER_BIT\";\n    GL[GL[\"STENCIL_BUFFER_BIT\"] = 1024] = \"STENCIL_BUFFER_BIT\";\n    GL[GL[\"COLOR_BUFFER_BIT\"] = 16384] = \"COLOR_BUFFER_BIT\";\n    // Rendering primitives\n    // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.\n    GL[GL[\"POINTS\"] = 0] = \"POINTS\";\n    GL[GL[\"LINES\"] = 1] = \"LINES\";\n    GL[GL[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n    GL[GL[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n    GL[GL[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n    GL[GL[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n    GL[GL[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n    // Blending modes\n    // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).\n    GL[GL[\"ZERO\"] = 0] = \"ZERO\";\n    GL[GL[\"ONE\"] = 1] = \"ONE\";\n    GL[GL[\"SRC_COLOR\"] = 768] = \"SRC_COLOR\";\n    GL[GL[\"ONE_MINUS_SRC_COLOR\"] = 769] = \"ONE_MINUS_SRC_COLOR\";\n    GL[GL[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n    GL[GL[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n    GL[GL[\"DST_ALPHA\"] = 772] = \"DST_ALPHA\";\n    GL[GL[\"ONE_MINUS_DST_ALPHA\"] = 773] = \"ONE_MINUS_DST_ALPHA\";\n    GL[GL[\"DST_COLOR\"] = 774] = \"DST_COLOR\";\n    GL[GL[\"ONE_MINUS_DST_COLOR\"] = 775] = \"ONE_MINUS_DST_COLOR\";\n    GL[GL[\"SRC_ALPHA_SATURATE\"] = 776] = \"SRC_ALPHA_SATURATE\";\n    GL[GL[\"CONSTANT_COLOR\"] = 32769] = \"CONSTANT_COLOR\";\n    GL[GL[\"ONE_MINUS_CONSTANT_COLOR\"] = 32770] = \"ONE_MINUS_CONSTANT_COLOR\";\n    GL[GL[\"CONSTANT_ALPHA\"] = 32771] = \"CONSTANT_ALPHA\";\n    GL[GL[\"ONE_MINUS_CONSTANT_ALPHA\"] = 32772] = \"ONE_MINUS_CONSTANT_ALPHA\";\n    // Blending equations\n    // Constants passed to blendEquation() or blendEquationSeparate() to control\n    // how the blending is calculated (for both, RBG and alpha, or separately).\n    GL[GL[\"FUNC_ADD\"] = 32774] = \"FUNC_ADD\";\n    GL[GL[\"FUNC_SUBTRACT\"] = 32778] = \"FUNC_SUBTRACT\";\n    GL[GL[\"FUNC_REVERSE_SUBTRACT\"] = 32779] = \"FUNC_REVERSE_SUBTRACT\";\n    // Getting GL parameter information\n    // Constants passed to getParameter() to specify what information to return.\n    GL[GL[\"BLEND_EQUATION\"] = 32777] = \"BLEND_EQUATION\";\n    GL[GL[\"BLEND_EQUATION_RGB\"] = 32777] = \"BLEND_EQUATION_RGB\";\n    GL[GL[\"BLEND_EQUATION_ALPHA\"] = 34877] = \"BLEND_EQUATION_ALPHA\";\n    GL[GL[\"BLEND_DST_RGB\"] = 32968] = \"BLEND_DST_RGB\";\n    GL[GL[\"BLEND_SRC_RGB\"] = 32969] = \"BLEND_SRC_RGB\";\n    GL[GL[\"BLEND_DST_ALPHA\"] = 32970] = \"BLEND_DST_ALPHA\";\n    GL[GL[\"BLEND_SRC_ALPHA\"] = 32971] = \"BLEND_SRC_ALPHA\";\n    GL[GL[\"BLEND_COLOR\"] = 32773] = \"BLEND_COLOR\";\n    GL[GL[\"ARRAY_BUFFER_BINDING\"] = 34964] = \"ARRAY_BUFFER_BINDING\";\n    GL[GL[\"ELEMENT_ARRAY_BUFFER_BINDING\"] = 34965] = \"ELEMENT_ARRAY_BUFFER_BINDING\";\n    GL[GL[\"LINE_WIDTH\"] = 2849] = \"LINE_WIDTH\";\n    GL[GL[\"ALIASED_POINT_SIZE_RANGE\"] = 33901] = \"ALIASED_POINT_SIZE_RANGE\";\n    GL[GL[\"ALIASED_LINE_WIDTH_RANGE\"] = 33902] = \"ALIASED_LINE_WIDTH_RANGE\";\n    GL[GL[\"CULL_FACE_MODE\"] = 2885] = \"CULL_FACE_MODE\";\n    GL[GL[\"FRONT_FACE\"] = 2886] = \"FRONT_FACE\";\n    GL[GL[\"DEPTH_RANGE\"] = 2928] = \"DEPTH_RANGE\";\n    GL[GL[\"DEPTH_WRITEMASK\"] = 2930] = \"DEPTH_WRITEMASK\";\n    GL[GL[\"DEPTH_CLEAR_VALUE\"] = 2931] = \"DEPTH_CLEAR_VALUE\";\n    GL[GL[\"DEPTH_FUNC\"] = 2932] = \"DEPTH_FUNC\";\n    GL[GL[\"STENCIL_CLEAR_VALUE\"] = 2961] = \"STENCIL_CLEAR_VALUE\";\n    GL[GL[\"STENCIL_FUNC\"] = 2962] = \"STENCIL_FUNC\";\n    GL[GL[\"STENCIL_FAIL\"] = 2964] = \"STENCIL_FAIL\";\n    GL[GL[\"STENCIL_PASS_DEPTH_FAIL\"] = 2965] = \"STENCIL_PASS_DEPTH_FAIL\";\n    GL[GL[\"STENCIL_PASS_DEPTH_PASS\"] = 2966] = \"STENCIL_PASS_DEPTH_PASS\";\n    GL[GL[\"STENCIL_REF\"] = 2967] = \"STENCIL_REF\";\n    GL[GL[\"STENCIL_VALUE_MASK\"] = 2963] = \"STENCIL_VALUE_MASK\";\n    GL[GL[\"STENCIL_WRITEMASK\"] = 2968] = \"STENCIL_WRITEMASK\";\n    GL[GL[\"STENCIL_BACK_FUNC\"] = 34816] = \"STENCIL_BACK_FUNC\";\n    GL[GL[\"STENCIL_BACK_FAIL\"] = 34817] = \"STENCIL_BACK_FAIL\";\n    GL[GL[\"STENCIL_BACK_PASS_DEPTH_FAIL\"] = 34818] = \"STENCIL_BACK_PASS_DEPTH_FAIL\";\n    GL[GL[\"STENCIL_BACK_PASS_DEPTH_PASS\"] = 34819] = \"STENCIL_BACK_PASS_DEPTH_PASS\";\n    GL[GL[\"STENCIL_BACK_REF\"] = 36003] = \"STENCIL_BACK_REF\";\n    GL[GL[\"STENCIL_BACK_VALUE_MASK\"] = 36004] = \"STENCIL_BACK_VALUE_MASK\";\n    GL[GL[\"STENCIL_BACK_WRITEMASK\"] = 36005] = \"STENCIL_BACK_WRITEMASK\";\n    GL[GL[\"VIEWPORT\"] = 2978] = \"VIEWPORT\";\n    GL[GL[\"SCISSOR_BOX\"] = 3088] = \"SCISSOR_BOX\";\n    GL[GL[\"COLOR_CLEAR_VALUE\"] = 3106] = \"COLOR_CLEAR_VALUE\";\n    GL[GL[\"COLOR_WRITEMASK\"] = 3107] = \"COLOR_WRITEMASK\";\n    GL[GL[\"UNPACK_ALIGNMENT\"] = 3317] = \"UNPACK_ALIGNMENT\";\n    GL[GL[\"PACK_ALIGNMENT\"] = 3333] = \"PACK_ALIGNMENT\";\n    GL[GL[\"MAX_TEXTURE_SIZE\"] = 3379] = \"MAX_TEXTURE_SIZE\";\n    GL[GL[\"MAX_VIEWPORT_DIMS\"] = 3386] = \"MAX_VIEWPORT_DIMS\";\n    GL[GL[\"SUBPIXEL_BITS\"] = 3408] = \"SUBPIXEL_BITS\";\n    GL[GL[\"RED_BITS\"] = 3410] = \"RED_BITS\";\n    GL[GL[\"GREEN_BITS\"] = 3411] = \"GREEN_BITS\";\n    GL[GL[\"BLUE_BITS\"] = 3412] = \"BLUE_BITS\";\n    GL[GL[\"ALPHA_BITS\"] = 3413] = \"ALPHA_BITS\";\n    GL[GL[\"DEPTH_BITS\"] = 3414] = \"DEPTH_BITS\";\n    GL[GL[\"STENCIL_BITS\"] = 3415] = \"STENCIL_BITS\";\n    GL[GL[\"POLYGON_OFFSET_UNITS\"] = 10752] = \"POLYGON_OFFSET_UNITS\";\n    GL[GL[\"POLYGON_OFFSET_FACTOR\"] = 32824] = \"POLYGON_OFFSET_FACTOR\";\n    GL[GL[\"TEXTURE_BINDING_2D\"] = 32873] = \"TEXTURE_BINDING_2D\";\n    GL[GL[\"SAMPLE_BUFFERS\"] = 32936] = \"SAMPLE_BUFFERS\";\n    GL[GL[\"SAMPLES\"] = 32937] = \"SAMPLES\";\n    GL[GL[\"SAMPLE_COVERAGE_VALUE\"] = 32938] = \"SAMPLE_COVERAGE_VALUE\";\n    GL[GL[\"SAMPLE_COVERAGE_INVERT\"] = 32939] = \"SAMPLE_COVERAGE_INVERT\";\n    GL[GL[\"COMPRESSED_TEXTURE_FORMATS\"] = 34467] = \"COMPRESSED_TEXTURE_FORMATS\";\n    GL[GL[\"VENDOR\"] = 7936] = \"VENDOR\";\n    GL[GL[\"RENDERER\"] = 7937] = \"RENDERER\";\n    GL[GL[\"VERSION\"] = 7938] = \"VERSION\";\n    GL[GL[\"IMPLEMENTATION_COLOR_READ_TYPE\"] = 35738] = \"IMPLEMENTATION_COLOR_READ_TYPE\";\n    GL[GL[\"IMPLEMENTATION_COLOR_READ_FORMAT\"] = 35739] = \"IMPLEMENTATION_COLOR_READ_FORMAT\";\n    GL[GL[\"BROWSER_DEFAULT_WEBGL\"] = 37444] = \"BROWSER_DEFAULT_WEBGL\";\n    // Buffers\n    // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or\n    // getBufferParameter().\n    GL[GL[\"STATIC_DRAW\"] = 35044] = \"STATIC_DRAW\";\n    GL[GL[\"STREAM_DRAW\"] = 35040] = \"STREAM_DRAW\";\n    GL[GL[\"DYNAMIC_DRAW\"] = 35048] = \"DYNAMIC_DRAW\";\n    GL[GL[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n    GL[GL[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n    GL[GL[\"BUFFER_SIZE\"] = 34660] = \"BUFFER_SIZE\";\n    GL[GL[\"BUFFER_USAGE\"] = 34661] = \"BUFFER_USAGE\";\n    // Vertex attributes\n    // Constants passed to getVertexAttrib().\n    GL[GL[\"CURRENT_VERTEX_ATTRIB\"] = 34342] = \"CURRENT_VERTEX_ATTRIB\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_ENABLED\"] = 34338] = \"VERTEX_ATTRIB_ARRAY_ENABLED\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_SIZE\"] = 34339] = \"VERTEX_ATTRIB_ARRAY_SIZE\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_STRIDE\"] = 34340] = \"VERTEX_ATTRIB_ARRAY_STRIDE\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_TYPE\"] = 34341] = \"VERTEX_ATTRIB_ARRAY_TYPE\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_NORMALIZED\"] = 34922] = \"VERTEX_ATTRIB_ARRAY_NORMALIZED\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_POINTER\"] = 34373] = \"VERTEX_ATTRIB_ARRAY_POINTER\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING\"] = 34975] = \"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING\";\n    // Culling\n    // Constants passed to cullFace().\n    GL[GL[\"CULL_FACE\"] = 2884] = \"CULL_FACE\";\n    GL[GL[\"FRONT\"] = 1028] = \"FRONT\";\n    GL[GL[\"BACK\"] = 1029] = \"BACK\";\n    GL[GL[\"FRONT_AND_BACK\"] = 1032] = \"FRONT_AND_BACK\";\n    // Enabling and disabling\n    // Constants passed to enable() or disable().\n    GL[GL[\"BLEND\"] = 3042] = \"BLEND\";\n    GL[GL[\"DEPTH_TEST\"] = 2929] = \"DEPTH_TEST\";\n    GL[GL[\"DITHER\"] = 3024] = \"DITHER\";\n    GL[GL[\"POLYGON_OFFSET_FILL\"] = 32823] = \"POLYGON_OFFSET_FILL\";\n    GL[GL[\"SAMPLE_ALPHA_TO_COVERAGE\"] = 32926] = \"SAMPLE_ALPHA_TO_COVERAGE\";\n    GL[GL[\"SAMPLE_COVERAGE\"] = 32928] = \"SAMPLE_COVERAGE\";\n    GL[GL[\"SCISSOR_TEST\"] = 3089] = \"SCISSOR_TEST\";\n    GL[GL[\"STENCIL_TEST\"] = 2960] = \"STENCIL_TEST\";\n    // Errors\n    // Constants returned from getError().\n    GL[GL[\"NO_ERROR\"] = 0] = \"NO_ERROR\";\n    GL[GL[\"INVALID_ENUM\"] = 1280] = \"INVALID_ENUM\";\n    GL[GL[\"INVALID_VALUE\"] = 1281] = \"INVALID_VALUE\";\n    GL[GL[\"INVALID_OPERATION\"] = 1282] = \"INVALID_OPERATION\";\n    GL[GL[\"OUT_OF_MEMORY\"] = 1285] = \"OUT_OF_MEMORY\";\n    GL[GL[\"CONTEXT_LOST_WEBGL\"] = 37442] = \"CONTEXT_LOST_WEBGL\";\n    // Front face directions\n    // Constants passed to frontFace().\n    GL[GL[\"CW\"] = 2304] = \"CW\";\n    GL[GL[\"CCW\"] = 2305] = \"CCW\";\n    // Hints\n    // Constants passed to hint()\n    GL[GL[\"DONT_CARE\"] = 4352] = \"DONT_CARE\";\n    GL[GL[\"FASTEST\"] = 4353] = \"FASTEST\";\n    GL[GL[\"NICEST\"] = 4354] = \"NICEST\";\n    GL[GL[\"GENERATE_MIPMAP_HINT\"] = 33170] = \"GENERATE_MIPMAP_HINT\";\n    // Data types\n    GL[GL[\"BYTE\"] = 5120] = \"BYTE\";\n    GL[GL[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    GL[GL[\"SHORT\"] = 5122] = \"SHORT\";\n    GL[GL[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    GL[GL[\"INT\"] = 5124] = \"INT\";\n    GL[GL[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    GL[GL[\"FLOAT\"] = 5126] = \"FLOAT\";\n    GL[GL[\"DOUBLE\"] = 5130] = \"DOUBLE\";\n    // Pixel formats\n    GL[GL[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n    GL[GL[\"ALPHA\"] = 6406] = \"ALPHA\";\n    GL[GL[\"RGB\"] = 6407] = \"RGB\";\n    GL[GL[\"RGBA\"] = 6408] = \"RGBA\";\n    GL[GL[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n    GL[GL[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n    // Pixel types\n    // UNSIGNED_BYTE = 0x1401,\n    GL[GL[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n    GL[GL[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n    GL[GL[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n    // Shaders\n    // Constants passed to createShader() or getShaderParameter()\n    GL[GL[\"FRAGMENT_SHADER\"] = 35632] = \"FRAGMENT_SHADER\";\n    GL[GL[\"VERTEX_SHADER\"] = 35633] = \"VERTEX_SHADER\";\n    GL[GL[\"COMPILE_STATUS\"] = 35713] = \"COMPILE_STATUS\";\n    GL[GL[\"DELETE_STATUS\"] = 35712] = \"DELETE_STATUS\";\n    GL[GL[\"LINK_STATUS\"] = 35714] = \"LINK_STATUS\";\n    GL[GL[\"VALIDATE_STATUS\"] = 35715] = \"VALIDATE_STATUS\";\n    GL[GL[\"ATTACHED_SHADERS\"] = 35717] = \"ATTACHED_SHADERS\";\n    GL[GL[\"ACTIVE_ATTRIBUTES\"] = 35721] = \"ACTIVE_ATTRIBUTES\";\n    GL[GL[\"ACTIVE_UNIFORMS\"] = 35718] = \"ACTIVE_UNIFORMS\";\n    GL[GL[\"MAX_VERTEX_ATTRIBS\"] = 34921] = \"MAX_VERTEX_ATTRIBS\";\n    GL[GL[\"MAX_VERTEX_UNIFORM_VECTORS\"] = 36347] = \"MAX_VERTEX_UNIFORM_VECTORS\";\n    GL[GL[\"MAX_VARYING_VECTORS\"] = 36348] = \"MAX_VARYING_VECTORS\";\n    GL[GL[\"MAX_COMBINED_TEXTURE_IMAGE_UNITS\"] = 35661] = \"MAX_COMBINED_TEXTURE_IMAGE_UNITS\";\n    GL[GL[\"MAX_VERTEX_TEXTURE_IMAGE_UNITS\"] = 35660] = \"MAX_VERTEX_TEXTURE_IMAGE_UNITS\";\n    GL[GL[\"MAX_TEXTURE_IMAGE_UNITS\"] = 34930] = \"MAX_TEXTURE_IMAGE_UNITS\";\n    GL[GL[\"MAX_FRAGMENT_UNIFORM_VECTORS\"] = 36349] = \"MAX_FRAGMENT_UNIFORM_VECTORS\";\n    GL[GL[\"SHADER_TYPE\"] = 35663] = \"SHADER_TYPE\";\n    GL[GL[\"SHADING_LANGUAGE_VERSION\"] = 35724] = \"SHADING_LANGUAGE_VERSION\";\n    GL[GL[\"CURRENT_PROGRAM\"] = 35725] = \"CURRENT_PROGRAM\";\n    // Depth or stencil tests\n    // Constants passed to depthFunc() or stencilFunc().\n    GL[GL[\"NEVER\"] = 512] = \"NEVER\";\n    GL[GL[\"ALWAYS\"] = 519] = \"ALWAYS\";\n    GL[GL[\"LESS\"] = 513] = \"LESS\";\n    GL[GL[\"EQUAL\"] = 514] = \"EQUAL\";\n    GL[GL[\"LEQUAL\"] = 515] = \"LEQUAL\";\n    GL[GL[\"GREATER\"] = 516] = \"GREATER\";\n    GL[GL[\"GEQUAL\"] = 518] = \"GEQUAL\";\n    GL[GL[\"NOTEQUAL\"] = 517] = \"NOTEQUAL\";\n    // Stencil actions\n    // Constants passed to stencilOp().\n    GL[GL[\"KEEP\"] = 7680] = \"KEEP\";\n    GL[GL[\"REPLACE\"] = 7681] = \"REPLACE\";\n    GL[GL[\"INCR\"] = 7682] = \"INCR\";\n    GL[GL[\"DECR\"] = 7683] = \"DECR\";\n    GL[GL[\"INVERT\"] = 5386] = \"INVERT\";\n    GL[GL[\"INCR_WRAP\"] = 34055] = \"INCR_WRAP\";\n    GL[GL[\"DECR_WRAP\"] = 34056] = \"DECR_WRAP\";\n    // Textures\n    // Constants passed to texParameteri(),\n    // texParameterf(), bindTexture(), texImage2D(), and others.\n    GL[GL[\"NEAREST\"] = 9728] = \"NEAREST\";\n    GL[GL[\"LINEAR\"] = 9729] = \"LINEAR\";\n    GL[GL[\"NEAREST_MIPMAP_NEAREST\"] = 9984] = \"NEAREST_MIPMAP_NEAREST\";\n    GL[GL[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n    GL[GL[\"NEAREST_MIPMAP_LINEAR\"] = 9986] = \"NEAREST_MIPMAP_LINEAR\";\n    GL[GL[\"LINEAR_MIPMAP_LINEAR\"] = 9987] = \"LINEAR_MIPMAP_LINEAR\";\n    GL[GL[\"TEXTURE_MAG_FILTER\"] = 10240] = \"TEXTURE_MAG_FILTER\";\n    GL[GL[\"TEXTURE_MIN_FILTER\"] = 10241] = \"TEXTURE_MIN_FILTER\";\n    GL[GL[\"TEXTURE_WRAP_S\"] = 10242] = \"TEXTURE_WRAP_S\";\n    GL[GL[\"TEXTURE_WRAP_T\"] = 10243] = \"TEXTURE_WRAP_T\";\n    GL[GL[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n    GL[GL[\"TEXTURE\"] = 5890] = \"TEXTURE\";\n    GL[GL[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n    GL[GL[\"TEXTURE_BINDING_CUBE_MAP\"] = 34068] = \"TEXTURE_BINDING_CUBE_MAP\";\n    GL[GL[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n    GL[GL[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n    GL[GL[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n    GL[GL[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n    GL[GL[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n    GL[GL[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n    GL[GL[\"MAX_CUBE_MAP_TEXTURE_SIZE\"] = 34076] = \"MAX_CUBE_MAP_TEXTURE_SIZE\";\n    // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.\n    GL[GL[\"TEXTURE0\"] = 33984] = \"TEXTURE0\";\n    GL[GL[\"ACTIVE_TEXTURE\"] = 34016] = \"ACTIVE_TEXTURE\";\n    GL[GL[\"REPEAT\"] = 10497] = \"REPEAT\";\n    GL[GL[\"CLAMP_TO_EDGE\"] = 33071] = \"CLAMP_TO_EDGE\";\n    GL[GL[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n    // Emulation\n    GL[GL[\"TEXTURE_WIDTH\"] = 4096] = \"TEXTURE_WIDTH\";\n    GL[GL[\"TEXTURE_HEIGHT\"] = 4097] = \"TEXTURE_HEIGHT\";\n    // Uniform types\n    GL[GL[\"FLOAT_VEC2\"] = 35664] = \"FLOAT_VEC2\";\n    GL[GL[\"FLOAT_VEC3\"] = 35665] = \"FLOAT_VEC3\";\n    GL[GL[\"FLOAT_VEC4\"] = 35666] = \"FLOAT_VEC4\";\n    GL[GL[\"INT_VEC2\"] = 35667] = \"INT_VEC2\";\n    GL[GL[\"INT_VEC3\"] = 35668] = \"INT_VEC3\";\n    GL[GL[\"INT_VEC4\"] = 35669] = \"INT_VEC4\";\n    GL[GL[\"BOOL\"] = 35670] = \"BOOL\";\n    GL[GL[\"BOOL_VEC2\"] = 35671] = \"BOOL_VEC2\";\n    GL[GL[\"BOOL_VEC3\"] = 35672] = \"BOOL_VEC3\";\n    GL[GL[\"BOOL_VEC4\"] = 35673] = \"BOOL_VEC4\";\n    GL[GL[\"FLOAT_MAT2\"] = 35674] = \"FLOAT_MAT2\";\n    GL[GL[\"FLOAT_MAT3\"] = 35675] = \"FLOAT_MAT3\";\n    GL[GL[\"FLOAT_MAT4\"] = 35676] = \"FLOAT_MAT4\";\n    GL[GL[\"SAMPLER_2D\"] = 35678] = \"SAMPLER_2D\";\n    GL[GL[\"SAMPLER_CUBE\"] = 35680] = \"SAMPLER_CUBE\";\n    // Shader precision-specified types\n    GL[GL[\"LOW_FLOAT\"] = 36336] = \"LOW_FLOAT\";\n    GL[GL[\"MEDIUM_FLOAT\"] = 36337] = \"MEDIUM_FLOAT\";\n    GL[GL[\"HIGH_FLOAT\"] = 36338] = \"HIGH_FLOAT\";\n    GL[GL[\"LOW_INT\"] = 36339] = \"LOW_INT\";\n    GL[GL[\"MEDIUM_INT\"] = 36340] = \"MEDIUM_INT\";\n    GL[GL[\"HIGH_INT\"] = 36341] = \"HIGH_INT\";\n    // Framebuffers and renderbuffers\n    GL[GL[\"FRAMEBUFFER\"] = 36160] = \"FRAMEBUFFER\";\n    GL[GL[\"RENDERBUFFER\"] = 36161] = \"RENDERBUFFER\";\n    GL[GL[\"RGBA4\"] = 32854] = \"RGBA4\";\n    GL[GL[\"RGB5_A1\"] = 32855] = \"RGB5_A1\";\n    GL[GL[\"RGB565\"] = 36194] = \"RGB565\";\n    GL[GL[\"DEPTH_COMPONENT16\"] = 33189] = \"DEPTH_COMPONENT16\";\n    GL[GL[\"STENCIL_INDEX\"] = 6401] = \"STENCIL_INDEX\";\n    GL[GL[\"STENCIL_INDEX8\"] = 36168] = \"STENCIL_INDEX8\";\n    GL[GL[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n    GL[GL[\"RENDERBUFFER_WIDTH\"] = 36162] = \"RENDERBUFFER_WIDTH\";\n    GL[GL[\"RENDERBUFFER_HEIGHT\"] = 36163] = \"RENDERBUFFER_HEIGHT\";\n    GL[GL[\"RENDERBUFFER_INTERNAL_FORMAT\"] = 36164] = \"RENDERBUFFER_INTERNAL_FORMAT\";\n    GL[GL[\"RENDERBUFFER_RED_SIZE\"] = 36176] = \"RENDERBUFFER_RED_SIZE\";\n    GL[GL[\"RENDERBUFFER_GREEN_SIZE\"] = 36177] = \"RENDERBUFFER_GREEN_SIZE\";\n    GL[GL[\"RENDERBUFFER_BLUE_SIZE\"] = 36178] = \"RENDERBUFFER_BLUE_SIZE\";\n    GL[GL[\"RENDERBUFFER_ALPHA_SIZE\"] = 36179] = \"RENDERBUFFER_ALPHA_SIZE\";\n    GL[GL[\"RENDERBUFFER_DEPTH_SIZE\"] = 36180] = \"RENDERBUFFER_DEPTH_SIZE\";\n    GL[GL[\"RENDERBUFFER_STENCIL_SIZE\"] = 36181] = \"RENDERBUFFER_STENCIL_SIZE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE\"] = 36048] = \"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME\"] = 36049] = \"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL\"] = 36050] = \"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE\"] = 36051] = \"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE\";\n    GL[GL[\"COLOR_ATTACHMENT0\"] = 36064] = \"COLOR_ATTACHMENT0\";\n    GL[GL[\"DEPTH_ATTACHMENT\"] = 36096] = \"DEPTH_ATTACHMENT\";\n    GL[GL[\"STENCIL_ATTACHMENT\"] = 36128] = \"STENCIL_ATTACHMENT\";\n    GL[GL[\"DEPTH_STENCIL_ATTACHMENT\"] = 33306] = \"DEPTH_STENCIL_ATTACHMENT\";\n    GL[GL[\"NONE\"] = 0] = \"NONE\";\n    GL[GL[\"FRAMEBUFFER_COMPLETE\"] = 36053] = \"FRAMEBUFFER_COMPLETE\";\n    GL[GL[\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\"] = 36054] = \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n    GL[GL[\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\"] = 36055] = \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n    GL[GL[\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\"] = 36057] = \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n    GL[GL[\"FRAMEBUFFER_UNSUPPORTED\"] = 36061] = \"FRAMEBUFFER_UNSUPPORTED\";\n    GL[GL[\"FRAMEBUFFER_BINDING\"] = 36006] = \"FRAMEBUFFER_BINDING\";\n    GL[GL[\"RENDERBUFFER_BINDING\"] = 36007] = \"RENDERBUFFER_BINDING\";\n    GL[GL[\"READ_FRAMEBUFFER\"] = 36008] = \"READ_FRAMEBUFFER\";\n    GL[GL[\"DRAW_FRAMEBUFFER\"] = 36009] = \"DRAW_FRAMEBUFFER\";\n    GL[GL[\"MAX_RENDERBUFFER_SIZE\"] = 34024] = \"MAX_RENDERBUFFER_SIZE\";\n    GL[GL[\"INVALID_FRAMEBUFFER_OPERATION\"] = 1286] = \"INVALID_FRAMEBUFFER_OPERATION\";\n    // Pixel storage modes\n    // Constants passed to pixelStorei().\n    GL[GL[\"UNPACK_FLIP_Y_WEBGL\"] = 37440] = \"UNPACK_FLIP_Y_WEBGL\";\n    GL[GL[\"UNPACK_PREMULTIPLY_ALPHA_WEBGL\"] = 37441] = \"UNPACK_PREMULTIPLY_ALPHA_WEBGL\";\n    GL[GL[\"UNPACK_COLORSPACE_CONVERSION_WEBGL\"] = 37443] = \"UNPACK_COLORSPACE_CONVERSION_WEBGL\";\n    // /////////////////////////////////////////////////////\n    // Additional constants defined WebGL 2\n    // These constants are defined on the WebGL2RenderingContext interface.\n    // All WebGL 1 constants are also available in a WebGL 2 context.\n    // /////////////////////////////////////////////////////\n    // Getting GL parameter information\n    // Constants passed to getParameter()\n    // to specify what information to return.\n    GL[GL[\"READ_BUFFER\"] = 3074] = \"READ_BUFFER\";\n    GL[GL[\"UNPACK_ROW_LENGTH\"] = 3314] = \"UNPACK_ROW_LENGTH\";\n    GL[GL[\"UNPACK_SKIP_ROWS\"] = 3315] = \"UNPACK_SKIP_ROWS\";\n    GL[GL[\"UNPACK_SKIP_PIXELS\"] = 3316] = \"UNPACK_SKIP_PIXELS\";\n    GL[GL[\"PACK_ROW_LENGTH\"] = 3330] = \"PACK_ROW_LENGTH\";\n    GL[GL[\"PACK_SKIP_ROWS\"] = 3331] = \"PACK_SKIP_ROWS\";\n    GL[GL[\"PACK_SKIP_PIXELS\"] = 3332] = \"PACK_SKIP_PIXELS\";\n    GL[GL[\"TEXTURE_BINDING_3D\"] = 32874] = \"TEXTURE_BINDING_3D\";\n    GL[GL[\"UNPACK_SKIP_IMAGES\"] = 32877] = \"UNPACK_SKIP_IMAGES\";\n    GL[GL[\"UNPACK_IMAGE_HEIGHT\"] = 32878] = \"UNPACK_IMAGE_HEIGHT\";\n    GL[GL[\"MAX_3D_TEXTURE_SIZE\"] = 32883] = \"MAX_3D_TEXTURE_SIZE\";\n    GL[GL[\"MAX_ELEMENTS_VERTICES\"] = 33000] = \"MAX_ELEMENTS_VERTICES\";\n    GL[GL[\"MAX_ELEMENTS_INDICES\"] = 33001] = \"MAX_ELEMENTS_INDICES\";\n    GL[GL[\"MAX_TEXTURE_LOD_BIAS\"] = 34045] = \"MAX_TEXTURE_LOD_BIAS\";\n    GL[GL[\"MAX_FRAGMENT_UNIFORM_COMPONENTS\"] = 35657] = \"MAX_FRAGMENT_UNIFORM_COMPONENTS\";\n    GL[GL[\"MAX_VERTEX_UNIFORM_COMPONENTS\"] = 35658] = \"MAX_VERTEX_UNIFORM_COMPONENTS\";\n    GL[GL[\"MAX_ARRAY_TEXTURE_LAYERS\"] = 35071] = \"MAX_ARRAY_TEXTURE_LAYERS\";\n    GL[GL[\"MIN_PROGRAM_TEXEL_OFFSET\"] = 35076] = \"MIN_PROGRAM_TEXEL_OFFSET\";\n    GL[GL[\"MAX_PROGRAM_TEXEL_OFFSET\"] = 35077] = \"MAX_PROGRAM_TEXEL_OFFSET\";\n    GL[GL[\"MAX_VARYING_COMPONENTS\"] = 35659] = \"MAX_VARYING_COMPONENTS\";\n    GL[GL[\"FRAGMENT_SHADER_DERIVATIVE_HINT\"] = 35723] = \"FRAGMENT_SHADER_DERIVATIVE_HINT\";\n    GL[GL[\"RASTERIZER_DISCARD\"] = 35977] = \"RASTERIZER_DISCARD\";\n    GL[GL[\"VERTEX_ARRAY_BINDING\"] = 34229] = \"VERTEX_ARRAY_BINDING\";\n    GL[GL[\"MAX_VERTEX_OUTPUT_COMPONENTS\"] = 37154] = \"MAX_VERTEX_OUTPUT_COMPONENTS\";\n    GL[GL[\"MAX_FRAGMENT_INPUT_COMPONENTS\"] = 37157] = \"MAX_FRAGMENT_INPUT_COMPONENTS\";\n    GL[GL[\"MAX_SERVER_WAIT_TIMEOUT\"] = 37137] = \"MAX_SERVER_WAIT_TIMEOUT\";\n    GL[GL[\"MAX_ELEMENT_INDEX\"] = 36203] = \"MAX_ELEMENT_INDEX\";\n    // Textures\n    // Constants passed to texParameteri(),\n    // texParameterf(), bindTexture(), texImage2D(), and others.\n    GL[GL[\"RED\"] = 6403] = \"RED\";\n    GL[GL[\"RGB8\"] = 32849] = \"RGB8\";\n    GL[GL[\"RGBA8\"] = 32856] = \"RGBA8\";\n    GL[GL[\"RGB10_A2\"] = 32857] = \"RGB10_A2\";\n    GL[GL[\"TEXTURE_3D\"] = 32879] = \"TEXTURE_3D\";\n    GL[GL[\"TEXTURE_WRAP_R\"] = 32882] = \"TEXTURE_WRAP_R\";\n    GL[GL[\"TEXTURE_MIN_LOD\"] = 33082] = \"TEXTURE_MIN_LOD\";\n    GL[GL[\"TEXTURE_MAX_LOD\"] = 33083] = \"TEXTURE_MAX_LOD\";\n    GL[GL[\"TEXTURE_BASE_LEVEL\"] = 33084] = \"TEXTURE_BASE_LEVEL\";\n    GL[GL[\"TEXTURE_MAX_LEVEL\"] = 33085] = \"TEXTURE_MAX_LEVEL\";\n    GL[GL[\"TEXTURE_COMPARE_MODE\"] = 34892] = \"TEXTURE_COMPARE_MODE\";\n    GL[GL[\"TEXTURE_COMPARE_FUNC\"] = 34893] = \"TEXTURE_COMPARE_FUNC\";\n    GL[GL[\"SRGB\"] = 35904] = \"SRGB\";\n    GL[GL[\"SRGB8\"] = 35905] = \"SRGB8\";\n    GL[GL[\"SRGB8_ALPHA8\"] = 35907] = \"SRGB8_ALPHA8\";\n    GL[GL[\"COMPARE_REF_TO_TEXTURE\"] = 34894] = \"COMPARE_REF_TO_TEXTURE\";\n    GL[GL[\"RGBA32F\"] = 34836] = \"RGBA32F\";\n    GL[GL[\"RGB32F\"] = 34837] = \"RGB32F\";\n    GL[GL[\"RGBA16F\"] = 34842] = \"RGBA16F\";\n    GL[GL[\"RGB16F\"] = 34843] = \"RGB16F\";\n    GL[GL[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n    GL[GL[\"TEXTURE_BINDING_2D_ARRAY\"] = 35869] = \"TEXTURE_BINDING_2D_ARRAY\";\n    GL[GL[\"R11F_G11F_B10F\"] = 35898] = \"R11F_G11F_B10F\";\n    GL[GL[\"RGB9_E5\"] = 35901] = \"RGB9_E5\";\n    GL[GL[\"RGBA32UI\"] = 36208] = \"RGBA32UI\";\n    GL[GL[\"RGB32UI\"] = 36209] = \"RGB32UI\";\n    GL[GL[\"RGBA16UI\"] = 36214] = \"RGBA16UI\";\n    GL[GL[\"RGB16UI\"] = 36215] = \"RGB16UI\";\n    GL[GL[\"RGBA8UI\"] = 36220] = \"RGBA8UI\";\n    GL[GL[\"RGB8UI\"] = 36221] = \"RGB8UI\";\n    GL[GL[\"RGBA32I\"] = 36226] = \"RGBA32I\";\n    GL[GL[\"RGB32I\"] = 36227] = \"RGB32I\";\n    GL[GL[\"RGBA16I\"] = 36232] = \"RGBA16I\";\n    GL[GL[\"RGB16I\"] = 36233] = \"RGB16I\";\n    GL[GL[\"RGBA8I\"] = 36238] = \"RGBA8I\";\n    GL[GL[\"RGB8I\"] = 36239] = \"RGB8I\";\n    GL[GL[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n    GL[GL[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n    GL[GL[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n    GL[GL[\"R8\"] = 33321] = \"R8\";\n    GL[GL[\"RG8\"] = 33323] = \"RG8\";\n    GL[GL[\"R16F\"] = 33325] = \"R16F\";\n    GL[GL[\"R32F\"] = 33326] = \"R32F\";\n    GL[GL[\"RG16F\"] = 33327] = \"RG16F\";\n    GL[GL[\"RG32F\"] = 33328] = \"RG32F\";\n    GL[GL[\"R8I\"] = 33329] = \"R8I\";\n    GL[GL[\"R8UI\"] = 33330] = \"R8UI\";\n    GL[GL[\"R16I\"] = 33331] = \"R16I\";\n    GL[GL[\"R16UI\"] = 33332] = \"R16UI\";\n    GL[GL[\"R32I\"] = 33333] = \"R32I\";\n    GL[GL[\"R32UI\"] = 33334] = \"R32UI\";\n    GL[GL[\"RG8I\"] = 33335] = \"RG8I\";\n    GL[GL[\"RG8UI\"] = 33336] = \"RG8UI\";\n    GL[GL[\"RG16I\"] = 33337] = \"RG16I\";\n    GL[GL[\"RG16UI\"] = 33338] = \"RG16UI\";\n    GL[GL[\"RG32I\"] = 33339] = \"RG32I\";\n    GL[GL[\"RG32UI\"] = 33340] = \"RG32UI\";\n    GL[GL[\"R8_SNORM\"] = 36756] = \"R8_SNORM\";\n    GL[GL[\"RG8_SNORM\"] = 36757] = \"RG8_SNORM\";\n    GL[GL[\"RGB8_SNORM\"] = 36758] = \"RGB8_SNORM\";\n    GL[GL[\"RGBA8_SNORM\"] = 36759] = \"RGBA8_SNORM\";\n    GL[GL[\"RGB10_A2UI\"] = 36975] = \"RGB10_A2UI\";\n    /* covered by extension\n      COMPRESSED_R11_EAC  = 0x9270,\n      COMPRESSED_SIGNED_R11_EAC = 0x9271,\n      COMPRESSED_RG11_EAC = 0x9272,\n      COMPRESSED_SIGNED_RG11_EAC  = 0x9273,\n      COMPRESSED_RGB8_ETC2  = 0x9274,\n      COMPRESSED_SRGB8_ETC2 = 0x9275,\n      COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2  = 0x9276,\n      COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC  = 0x9277,\n      COMPRESSED_RGBA8_ETC2_EAC = 0x9278,\n      COMPRESSED_SRGB8_ALPHA8_ETC2_EAC  = 0x9279,\n      */\n    GL[GL[\"TEXTURE_IMMUTABLE_FORMAT\"] = 37167] = \"TEXTURE_IMMUTABLE_FORMAT\";\n    GL[GL[\"TEXTURE_IMMUTABLE_LEVELS\"] = 33503] = \"TEXTURE_IMMUTABLE_LEVELS\";\n    // Pixel types\n    GL[GL[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n    GL[GL[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n    GL[GL[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n    GL[GL[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n    GL[GL[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n    GL[GL[\"HALF_FLOAT\"] = 5131] = \"HALF_FLOAT\";\n    GL[GL[\"RG\"] = 33319] = \"RG\";\n    GL[GL[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n    GL[GL[\"INT_2_10_10_10_REV\"] = 36255] = \"INT_2_10_10_10_REV\";\n    // Queries\n    GL[GL[\"CURRENT_QUERY\"] = 34917] = \"CURRENT_QUERY\";\n    GL[GL[\"QUERY_RESULT\"] = 34918] = \"QUERY_RESULT\";\n    GL[GL[\"QUERY_RESULT_AVAILABLE\"] = 34919] = \"QUERY_RESULT_AVAILABLE\";\n    GL[GL[\"ANY_SAMPLES_PASSED\"] = 35887] = \"ANY_SAMPLES_PASSED\";\n    GL[GL[\"ANY_SAMPLES_PASSED_CONSERVATIVE\"] = 36202] = \"ANY_SAMPLES_PASSED_CONSERVATIVE\";\n    // Draw buffers\n    GL[GL[\"MAX_DRAW_BUFFERS\"] = 34852] = \"MAX_DRAW_BUFFERS\";\n    GL[GL[\"DRAW_BUFFER0\"] = 34853] = \"DRAW_BUFFER0\";\n    GL[GL[\"DRAW_BUFFER1\"] = 34854] = \"DRAW_BUFFER1\";\n    GL[GL[\"DRAW_BUFFER2\"] = 34855] = \"DRAW_BUFFER2\";\n    GL[GL[\"DRAW_BUFFER3\"] = 34856] = \"DRAW_BUFFER3\";\n    GL[GL[\"DRAW_BUFFER4\"] = 34857] = \"DRAW_BUFFER4\";\n    GL[GL[\"DRAW_BUFFER5\"] = 34858] = \"DRAW_BUFFER5\";\n    GL[GL[\"DRAW_BUFFER6\"] = 34859] = \"DRAW_BUFFER6\";\n    GL[GL[\"DRAW_BUFFER7\"] = 34860] = \"DRAW_BUFFER7\";\n    GL[GL[\"DRAW_BUFFER8\"] = 34861] = \"DRAW_BUFFER8\";\n    GL[GL[\"DRAW_BUFFER9\"] = 34862] = \"DRAW_BUFFER9\";\n    GL[GL[\"DRAW_BUFFER10\"] = 34863] = \"DRAW_BUFFER10\";\n    GL[GL[\"DRAW_BUFFER11\"] = 34864] = \"DRAW_BUFFER11\";\n    GL[GL[\"DRAW_BUFFER12\"] = 34865] = \"DRAW_BUFFER12\";\n    GL[GL[\"DRAW_BUFFER13\"] = 34866] = \"DRAW_BUFFER13\";\n    GL[GL[\"DRAW_BUFFER14\"] = 34867] = \"DRAW_BUFFER14\";\n    GL[GL[\"DRAW_BUFFER15\"] = 34868] = \"DRAW_BUFFER15\";\n    GL[GL[\"MAX_COLOR_ATTACHMENTS\"] = 36063] = \"MAX_COLOR_ATTACHMENTS\";\n    GL[GL[\"COLOR_ATTACHMENT1\"] = 36065] = \"COLOR_ATTACHMENT1\";\n    GL[GL[\"COLOR_ATTACHMENT2\"] = 36066] = \"COLOR_ATTACHMENT2\";\n    GL[GL[\"COLOR_ATTACHMENT3\"] = 36067] = \"COLOR_ATTACHMENT3\";\n    GL[GL[\"COLOR_ATTACHMENT4\"] = 36068] = \"COLOR_ATTACHMENT4\";\n    GL[GL[\"COLOR_ATTACHMENT5\"] = 36069] = \"COLOR_ATTACHMENT5\";\n    GL[GL[\"COLOR_ATTACHMENT6\"] = 36070] = \"COLOR_ATTACHMENT6\";\n    GL[GL[\"COLOR_ATTACHMENT7\"] = 36071] = \"COLOR_ATTACHMENT7\";\n    GL[GL[\"COLOR_ATTACHMENT8\"] = 36072] = \"COLOR_ATTACHMENT8\";\n    GL[GL[\"COLOR_ATTACHMENT9\"] = 36073] = \"COLOR_ATTACHMENT9\";\n    GL[GL[\"COLOR_ATTACHMENT10\"] = 36074] = \"COLOR_ATTACHMENT10\";\n    GL[GL[\"COLOR_ATTACHMENT11\"] = 36075] = \"COLOR_ATTACHMENT11\";\n    GL[GL[\"COLOR_ATTACHMENT12\"] = 36076] = \"COLOR_ATTACHMENT12\";\n    GL[GL[\"COLOR_ATTACHMENT13\"] = 36077] = \"COLOR_ATTACHMENT13\";\n    GL[GL[\"COLOR_ATTACHMENT14\"] = 36078] = \"COLOR_ATTACHMENT14\";\n    GL[GL[\"COLOR_ATTACHMENT15\"] = 36079] = \"COLOR_ATTACHMENT15\";\n    // Samplers\n    GL[GL[\"SAMPLER_3D\"] = 35679] = \"SAMPLER_3D\";\n    GL[GL[\"SAMPLER_2D_SHADOW\"] = 35682] = \"SAMPLER_2D_SHADOW\";\n    GL[GL[\"SAMPLER_2D_ARRAY\"] = 36289] = \"SAMPLER_2D_ARRAY\";\n    GL[GL[\"SAMPLER_2D_ARRAY_SHADOW\"] = 36292] = \"SAMPLER_2D_ARRAY_SHADOW\";\n    GL[GL[\"SAMPLER_CUBE_SHADOW\"] = 36293] = \"SAMPLER_CUBE_SHADOW\";\n    GL[GL[\"INT_SAMPLER_2D\"] = 36298] = \"INT_SAMPLER_2D\";\n    GL[GL[\"INT_SAMPLER_3D\"] = 36299] = \"INT_SAMPLER_3D\";\n    GL[GL[\"INT_SAMPLER_CUBE\"] = 36300] = \"INT_SAMPLER_CUBE\";\n    GL[GL[\"INT_SAMPLER_2D_ARRAY\"] = 36303] = \"INT_SAMPLER_2D_ARRAY\";\n    GL[GL[\"UNSIGNED_INT_SAMPLER_2D\"] = 36306] = \"UNSIGNED_INT_SAMPLER_2D\";\n    GL[GL[\"UNSIGNED_INT_SAMPLER_3D\"] = 36307] = \"UNSIGNED_INT_SAMPLER_3D\";\n    GL[GL[\"UNSIGNED_INT_SAMPLER_CUBE\"] = 36308] = \"UNSIGNED_INT_SAMPLER_CUBE\";\n    GL[GL[\"UNSIGNED_INT_SAMPLER_2D_ARRAY\"] = 36311] = \"UNSIGNED_INT_SAMPLER_2D_ARRAY\";\n    GL[GL[\"MAX_SAMPLES\"] = 36183] = \"MAX_SAMPLES\";\n    GL[GL[\"SAMPLER_BINDING\"] = 35097] = \"SAMPLER_BINDING\";\n    // Buffers\n    GL[GL[\"PIXEL_PACK_BUFFER\"] = 35051] = \"PIXEL_PACK_BUFFER\";\n    GL[GL[\"PIXEL_UNPACK_BUFFER\"] = 35052] = \"PIXEL_UNPACK_BUFFER\";\n    GL[GL[\"PIXEL_PACK_BUFFER_BINDING\"] = 35053] = \"PIXEL_PACK_BUFFER_BINDING\";\n    GL[GL[\"PIXEL_UNPACK_BUFFER_BINDING\"] = 35055] = \"PIXEL_UNPACK_BUFFER_BINDING\";\n    GL[GL[\"COPY_READ_BUFFER\"] = 36662] = \"COPY_READ_BUFFER\";\n    GL[GL[\"COPY_WRITE_BUFFER\"] = 36663] = \"COPY_WRITE_BUFFER\";\n    GL[GL[\"COPY_READ_BUFFER_BINDING\"] = 36662] = \"COPY_READ_BUFFER_BINDING\";\n    GL[GL[\"COPY_WRITE_BUFFER_BINDING\"] = 36663] = \"COPY_WRITE_BUFFER_BINDING\";\n    // Data types\n    GL[GL[\"FLOAT_MAT2x3\"] = 35685] = \"FLOAT_MAT2x3\";\n    GL[GL[\"FLOAT_MAT2x4\"] = 35686] = \"FLOAT_MAT2x4\";\n    GL[GL[\"FLOAT_MAT3x2\"] = 35687] = \"FLOAT_MAT3x2\";\n    GL[GL[\"FLOAT_MAT3x4\"] = 35688] = \"FLOAT_MAT3x4\";\n    GL[GL[\"FLOAT_MAT4x2\"] = 35689] = \"FLOAT_MAT4x2\";\n    GL[GL[\"FLOAT_MAT4x3\"] = 35690] = \"FLOAT_MAT4x3\";\n    GL[GL[\"UNSIGNED_INT_VEC2\"] = 36294] = \"UNSIGNED_INT_VEC2\";\n    GL[GL[\"UNSIGNED_INT_VEC3\"] = 36295] = \"UNSIGNED_INT_VEC3\";\n    GL[GL[\"UNSIGNED_INT_VEC4\"] = 36296] = \"UNSIGNED_INT_VEC4\";\n    GL[GL[\"UNSIGNED_NORMALIZED\"] = 35863] = \"UNSIGNED_NORMALIZED\";\n    GL[GL[\"SIGNED_NORMALIZED\"] = 36764] = \"SIGNED_NORMALIZED\";\n    // Vertex attributes\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_INTEGER\"] = 35069] = \"VERTEX_ATTRIB_ARRAY_INTEGER\";\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_DIVISOR\"] = 35070] = \"VERTEX_ATTRIB_ARRAY_DIVISOR\";\n    // Transform feedback\n    GL[GL[\"TRANSFORM_FEEDBACK_BUFFER_MODE\"] = 35967] = \"TRANSFORM_FEEDBACK_BUFFER_MODE\";\n    GL[GL[\"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS\"] = 35968] = \"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS\";\n    GL[GL[\"TRANSFORM_FEEDBACK_VARYINGS\"] = 35971] = \"TRANSFORM_FEEDBACK_VARYINGS\";\n    GL[GL[\"TRANSFORM_FEEDBACK_BUFFER_START\"] = 35972] = \"TRANSFORM_FEEDBACK_BUFFER_START\";\n    GL[GL[\"TRANSFORM_FEEDBACK_BUFFER_SIZE\"] = 35973] = \"TRANSFORM_FEEDBACK_BUFFER_SIZE\";\n    GL[GL[\"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN\"] = 35976] = \"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN\";\n    GL[GL[\"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS\"] = 35978] = \"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS\";\n    GL[GL[\"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS\"] = 35979] = \"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS\";\n    GL[GL[\"INTERLEAVED_ATTRIBS\"] = 35980] = \"INTERLEAVED_ATTRIBS\";\n    GL[GL[\"SEPARATE_ATTRIBS\"] = 35981] = \"SEPARATE_ATTRIBS\";\n    GL[GL[\"TRANSFORM_FEEDBACK_BUFFER\"] = 35982] = \"TRANSFORM_FEEDBACK_BUFFER\";\n    GL[GL[\"TRANSFORM_FEEDBACK_BUFFER_BINDING\"] = 35983] = \"TRANSFORM_FEEDBACK_BUFFER_BINDING\";\n    GL[GL[\"TRANSFORM_FEEDBACK\"] = 36386] = \"TRANSFORM_FEEDBACK\";\n    GL[GL[\"TRANSFORM_FEEDBACK_PAUSED\"] = 36387] = \"TRANSFORM_FEEDBACK_PAUSED\";\n    GL[GL[\"TRANSFORM_FEEDBACK_ACTIVE\"] = 36388] = \"TRANSFORM_FEEDBACK_ACTIVE\";\n    GL[GL[\"TRANSFORM_FEEDBACK_BINDING\"] = 36389] = \"TRANSFORM_FEEDBACK_BINDING\";\n    // Framebuffers and renderbuffers\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING\"] = 33296] = \"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\"] = 33297] = \"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_RED_SIZE\"] = 33298] = \"FRAMEBUFFER_ATTACHMENT_RED_SIZE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE\"] = 33299] = \"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE\"] = 33300] = \"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE\"] = 33301] = \"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE\"] = 33302] = \"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE\"] = 33303] = \"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE\";\n    GL[GL[\"FRAMEBUFFER_DEFAULT\"] = 33304] = \"FRAMEBUFFER_DEFAULT\";\n    // DEPTH_STENCIL_ATTACHMENT  = 0x821A,\n    // DEPTH_STENCIL = 0x84F9,\n    GL[GL[\"DEPTH24_STENCIL8\"] = 35056] = \"DEPTH24_STENCIL8\";\n    GL[GL[\"DRAW_FRAMEBUFFER_BINDING\"] = 36006] = \"DRAW_FRAMEBUFFER_BINDING\";\n    GL[GL[\"READ_FRAMEBUFFER_BINDING\"] = 36010] = \"READ_FRAMEBUFFER_BINDING\";\n    GL[GL[\"RENDERBUFFER_SAMPLES\"] = 36011] = \"RENDERBUFFER_SAMPLES\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER\"] = 36052] = \"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER\";\n    GL[GL[\"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\"] = 36182] = \"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\";\n    // Uniforms\n    GL[GL[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n    GL[GL[\"UNIFORM_BUFFER_BINDING\"] = 35368] = \"UNIFORM_BUFFER_BINDING\";\n    GL[GL[\"UNIFORM_BUFFER_START\"] = 35369] = \"UNIFORM_BUFFER_START\";\n    GL[GL[\"UNIFORM_BUFFER_SIZE\"] = 35370] = \"UNIFORM_BUFFER_SIZE\";\n    GL[GL[\"MAX_VERTEX_UNIFORM_BLOCKS\"] = 35371] = \"MAX_VERTEX_UNIFORM_BLOCKS\";\n    GL[GL[\"MAX_FRAGMENT_UNIFORM_BLOCKS\"] = 35373] = \"MAX_FRAGMENT_UNIFORM_BLOCKS\";\n    GL[GL[\"MAX_COMBINED_UNIFORM_BLOCKS\"] = 35374] = \"MAX_COMBINED_UNIFORM_BLOCKS\";\n    GL[GL[\"MAX_UNIFORM_BUFFER_BINDINGS\"] = 35375] = \"MAX_UNIFORM_BUFFER_BINDINGS\";\n    GL[GL[\"MAX_UNIFORM_BLOCK_SIZE\"] = 35376] = \"MAX_UNIFORM_BLOCK_SIZE\";\n    GL[GL[\"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\"] = 35377] = \"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\";\n    GL[GL[\"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\"] = 35379] = \"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\";\n    GL[GL[\"UNIFORM_BUFFER_OFFSET_ALIGNMENT\"] = 35380] = \"UNIFORM_BUFFER_OFFSET_ALIGNMENT\";\n    GL[GL[\"ACTIVE_UNIFORM_BLOCKS\"] = 35382] = \"ACTIVE_UNIFORM_BLOCKS\";\n    GL[GL[\"UNIFORM_TYPE\"] = 35383] = \"UNIFORM_TYPE\";\n    GL[GL[\"UNIFORM_SIZE\"] = 35384] = \"UNIFORM_SIZE\";\n    GL[GL[\"UNIFORM_BLOCK_INDEX\"] = 35386] = \"UNIFORM_BLOCK_INDEX\";\n    GL[GL[\"UNIFORM_OFFSET\"] = 35387] = \"UNIFORM_OFFSET\";\n    GL[GL[\"UNIFORM_ARRAY_STRIDE\"] = 35388] = \"UNIFORM_ARRAY_STRIDE\";\n    GL[GL[\"UNIFORM_MATRIX_STRIDE\"] = 35389] = \"UNIFORM_MATRIX_STRIDE\";\n    GL[GL[\"UNIFORM_IS_ROW_MAJOR\"] = 35390] = \"UNIFORM_IS_ROW_MAJOR\";\n    GL[GL[\"UNIFORM_BLOCK_BINDING\"] = 35391] = \"UNIFORM_BLOCK_BINDING\";\n    GL[GL[\"UNIFORM_BLOCK_DATA_SIZE\"] = 35392] = \"UNIFORM_BLOCK_DATA_SIZE\";\n    GL[GL[\"UNIFORM_BLOCK_ACTIVE_UNIFORMS\"] = 35394] = \"UNIFORM_BLOCK_ACTIVE_UNIFORMS\";\n    GL[GL[\"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES\"] = 35395] = \"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES\";\n    GL[GL[\"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER\"] = 35396] = \"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER\";\n    GL[GL[\"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER\"] = 35398] = \"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER\";\n    // Sync objects\n    GL[GL[\"OBJECT_TYPE\"] = 37138] = \"OBJECT_TYPE\";\n    GL[GL[\"SYNC_CONDITION\"] = 37139] = \"SYNC_CONDITION\";\n    GL[GL[\"SYNC_STATUS\"] = 37140] = \"SYNC_STATUS\";\n    GL[GL[\"SYNC_FLAGS\"] = 37141] = \"SYNC_FLAGS\";\n    GL[GL[\"SYNC_FENCE\"] = 37142] = \"SYNC_FENCE\";\n    GL[GL[\"SYNC_GPU_COMMANDS_COMPLETE\"] = 37143] = \"SYNC_GPU_COMMANDS_COMPLETE\";\n    GL[GL[\"UNSIGNALED\"] = 37144] = \"UNSIGNALED\";\n    GL[GL[\"SIGNALED\"] = 37145] = \"SIGNALED\";\n    GL[GL[\"ALREADY_SIGNALED\"] = 37146] = \"ALREADY_SIGNALED\";\n    GL[GL[\"TIMEOUT_EXPIRED\"] = 37147] = \"TIMEOUT_EXPIRED\";\n    GL[GL[\"CONDITION_SATISFIED\"] = 37148] = \"CONDITION_SATISFIED\";\n    GL[GL[\"WAIT_FAILED\"] = 37149] = \"WAIT_FAILED\";\n    GL[GL[\"SYNC_FLUSH_COMMANDS_BIT\"] = 1] = \"SYNC_FLUSH_COMMANDS_BIT\";\n    // Miscellaneous constants\n    GL[GL[\"COLOR\"] = 6144] = \"COLOR\";\n    GL[GL[\"DEPTH\"] = 6145] = \"DEPTH\";\n    GL[GL[\"STENCIL\"] = 6146] = \"STENCIL\";\n    GL[GL[\"MIN\"] = 32775] = \"MIN\";\n    GL[GL[\"MAX\"] = 32776] = \"MAX\";\n    GL[GL[\"DEPTH_COMPONENT24\"] = 33190] = \"DEPTH_COMPONENT24\";\n    GL[GL[\"STREAM_READ\"] = 35041] = \"STREAM_READ\";\n    GL[GL[\"STREAM_COPY\"] = 35042] = \"STREAM_COPY\";\n    GL[GL[\"STATIC_READ\"] = 35045] = \"STATIC_READ\";\n    GL[GL[\"STATIC_COPY\"] = 35046] = \"STATIC_COPY\";\n    GL[GL[\"DYNAMIC_READ\"] = 35049] = \"DYNAMIC_READ\";\n    GL[GL[\"DYNAMIC_COPY\"] = 35050] = \"DYNAMIC_COPY\";\n    GL[GL[\"DEPTH_COMPONENT32F\"] = 36012] = \"DEPTH_COMPONENT32F\";\n    GL[GL[\"DEPTH32F_STENCIL8\"] = 36013] = \"DEPTH32F_STENCIL8\";\n    GL[GL[\"INVALID_INDEX\"] = 4294967295] = \"INVALID_INDEX\";\n    GL[GL[\"TIMEOUT_IGNORED\"] = -1] = \"TIMEOUT_IGNORED\";\n    GL[GL[\"MAX_CLIENT_WAIT_TIMEOUT_WEBGL\"] = 37447] = \"MAX_CLIENT_WAIT_TIMEOUT_WEBGL\";\n    // Constants defined in WebGL extensions\n    // ANGLE_instanced_arrays\n    GL[GL[\"VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE\"] = 35070] = \"VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE\";\n    // WEBGL_debug_renderer_info\n    GL[GL[\"UNMASKED_VENDOR_WEBGL\"] = 37445] = \"UNMASKED_VENDOR_WEBGL\";\n    GL[GL[\"UNMASKED_RENDERER_WEBGL\"] = 37446] = \"UNMASKED_RENDERER_WEBGL\";\n    // EXT_texture_filter_anisotropic\n    GL[GL[\"MAX_TEXTURE_MAX_ANISOTROPY_EXT\"] = 34047] = \"MAX_TEXTURE_MAX_ANISOTROPY_EXT\";\n    GL[GL[\"TEXTURE_MAX_ANISOTROPY_EXT\"] = 34046] = \"TEXTURE_MAX_ANISOTROPY_EXT\";\n    // WEBGL_compressed_texture_s3tc\n    GL[GL[\"COMPRESSED_RGB_S3TC_DXT1_EXT\"] = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\";\n    GL[GL[\"COMPRESSED_RGBA_S3TC_DXT1_EXT\"] = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\";\n    GL[GL[\"COMPRESSED_RGBA_S3TC_DXT3_EXT\"] = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\";\n    GL[GL[\"COMPRESSED_RGBA_S3TC_DXT5_EXT\"] = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\";\n    // WEBGL_compressed_texture_es3\n    GL[GL[\"COMPRESSED_R11_EAC\"] = 37488] = \"COMPRESSED_R11_EAC\";\n    GL[GL[\"COMPRESSED_SIGNED_R11_EAC\"] = 37489] = \"COMPRESSED_SIGNED_R11_EAC\";\n    GL[GL[\"COMPRESSED_RG11_EAC\"] = 37490] = \"COMPRESSED_RG11_EAC\";\n    GL[GL[\"COMPRESSED_SIGNED_RG11_EAC\"] = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\";\n    GL[GL[\"COMPRESSED_RGB8_ETC2\"] = 37492] = \"COMPRESSED_RGB8_ETC2\";\n    GL[GL[\"COMPRESSED_RGBA8_ETC2_EAC\"] = 37493] = \"COMPRESSED_RGBA8_ETC2_EAC\";\n    GL[GL[\"COMPRESSED_SRGB8_ETC2\"] = 37494] = \"COMPRESSED_SRGB8_ETC2\";\n    GL[GL[\"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\"] = 37495] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\";\n    GL[GL[\"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37496] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n    GL[GL[\"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37497] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n    // WEBGL_compressed_texture_pvrtc\n    GL[GL[\"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\"] = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\";\n    GL[GL[\"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\"] = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\";\n    GL[GL[\"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\"] = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\";\n    GL[GL[\"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\"] = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\";\n    // WEBGL_compressed_texture_etc1\n    GL[GL[\"COMPRESSED_RGB_ETC1_WEBGL\"] = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\";\n    // WEBGL_compressed_texture_atc\n    GL[GL[\"COMPRESSED_RGB_ATC_WEBGL\"] = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\";\n    GL[GL[\"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\"] = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\";\n    GL[GL[\"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\"] = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\";\n    // WEBGL_depth_texture\n    GL[GL[\"UNSIGNED_INT_24_8_WEBGL\"] = 34042] = \"UNSIGNED_INT_24_8_WEBGL\";\n    // OES_texture_half_float\n    GL[GL[\"HALF_FLOAT_OES\"] = 36193] = \"HALF_FLOAT_OES\";\n    // WEBGL_color_buffer_float\n    GL[GL[\"RGBA32F_EXT\"] = 34836] = \"RGBA32F_EXT\";\n    GL[GL[\"RGB32F_EXT\"] = 34837] = \"RGB32F_EXT\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT\"] = 33297] = \"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT\";\n    GL[GL[\"UNSIGNED_NORMALIZED_EXT\"] = 35863] = \"UNSIGNED_NORMALIZED_EXT\";\n    // EXT_blend_minmax\n    GL[GL[\"MIN_EXT\"] = 32775] = \"MIN_EXT\";\n    GL[GL[\"MAX_EXT\"] = 32776] = \"MAX_EXT\";\n    // EXT_sRGB\n    GL[GL[\"SRGB_EXT\"] = 35904] = \"SRGB_EXT\";\n    GL[GL[\"SRGB_ALPHA_EXT\"] = 35906] = \"SRGB_ALPHA_EXT\";\n    GL[GL[\"SRGB8_ALPHA8_EXT\"] = 35907] = \"SRGB8_ALPHA8_EXT\";\n    GL[GL[\"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT\"] = 33296] = \"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT\";\n    // OES_standard_derivatives\n    GL[GL[\"FRAGMENT_SHADER_DERIVATIVE_HINT_OES\"] = 35723] = \"FRAGMENT_SHADER_DERIVATIVE_HINT_OES\";\n    // WEBGL_draw_buffers\n    GL[GL[\"COLOR_ATTACHMENT0_WEBGL\"] = 36064] = \"COLOR_ATTACHMENT0_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT1_WEBGL\"] = 36065] = \"COLOR_ATTACHMENT1_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT2_WEBGL\"] = 36066] = \"COLOR_ATTACHMENT2_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT3_WEBGL\"] = 36067] = \"COLOR_ATTACHMENT3_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT4_WEBGL\"] = 36068] = \"COLOR_ATTACHMENT4_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT5_WEBGL\"] = 36069] = \"COLOR_ATTACHMENT5_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT6_WEBGL\"] = 36070] = \"COLOR_ATTACHMENT6_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT7_WEBGL\"] = 36071] = \"COLOR_ATTACHMENT7_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT8_WEBGL\"] = 36072] = \"COLOR_ATTACHMENT8_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT9_WEBGL\"] = 36073] = \"COLOR_ATTACHMENT9_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT10_WEBGL\"] = 36074] = \"COLOR_ATTACHMENT10_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT11_WEBGL\"] = 36075] = \"COLOR_ATTACHMENT11_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT12_WEBGL\"] = 36076] = \"COLOR_ATTACHMENT12_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT13_WEBGL\"] = 36077] = \"COLOR_ATTACHMENT13_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT14_WEBGL\"] = 36078] = \"COLOR_ATTACHMENT14_WEBGL\";\n    GL[GL[\"COLOR_ATTACHMENT15_WEBGL\"] = 36079] = \"COLOR_ATTACHMENT15_WEBGL\";\n    GL[GL[\"DRAW_BUFFER0_WEBGL\"] = 34853] = \"DRAW_BUFFER0_WEBGL\";\n    GL[GL[\"DRAW_BUFFER1_WEBGL\"] = 34854] = \"DRAW_BUFFER1_WEBGL\";\n    GL[GL[\"DRAW_BUFFER2_WEBGL\"] = 34855] = \"DRAW_BUFFER2_WEBGL\";\n    GL[GL[\"DRAW_BUFFER3_WEBGL\"] = 34856] = \"DRAW_BUFFER3_WEBGL\";\n    GL[GL[\"DRAW_BUFFER4_WEBGL\"] = 34857] = \"DRAW_BUFFER4_WEBGL\";\n    GL[GL[\"DRAW_BUFFER5_WEBGL\"] = 34858] = \"DRAW_BUFFER5_WEBGL\";\n    GL[GL[\"DRAW_BUFFER6_WEBGL\"] = 34859] = \"DRAW_BUFFER6_WEBGL\";\n    GL[GL[\"DRAW_BUFFER7_WEBGL\"] = 34860] = \"DRAW_BUFFER7_WEBGL\";\n    GL[GL[\"DRAW_BUFFER8_WEBGL\"] = 34861] = \"DRAW_BUFFER8_WEBGL\";\n    GL[GL[\"DRAW_BUFFER9_WEBGL\"] = 34862] = \"DRAW_BUFFER9_WEBGL\";\n    GL[GL[\"DRAW_BUFFER10_WEBGL\"] = 34863] = \"DRAW_BUFFER10_WEBGL\";\n    GL[GL[\"DRAW_BUFFER11_WEBGL\"] = 34864] = \"DRAW_BUFFER11_WEBGL\";\n    GL[GL[\"DRAW_BUFFER12_WEBGL\"] = 34865] = \"DRAW_BUFFER12_WEBGL\";\n    GL[GL[\"DRAW_BUFFER13_WEBGL\"] = 34866] = \"DRAW_BUFFER13_WEBGL\";\n    GL[GL[\"DRAW_BUFFER14_WEBGL\"] = 34867] = \"DRAW_BUFFER14_WEBGL\";\n    GL[GL[\"DRAW_BUFFER15_WEBGL\"] = 34868] = \"DRAW_BUFFER15_WEBGL\";\n    GL[GL[\"MAX_COLOR_ATTACHMENTS_WEBGL\"] = 36063] = \"MAX_COLOR_ATTACHMENTS_WEBGL\";\n    GL[GL[\"MAX_DRAW_BUFFERS_WEBGL\"] = 34852] = \"MAX_DRAW_BUFFERS_WEBGL\";\n    // OES_vertex_array_object\n    GL[GL[\"VERTEX_ARRAY_BINDING_OES\"] = 34229] = \"VERTEX_ARRAY_BINDING_OES\";\n    // EXT_disjoint_timer_query\n    GL[GL[\"QUERY_COUNTER_BITS_EXT\"] = 34916] = \"QUERY_COUNTER_BITS_EXT\";\n    GL[GL[\"CURRENT_QUERY_EXT\"] = 34917] = \"CURRENT_QUERY_EXT\";\n    GL[GL[\"QUERY_RESULT_EXT\"] = 34918] = \"QUERY_RESULT_EXT\";\n    GL[GL[\"QUERY_RESULT_AVAILABLE_EXT\"] = 34919] = \"QUERY_RESULT_AVAILABLE_EXT\";\n    GL[GL[\"TIME_ELAPSED_EXT\"] = 35007] = \"TIME_ELAPSED_EXT\";\n    GL[GL[\"TIMESTAMP_EXT\"] = 36392] = \"TIMESTAMP_EXT\";\n    GL[GL[\"GPU_DISJOINT_EXT\"] = 36795] = \"GPU_DISJOINT_EXT\";\n})(exports.GL || (exports.GL = {}));\n\nexports.ResourceType = void 0;\n(function (ResourceType) {\n    ResourceType[ResourceType[\"Buffer\"] = 0] = \"Buffer\";\n    ResourceType[ResourceType[\"Texture\"] = 1] = \"Texture\";\n    ResourceType[ResourceType[\"RenderTarget\"] = 2] = \"RenderTarget\";\n    ResourceType[ResourceType[\"Sampler\"] = 3] = \"Sampler\";\n    ResourceType[ResourceType[\"Program\"] = 4] = \"Program\";\n    ResourceType[ResourceType[\"Bindings\"] = 5] = \"Bindings\";\n    ResourceType[ResourceType[\"InputLayout\"] = 6] = \"InputLayout\";\n    ResourceType[ResourceType[\"RenderPipeline\"] = 7] = \"RenderPipeline\";\n    ResourceType[ResourceType[\"ComputePipeline\"] = 8] = \"ComputePipeline\";\n    ResourceType[ResourceType[\"Readback\"] = 9] = \"Readback\";\n    ResourceType[ResourceType[\"QueryPool\"] = 10] = \"QueryPool\";\n    ResourceType[ResourceType[\"RenderBundle\"] = 11] = \"RenderBundle\";\n})(exports.ResourceType || (exports.ResourceType = {}));\nexports.CompareFunction = void 0;\n(function (CompareFunction) {\n    CompareFunction[CompareFunction[\"NEVER\"] = 512] = \"NEVER\";\n    CompareFunction[CompareFunction[\"LESS\"] = 513] = \"LESS\";\n    CompareFunction[CompareFunction[\"EQUAL\"] = 514] = \"EQUAL\";\n    CompareFunction[CompareFunction[\"LEQUAL\"] = 515] = \"LEQUAL\";\n    CompareFunction[CompareFunction[\"GREATER\"] = 516] = \"GREATER\";\n    CompareFunction[CompareFunction[\"NOTEQUAL\"] = 517] = \"NOTEQUAL\";\n    CompareFunction[CompareFunction[\"GEQUAL\"] = 518] = \"GEQUAL\";\n    CompareFunction[CompareFunction[\"ALWAYS\"] = 519] = \"ALWAYS\";\n})(exports.CompareFunction || (exports.CompareFunction = {}));\nexports.FrontFace = void 0;\n(function (FrontFace) {\n    FrontFace[FrontFace[\"CCW\"] = 2305] = \"CCW\";\n    FrontFace[FrontFace[\"CW\"] = 2304] = \"CW\";\n})(exports.FrontFace || (exports.FrontFace = {}));\nexports.CullMode = void 0;\n(function (CullMode) {\n    CullMode[CullMode[\"NONE\"] = 0] = \"NONE\";\n    CullMode[CullMode[\"FRONT\"] = 1] = \"FRONT\";\n    CullMode[CullMode[\"BACK\"] = 2] = \"BACK\";\n    CullMode[CullMode[\"FRONT_AND_BACK\"] = 3] = \"FRONT_AND_BACK\";\n})(exports.CullMode || (exports.CullMode = {}));\n/**\n * Blend factor RGBA components.\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpublendfactor\n */\nexports.BlendFactor = void 0;\n(function (BlendFactor) {\n    /**\n     * (0, 0, 0, 0)\n     */\n    BlendFactor[BlendFactor[\"ZERO\"] = 0] = \"ZERO\";\n    /**\n     * (1, 1, 1, 1)\n     */\n    BlendFactor[BlendFactor[\"ONE\"] = 1] = \"ONE\";\n    /**\n     * (Rsrc, Gsrc, Bsrc, Asrc)\n     */\n    BlendFactor[BlendFactor[\"SRC\"] = 768] = \"SRC\";\n    /**\n     * (1 - Rsrc, 1 - Gsrc, 1 - Bsrc, 1 - Asrc)\n     */\n    BlendFactor[BlendFactor[\"ONE_MINUS_SRC\"] = 769] = \"ONE_MINUS_SRC\";\n    /**\n     * (Rdst, Gdst, Bdst, Adst)\n     */\n    BlendFactor[BlendFactor[\"DST\"] = 774] = \"DST\";\n    /**\n     * (1 - Rdst, 1 - Gdst, 1 - Bdst, 1 - Adst)\n     */\n    BlendFactor[BlendFactor[\"ONE_MINUS_DST\"] = 775] = \"ONE_MINUS_DST\";\n    /**\n     * (Asrc, Asrc, Asrc, Asrc)\n     */\n    BlendFactor[BlendFactor[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n    /**\n     * (1 - Asrc, 1 - Asrc, 1 - Asrc, 1 - Asrc)\n     */\n    BlendFactor[BlendFactor[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n    /**\n     * (Adst, Adst, Adst, Adst)\n     */\n    BlendFactor[BlendFactor[\"DST_ALPHA\"] = 772] = \"DST_ALPHA\";\n    /**\n     * (1 - Adst, 1 - Adst, 1 - Adst, 1 - Adst)\n     */\n    BlendFactor[BlendFactor[\"ONE_MINUS_DST_ALPHA\"] = 773] = \"ONE_MINUS_DST_ALPHA\";\n    /**\n     * (Rconst, Gconst, Bconst, Aconst)\n     */\n    BlendFactor[BlendFactor[\"CONST\"] = 32769] = \"CONST\";\n    /**\n     * (1 - Rconst, 1 - Gconst, 1 - Bconst, 1 - Aconst)\n     */\n    BlendFactor[BlendFactor[\"ONE_MINUS_CONSTANT\"] = 32770] = \"ONE_MINUS_CONSTANT\";\n    /**\n     * (min(Asrc, 1 - Adst), min(Asrc, 1 - Adst), min(Asrc, 1 - Adst), 1)\n     */\n    BlendFactor[BlendFactor[\"SRC_ALPHA_SATURATE\"] = 776] = \"SRC_ALPHA_SATURATE\";\n})(exports.BlendFactor || (exports.BlendFactor = {}));\n/**\n * Defines the algorithm used to combine source and destination blend factors.\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpublendoperation\n */\nexports.BlendMode = void 0;\n(function (BlendMode) {\n    /**\n     * RGBAsrc  RGBAsrcFactor + RGBAdst  RGBAdstFactor\n     */\n    BlendMode[BlendMode[\"ADD\"] = 32774] = \"ADD\";\n    /**\n     * RGBAsrc  RGBAsrcFactor - RGBAdst  RGBAdstFactor\n     */\n    BlendMode[BlendMode[\"SUBSTRACT\"] = 32778] = \"SUBSTRACT\";\n    /**\n     * RGBAdst  RGBAdstFactor - RGBAsrc  RGBAsrcFactor\n     */\n    BlendMode[BlendMode[\"REVERSE_SUBSTRACT\"] = 32779] = \"REVERSE_SUBSTRACT\";\n    // TODO: WebGL 1 should use ext\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendEquation#parameters\n    /**\n     * min(RGBAsrc, RGBAdst)\n     */\n    BlendMode[BlendMode[\"MIN\"] = 32775] = \"MIN\";\n    /**\n     * max(RGBAsrc, RGBAdst)\n     */\n    BlendMode[BlendMode[\"MAX\"] = 32776] = \"MAX\";\n})(exports.BlendMode || (exports.BlendMode = {}));\nexports.AddressMode = void 0;\n(function (AddressMode) {\n    AddressMode[AddressMode[\"CLAMP_TO_EDGE\"] = 0] = \"CLAMP_TO_EDGE\";\n    AddressMode[AddressMode[\"REPEAT\"] = 1] = \"REPEAT\";\n    AddressMode[AddressMode[\"MIRRORED_REPEAT\"] = 2] = \"MIRRORED_REPEAT\";\n})(exports.AddressMode || (exports.AddressMode = {}));\nexports.FilterMode = void 0;\n(function (FilterMode) {\n    FilterMode[FilterMode[\"POINT\"] = 0] = \"POINT\";\n    FilterMode[FilterMode[\"BILINEAR\"] = 1] = \"BILINEAR\";\n})(exports.FilterMode || (exports.FilterMode = {}));\nexports.MipmapFilterMode = void 0;\n(function (MipmapFilterMode) {\n    MipmapFilterMode[MipmapFilterMode[\"NO_MIP\"] = 0] = \"NO_MIP\";\n    MipmapFilterMode[MipmapFilterMode[\"NEAREST\"] = 1] = \"NEAREST\";\n    MipmapFilterMode[MipmapFilterMode[\"LINEAR\"] = 2] = \"LINEAR\";\n})(exports.MipmapFilterMode || (exports.MipmapFilterMode = {}));\nexports.PrimitiveTopology = void 0;\n(function (PrimitiveTopology) {\n    PrimitiveTopology[PrimitiveTopology[\"POINTS\"] = 0] = \"POINTS\";\n    PrimitiveTopology[PrimitiveTopology[\"TRIANGLES\"] = 1] = \"TRIANGLES\";\n    PrimitiveTopology[PrimitiveTopology[\"TRIANGLE_STRIP\"] = 2] = \"TRIANGLE_STRIP\";\n    PrimitiveTopology[PrimitiveTopology[\"LINES\"] = 3] = \"LINES\";\n    PrimitiveTopology[PrimitiveTopology[\"LINE_STRIP\"] = 4] = \"LINE_STRIP\";\n})(exports.PrimitiveTopology || (exports.PrimitiveTopology = {}));\n/**\n * @see https://www.w3.org/TR/webgpu/#buffer-usage\n */\nexports.BufferUsage = void 0;\n(function (BufferUsage) {\n    BufferUsage[BufferUsage[\"MAP_READ\"] = 1] = \"MAP_READ\";\n    BufferUsage[BufferUsage[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n    BufferUsage[BufferUsage[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n    BufferUsage[BufferUsage[\"COPY_DST\"] = 8] = \"COPY_DST\";\n    BufferUsage[BufferUsage[\"INDEX\"] = 16] = \"INDEX\";\n    BufferUsage[BufferUsage[\"VERTEX\"] = 32] = \"VERTEX\";\n    BufferUsage[BufferUsage[\"UNIFORM\"] = 64] = \"UNIFORM\";\n    BufferUsage[BufferUsage[\"STORAGE\"] = 128] = \"STORAGE\";\n    BufferUsage[BufferUsage[\"INDIRECT\"] = 256] = \"INDIRECT\";\n    BufferUsage[BufferUsage[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n})(exports.BufferUsage || (exports.BufferUsage = {}));\nexports.BufferFrequencyHint = void 0;\n(function (BufferFrequencyHint) {\n    BufferFrequencyHint[BufferFrequencyHint[\"STATIC\"] = 1] = \"STATIC\";\n    BufferFrequencyHint[BufferFrequencyHint[\"DYNAMIC\"] = 2] = \"DYNAMIC\";\n})(exports.BufferFrequencyHint || (exports.BufferFrequencyHint = {}));\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpuvertexstepmode\n */\nexports.VertexStepMode = void 0;\n(function (VertexStepMode) {\n    VertexStepMode[VertexStepMode[\"VERTEX\"] = 1] = \"VERTEX\";\n    VertexStepMode[VertexStepMode[\"INSTANCE\"] = 2] = \"INSTANCE\";\n})(exports.VertexStepMode || (exports.VertexStepMode = {}));\nexports.TextureEvent = void 0;\n(function (TextureEvent) {\n    TextureEvent[\"LOADED\"] = \"loaded\";\n})(exports.TextureEvent || (exports.TextureEvent = {}));\nexports.TextureDimension = void 0;\n(function (TextureDimension) {\n    TextureDimension[TextureDimension[\"TEXTURE_2D\"] = 0] = \"TEXTURE_2D\";\n    TextureDimension[TextureDimension[\"TEXTURE_2D_ARRAY\"] = 1] = \"TEXTURE_2D_ARRAY\";\n    TextureDimension[TextureDimension[\"TEXTURE_3D\"] = 2] = \"TEXTURE_3D\";\n    TextureDimension[TextureDimension[\"TEXTURE_CUBE_MAP\"] = 3] = \"TEXTURE_CUBE_MAP\";\n})(exports.TextureDimension || (exports.TextureDimension = {}));\nexports.TextureUsage = void 0;\n(function (TextureUsage) {\n    TextureUsage[TextureUsage[\"SAMPLED\"] = 1] = \"SAMPLED\";\n    TextureUsage[TextureUsage[\"RENDER_TARGET\"] = 2] = \"RENDER_TARGET\";\n    TextureUsage[TextureUsage[\"STORAGE\"] = 4] = \"STORAGE\";\n})(exports.TextureUsage || (exports.TextureUsage = {}));\nexports.ChannelWriteMask = void 0;\n(function (ChannelWriteMask) {\n    ChannelWriteMask[ChannelWriteMask[\"NONE\"] = 0] = \"NONE\";\n    ChannelWriteMask[ChannelWriteMask[\"RED\"] = 1] = \"RED\";\n    ChannelWriteMask[ChannelWriteMask[\"GREEN\"] = 2] = \"GREEN\";\n    ChannelWriteMask[ChannelWriteMask[\"BLUE\"] = 4] = \"BLUE\";\n    ChannelWriteMask[ChannelWriteMask[\"ALPHA\"] = 8] = \"ALPHA\";\n    ChannelWriteMask[ChannelWriteMask[\"RGB\"] = 7] = \"RGB\";\n    ChannelWriteMask[ChannelWriteMask[\"ALL\"] = 15] = \"ALL\";\n})(exports.ChannelWriteMask || (exports.ChannelWriteMask = {}));\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpustenciloperation\n */\nexports.StencilOp = void 0;\n(function (StencilOp) {\n    StencilOp[StencilOp[\"KEEP\"] = 7680] = \"KEEP\";\n    StencilOp[StencilOp[\"ZERO\"] = 0] = \"ZERO\";\n    StencilOp[StencilOp[\"REPLACE\"] = 7681] = \"REPLACE\";\n    StencilOp[StencilOp[\"INVERT\"] = 5386] = \"INVERT\";\n    StencilOp[StencilOp[\"INCREMENT_CLAMP\"] = 7682] = \"INCREMENT_CLAMP\";\n    StencilOp[StencilOp[\"DECREMENT_CLAMP\"] = 7683] = \"DECREMENT_CLAMP\";\n    StencilOp[StencilOp[\"INCREMENT_WRAP\"] = 34055] = \"INCREMENT_WRAP\";\n    StencilOp[StencilOp[\"DECREMENT_WRAP\"] = 34056] = \"DECREMENT_WRAP\";\n})(exports.StencilOp || (exports.StencilOp = {}));\nfunction makeTextureDescriptor2D(format, width, height, mipLevelCount) {\n    var dimension = exports.TextureDimension.TEXTURE_2D;\n    var depthOrArrayLayers = 1;\n    var usage = exports.TextureUsage.SAMPLED;\n    return {\n        dimension: dimension,\n        format: format,\n        width: width,\n        height: height,\n        depthOrArrayLayers: depthOrArrayLayers,\n        mipLevelCount: mipLevelCount,\n        usage: usage,\n    };\n}\nexports.SamplerFormatKind = void 0;\n(function (SamplerFormatKind) {\n    SamplerFormatKind[SamplerFormatKind[\"Float\"] = 0] = \"Float\";\n    SamplerFormatKind[SamplerFormatKind[\"UnfilterableFloat\"] = 1] = \"UnfilterableFloat\";\n    SamplerFormatKind[SamplerFormatKind[\"Uint\"] = 2] = \"Uint\";\n    SamplerFormatKind[SamplerFormatKind[\"Sint\"] = 3] = \"Sint\";\n    SamplerFormatKind[SamplerFormatKind[\"Depth\"] = 4] = \"Depth\";\n})(exports.SamplerFormatKind || (exports.SamplerFormatKind = {}));\nexports.ViewportOrigin = void 0;\n(function (ViewportOrigin) {\n    ViewportOrigin[ViewportOrigin[\"LOWER_LEFT\"] = 0] = \"LOWER_LEFT\";\n    ViewportOrigin[ViewportOrigin[\"UPPER_LEFT\"] = 1] = \"UPPER_LEFT\";\n})(exports.ViewportOrigin || (exports.ViewportOrigin = {}));\nexports.ClipSpaceNearZ = void 0;\n(function (ClipSpaceNearZ) {\n    ClipSpaceNearZ[ClipSpaceNearZ[\"NEGATIVE_ONE\"] = 0] = \"NEGATIVE_ONE\";\n    ClipSpaceNearZ[ClipSpaceNearZ[\"ZERO\"] = 1] = \"ZERO\";\n})(exports.ClipSpaceNearZ || (exports.ClipSpaceNearZ = {}));\nexports.QueryPoolType = void 0;\n(function (QueryPoolType) {\n    QueryPoolType[QueryPoolType[\"OcclusionConservative\"] = 0] = \"OcclusionConservative\";\n})(exports.QueryPoolType || (exports.QueryPoolType = {}));\n\nexports.FormatTypeFlags = void 0;\n(function (FormatTypeFlags) {\n    FormatTypeFlags[FormatTypeFlags[\"U8\"] = 1] = \"U8\";\n    FormatTypeFlags[FormatTypeFlags[\"U16\"] = 2] = \"U16\";\n    FormatTypeFlags[FormatTypeFlags[\"U32\"] = 3] = \"U32\";\n    FormatTypeFlags[FormatTypeFlags[\"S8\"] = 4] = \"S8\";\n    FormatTypeFlags[FormatTypeFlags[\"S16\"] = 5] = \"S16\";\n    FormatTypeFlags[FormatTypeFlags[\"S32\"] = 6] = \"S32\";\n    FormatTypeFlags[FormatTypeFlags[\"F16\"] = 7] = \"F16\";\n    FormatTypeFlags[FormatTypeFlags[\"F32\"] = 8] = \"F32\";\n    // Compressed texture formats.\n    FormatTypeFlags[FormatTypeFlags[\"BC1\"] = 65] = \"BC1\";\n    FormatTypeFlags[FormatTypeFlags[\"BC2\"] = 66] = \"BC2\";\n    FormatTypeFlags[FormatTypeFlags[\"BC3\"] = 67] = \"BC3\";\n    FormatTypeFlags[FormatTypeFlags[\"BC4_UNORM\"] = 68] = \"BC4_UNORM\";\n    FormatTypeFlags[FormatTypeFlags[\"BC4_SNORM\"] = 69] = \"BC4_SNORM\";\n    FormatTypeFlags[FormatTypeFlags[\"BC5_UNORM\"] = 70] = \"BC5_UNORM\";\n    FormatTypeFlags[FormatTypeFlags[\"BC5_SNORM\"] = 71] = \"BC5_SNORM\";\n    // Special-case packed texture formats.\n    FormatTypeFlags[FormatTypeFlags[\"U16_PACKED_5551\"] = 97] = \"U16_PACKED_5551\";\n    FormatTypeFlags[FormatTypeFlags[\"U16_PACKED_565\"] = 98] = \"U16_PACKED_565\";\n    // Depth/stencil texture formats.\n    FormatTypeFlags[FormatTypeFlags[\"D24\"] = 129] = \"D24\";\n    FormatTypeFlags[FormatTypeFlags[\"D32F\"] = 130] = \"D32F\";\n    FormatTypeFlags[FormatTypeFlags[\"D24S8\"] = 131] = \"D24S8\";\n    FormatTypeFlags[FormatTypeFlags[\"D32FS8\"] = 132] = \"D32FS8\";\n})(exports.FormatTypeFlags || (exports.FormatTypeFlags = {}));\nexports.FormatCompFlags = void 0;\n(function (FormatCompFlags) {\n    FormatCompFlags[FormatCompFlags[\"R\"] = 1] = \"R\";\n    FormatCompFlags[FormatCompFlags[\"RG\"] = 2] = \"RG\";\n    FormatCompFlags[FormatCompFlags[\"RGB\"] = 3] = \"RGB\";\n    FormatCompFlags[FormatCompFlags[\"RGBA\"] = 4] = \"RGBA\";\n    FormatCompFlags[FormatCompFlags[\"A\"] = 5] = \"A\";\n})(exports.FormatCompFlags || (exports.FormatCompFlags = {}));\nfunction getFormatCompFlagsComponentCount(n) {\n    // The number of components is the flag value. Easy.\n    return n;\n}\nexports.FormatFlags = void 0;\n(function (FormatFlags) {\n    FormatFlags[FormatFlags[\"None\"] = 0] = \"None\";\n    FormatFlags[FormatFlags[\"Normalized\"] = 1] = \"Normalized\";\n    FormatFlags[FormatFlags[\"sRGB\"] = 2] = \"sRGB\";\n    FormatFlags[FormatFlags[\"Depth\"] = 4] = \"Depth\";\n    FormatFlags[FormatFlags[\"Stencil\"] = 8] = \"Stencil\";\n    FormatFlags[FormatFlags[\"RenderTarget\"] = 16] = \"RenderTarget\";\n    FormatFlags[FormatFlags[\"Luminance\"] = 32] = \"Luminance\";\n})(exports.FormatFlags || (exports.FormatFlags = {}));\nfunction makeFormat(type, comp, flags) {\n    return (type << 16) | (comp << 8) | flags;\n}\nexports.Format = void 0;\n(function (Format) {\n    Format[Format[\"ALPHA\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.A, exports.FormatFlags.None)] = \"ALPHA\";\n    Format[Format[\"U8_LUMINANCE\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.A, exports.FormatFlags.Luminance)] = \"U8_LUMINANCE\";\n    Format[Format[\"F16_LUMINANCE\"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.A, exports.FormatFlags.Luminance)] = \"F16_LUMINANCE\";\n    Format[Format[\"F32_LUMINANCE\"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.A, exports.FormatFlags.Luminance)] = \"F32_LUMINANCE\";\n    Format[Format[\"F16_R\"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"F16_R\";\n    Format[Format[\"F16_RG\"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"F16_RG\";\n    Format[Format[\"F16_RGB\"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = \"F16_RGB\";\n    Format[Format[\"F16_RGBA\"] = makeFormat(exports.FormatTypeFlags.F16, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"F16_RGBA\";\n    Format[Format[\"F32_R\"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"F32_R\";\n    Format[Format[\"F32_RG\"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"F32_RG\";\n    Format[Format[\"F32_RGB\"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = \"F32_RGB\";\n    Format[Format[\"F32_RGBA\"] = makeFormat(exports.FormatTypeFlags.F32, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"F32_RGBA\";\n    Format[Format[\"U8_R\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"U8_R\";\n    Format[Format[\"U8_R_NORM\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = \"U8_R_NORM\";\n    Format[Format[\"U8_RG\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"U8_RG\";\n    Format[Format[\"U8_RG_NORM\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = \"U8_RG_NORM\";\n    Format[Format[\"U8_RGB\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = \"U8_RGB\";\n    Format[Format[\"U8_RGB_NORM\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = \"U8_RGB_NORM\";\n    Format[Format[\"U8_RGB_SRGB\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.sRGB | exports.FormatFlags.Normalized)] = \"U8_RGB_SRGB\";\n    Format[Format[\"U8_RGBA\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"U8_RGBA\";\n    Format[Format[\"U8_RGBA_NORM\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"U8_RGBA_NORM\";\n    Format[Format[\"U8_RGBA_SRGB\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.sRGB | exports.FormatFlags.Normalized)] = \"U8_RGBA_SRGB\";\n    Format[Format[\"U16_R\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"U16_R\";\n    Format[Format[\"U16_R_NORM\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = \"U16_R_NORM\";\n    Format[Format[\"U16_RG_NORM\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = \"U16_RG_NORM\";\n    Format[Format[\"U16_RGBA_NORM\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"U16_RGBA_NORM\";\n    Format[Format[\"U16_RGBA\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"U16_RGBA\";\n    Format[Format[\"U16_RGB\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = \"U16_RGB\";\n    Format[Format[\"U16_RG\"] = makeFormat(exports.FormatTypeFlags.U16, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"U16_RG\";\n    Format[Format[\"U32_R\"] = makeFormat(exports.FormatTypeFlags.U32, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"U32_R\";\n    Format[Format[\"U32_RG\"] = makeFormat(exports.FormatTypeFlags.U32, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"U32_RG\";\n    Format[Format[\"U32_RGB\"] = makeFormat(exports.FormatTypeFlags.U32, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = \"U32_RGB\";\n    Format[Format[\"U32_RGBA\"] = makeFormat(exports.FormatTypeFlags.U32, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"U32_RGBA\";\n    Format[Format[\"S8_R\"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"S8_R\";\n    Format[Format[\"S8_R_NORM\"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = \"S8_R_NORM\";\n    Format[Format[\"S8_RG_NORM\"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = \"S8_RG_NORM\";\n    Format[Format[\"S8_RGB_NORM\"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = \"S8_RGB_NORM\";\n    Format[Format[\"S8_RGBA_NORM\"] = makeFormat(exports.FormatTypeFlags.S8, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"S8_RGBA_NORM\";\n    Format[Format[\"S16_R\"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"S16_R\";\n    Format[Format[\"S16_RG\"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"S16_RG\";\n    Format[Format[\"S16_RG_NORM\"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = \"S16_RG_NORM\";\n    Format[Format[\"S16_RGB_NORM\"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = \"S16_RGB_NORM\";\n    Format[Format[\"S16_RGBA\"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"S16_RGBA\";\n    Format[Format[\"S16_RGBA_NORM\"] = makeFormat(exports.FormatTypeFlags.S16, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"S16_RGBA_NORM\";\n    Format[Format[\"S32_R\"] = makeFormat(exports.FormatTypeFlags.S32, exports.FormatCompFlags.R, exports.FormatFlags.None)] = \"S32_R\";\n    Format[Format[\"S32_RG\"] = makeFormat(exports.FormatTypeFlags.S32, exports.FormatCompFlags.RG, exports.FormatFlags.None)] = \"S32_RG\";\n    Format[Format[\"S32_RGB\"] = makeFormat(exports.FormatTypeFlags.S32, exports.FormatCompFlags.RGB, exports.FormatFlags.None)] = \"S32_RGB\";\n    Format[Format[\"S32_RGBA\"] = makeFormat(exports.FormatTypeFlags.S32, exports.FormatCompFlags.RGBA, exports.FormatFlags.None)] = \"S32_RGBA\";\n    // Packed texture formats.\n    Format[Format[\"U16_RGBA_5551\"] = makeFormat(exports.FormatTypeFlags.U16_PACKED_5551, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"U16_RGBA_5551\";\n    Format[Format[\"U16_RGB_565\"] = makeFormat(exports.FormatTypeFlags.U16_PACKED_565, exports.FormatCompFlags.RGB, exports.FormatFlags.Normalized)] = \"U16_RGB_565\";\n    // Compressed\n    Format[Format[\"BC1\"] = makeFormat(exports.FormatTypeFlags.BC1, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"BC1\";\n    Format[Format[\"BC1_SRGB\"] = makeFormat(exports.FormatTypeFlags.BC1, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = \"BC1_SRGB\";\n    Format[Format[\"BC2\"] = makeFormat(exports.FormatTypeFlags.BC2, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"BC2\";\n    Format[Format[\"BC2_SRGB\"] = makeFormat(exports.FormatTypeFlags.BC2, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = \"BC2_SRGB\";\n    Format[Format[\"BC3\"] = makeFormat(exports.FormatTypeFlags.BC3, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized)] = \"BC3\";\n    Format[Format[\"BC3_SRGB\"] = makeFormat(exports.FormatTypeFlags.BC3, exports.FormatCompFlags.RGBA, exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = \"BC3_SRGB\";\n    Format[Format[\"BC4_UNORM\"] = makeFormat(exports.FormatTypeFlags.BC4_UNORM, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = \"BC4_UNORM\";\n    Format[Format[\"BC4_SNORM\"] = makeFormat(exports.FormatTypeFlags.BC4_SNORM, exports.FormatCompFlags.R, exports.FormatFlags.Normalized)] = \"BC4_SNORM\";\n    Format[Format[\"BC5_UNORM\"] = makeFormat(exports.FormatTypeFlags.BC5_UNORM, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = \"BC5_UNORM\";\n    Format[Format[\"BC5_SNORM\"] = makeFormat(exports.FormatTypeFlags.BC5_SNORM, exports.FormatCompFlags.RG, exports.FormatFlags.Normalized)] = \"BC5_SNORM\";\n    // Depth/Stencil\n    Format[Format[\"D24\"] = makeFormat(exports.FormatTypeFlags.D24, exports.FormatCompFlags.R, exports.FormatFlags.Depth)] = \"D24\";\n    Format[Format[\"D24_S8\"] = makeFormat(exports.FormatTypeFlags.D24S8, exports.FormatCompFlags.RG, exports.FormatFlags.Depth | exports.FormatFlags.Stencil)] = \"D24_S8\";\n    Format[Format[\"D32F\"] = makeFormat(exports.FormatTypeFlags.D32F, exports.FormatCompFlags.R, exports.FormatFlags.Depth)] = \"D32F\";\n    Format[Format[\"D32F_S8\"] = makeFormat(exports.FormatTypeFlags.D32FS8, exports.FormatCompFlags.RG, exports.FormatFlags.Depth | exports.FormatFlags.Stencil)] = \"D32F_S8\";\n    // Special RT formats for preferred backend support.\n    Format[Format[\"U8_RGB_RT\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGB, exports.FormatFlags.RenderTarget | exports.FormatFlags.Normalized)] = \"U8_RGB_RT\";\n    Format[Format[\"U8_RGBA_RT\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.RenderTarget | exports.FormatFlags.Normalized)] = \"U8_RGBA_RT\";\n    Format[Format[\"U8_RGBA_RT_SRGB\"] = makeFormat(exports.FormatTypeFlags.U8, exports.FormatCompFlags.RGBA, exports.FormatFlags.RenderTarget | exports.FormatFlags.Normalized | exports.FormatFlags.sRGB)] = \"U8_RGBA_RT_SRGB\";\n})(exports.Format || (exports.Format = {}));\nfunction getFormatCompFlags(fmt) {\n    return (fmt >>> 8) & 0xff;\n}\nfunction getFormatTypeFlags(fmt) {\n    return (fmt >>> 16) & 0xff;\n}\nfunction getFormatFlags(fmt) {\n    return fmt & 0xff;\n}\nfunction getFormatTypeFlagsByteSize(typeFlags) {\n    switch (typeFlags) {\n        case exports.FormatTypeFlags.F32:\n        case exports.FormatTypeFlags.U32:\n        case exports.FormatTypeFlags.S32:\n            return 4;\n        case exports.FormatTypeFlags.U16:\n        case exports.FormatTypeFlags.S16:\n        case exports.FormatTypeFlags.F16:\n            return 2;\n        case exports.FormatTypeFlags.U8:\n        case exports.FormatTypeFlags.S8:\n            return 1;\n        default:\n            throw new Error('whoops');\n    }\n}\n/**\n * Gets the byte size for an individual component.\n * e.g. for F32_RGB, this will return \"4\", since F32 has 4 bytes.\n */\nfunction getFormatCompByteSize(fmt) {\n    return getFormatTypeFlagsByteSize(getFormatTypeFlags(fmt));\n}\nfunction getFormatComponentCount(fmt) {\n    return getFormatCompFlagsComponentCount(getFormatCompFlags(fmt));\n}\nfunction getFormatByteSize(fmt) {\n    var typeByteSize = getFormatTypeFlagsByteSize(getFormatTypeFlags(fmt));\n    var componentCount = getFormatCompFlagsComponentCount(getFormatCompFlags(fmt));\n    return typeByteSize * componentCount;\n}\nfunction setFormatFlags(fmt, flags) {\n    return (fmt & 0xffffff00) | flags;\n}\nfunction setFormatComponentCount(fmt, compFlags) {\n    return (fmt & 0xffff00ff) | (compFlags << 8);\n}\nfunction getFormatSamplerKind(fmt) {\n    var flags = getFormatFlags(fmt);\n    if (flags & exports.FormatFlags.Depth) {\n        return exports.SamplerFormatKind.Depth;\n    }\n    if (flags & exports.FormatFlags.Normalized) {\n        return exports.SamplerFormatKind.Float;\n    }\n    var typeFlags = getFormatTypeFlags(fmt);\n    if (typeFlags === exports.FormatTypeFlags.F16 || typeFlags === exports.FormatTypeFlags.F32) {\n        return exports.SamplerFormatKind.Float;\n    }\n    else if (typeFlags === exports.FormatTypeFlags.U8 ||\n        typeFlags === exports.FormatTypeFlags.U16 ||\n        typeFlags === exports.FormatTypeFlags.U32) {\n        return exports.SamplerFormatKind.Uint;\n    }\n    else if (typeFlags === exports.FormatTypeFlags.S8 ||\n        typeFlags === exports.FormatTypeFlags.S16 ||\n        typeFlags === exports.FormatTypeFlags.S32) {\n        return exports.SamplerFormatKind.Sint;\n    }\n    else {\n        throw new Error('whoops');\n    }\n}\n\nfunction assert(b, message) {\n    if (message === void 0) { message = ''; }\n    if (!b) {\n        // console.error(new Error().stack);\n        throw new Error(\"Assert fail: \".concat(message));\n    }\n}\nfunction assertExists(v) {\n    if (v !== undefined && v !== null)\n        return v;\n    else\n        throw new Error('Missing object');\n}\n\nfunction colorEqual(c0, c1) {\n    return c0.r === c1.r && c0.g === c1.g && c0.b === c1.b && c0.a === c1.a;\n}\nfunction colorCopy(dst, src) {\n    dst.r = src.r;\n    dst.g = src.g;\n    dst.b = src.b;\n    dst.a = src.a;\n}\nfunction colorNewCopy(src) {\n    var r = src.r, g = src.g, b = src.b, a = src.a;\n    return { r: r, g: g, b: b, a: a };\n}\nfunction colorNewFromRGBA(r, g, b, a) {\n    if (a === void 0) { a = 1.0; }\n    return { r: r, g: g, b: b, a: a };\n}\nvar TransparentBlack = colorNewFromRGBA(0, 0, 0, 0);\nvar OpaqueBlack = colorNewFromRGBA(0, 0, 0, 1);\nvar TransparentWhite = colorNewFromRGBA(1, 1, 1, 0);\nvar OpaqueWhite = colorNewFromRGBA(1, 1, 1, 1);\n\n/**\n * @see https://forum.babylonjs.com/t/reverse-depth-buffer-z-buffer/6905/2\n */\nvar IsDepthReversed = true;\nfunction reverseDepthForPerspectiveProjectionMatrix(m, isDepthReversed) {\n    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }\n    if (isDepthReversed) {\n        m[10] = -m[10];\n        m[14] = -m[14];\n    }\n}\nfunction reverseDepthForOrthographicProjectionMatrix(m, isDepthReversed) {\n    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }\n    if (isDepthReversed) {\n        m[10] = -m[10];\n        m[14] = -m[14] + 1;\n    }\n}\nfunction reverseDepthForCompareFunction(compareFunction, isDepthReversed) {\n    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }\n    if (isDepthReversed) {\n        switch (compareFunction) {\n            case exports.CompareFunction.LESS:\n                return exports.CompareFunction.GREATER;\n            case exports.CompareFunction.LEQUAL:\n                return exports.CompareFunction.GEQUAL;\n            case exports.CompareFunction.GEQUAL:\n                return exports.CompareFunction.LEQUAL;\n            case exports.CompareFunction.GREATER:\n                return exports.CompareFunction.LESS;\n            default:\n                return compareFunction;\n        }\n    }\n    else {\n        return compareFunction;\n    }\n}\nfunction reverseDepthForClearValue(n, isDepthReversed) {\n    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }\n    if (isDepthReversed) {\n        return 1.0 - n;\n    }\n    else {\n        return n;\n    }\n}\nfunction reverseDepthForDepthOffset(n, isDepthReversed) {\n    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }\n    if (isDepthReversed) {\n        return -n;\n    }\n    else {\n        return n;\n    }\n}\nfunction compareDepthValues(a, b, op, isDepthReversed) {\n    if (isDepthReversed === void 0) { isDepthReversed = IsDepthReversed; }\n    op = reverseDepthForCompareFunction(op, isDepthReversed);\n    if (op === exports.CompareFunction.LESS)\n        return a < b;\n    else if (op === exports.CompareFunction.LEQUAL)\n        return a <= b;\n    else if (op === exports.CompareFunction.GREATER)\n        return a > b;\n    else if (op === exports.CompareFunction.GEQUAL)\n        return a >= b;\n    else\n        throw new Error('whoops');\n}\n\n// import { reverseDepthForCompareFunction } from './depth';\nfunction isPowerOfTwo(n) {\n    return !!(n && (n & (n - 1)) === 0);\n}\nfunction fallbackUndefined(v, fallback) {\n    return v !== null && v !== undefined ? v : fallback;\n}\nfunction nullify(v) {\n    return v === undefined ? null : v;\n}\nfunction fillArray(L, n, v) {\n    L.length = n;\n    L.fill(v);\n}\nfunction align(n, multiple) {\n    var mask = multiple - 1;\n    return (n + mask) & ~mask;\n}\nfunction alignNonPowerOfTwo(n, multiple) {\n    return (((n + multiple - 1) / multiple) | 0) * multiple;\n}\n// @see https://github.com/d3/d3-array#bisectRight\nfunction bisectRight(L, e, compare) {\n    var lo = 0, hi = L.length;\n    while (lo < hi) {\n        var mid = lo + ((hi - lo) >>> 1);\n        var cmp = compare(e, L[mid]);\n        if (cmp < 0)\n            hi = mid;\n        else\n            lo = mid + 1;\n    }\n    return lo;\n}\nfunction spliceBisectRight(L, e, compare) {\n    var idx = bisectRight(L, e, compare);\n    L.splice(idx, 0, e);\n}\nfunction setBitFlagEnabled(v, mask, enabled) {\n    if (enabled)\n        v |= mask;\n    else\n        v &= ~mask;\n    return v;\n}\nfunction nArray(n, c) {\n    var d = new Array(n);\n    for (var i = 0; i < n; i++)\n        d[i] = c();\n    return d;\n}\nfunction prependLineNo(str, lineStart) {\n    if (lineStart === void 0) { lineStart = 1; }\n    var lines = str.split('\\n');\n    return lines\n        .map(function (s, i) { return \"\".concat(leftPad('' + (lineStart + i), 4, ' '), \"  \").concat(s); })\n        .join('\\n');\n}\nfunction leftPad(S, spaces, ch) {\n    if (ch === void 0) { ch = '0'; }\n    while (S.length < spaces)\n        S = \"\".concat(ch).concat(S);\n    return S;\n}\nfunction range(start, count) {\n    var L = [];\n    for (var i = start; i < start + count; i++)\n        L.push(i);\n    return L;\n}\nfunction copyChannelBlendState(dst, src) {\n    dst.blendDstFactor = src.blendDstFactor;\n    dst.blendSrcFactor = src.blendSrcFactor;\n    dst.blendMode = src.blendMode;\n}\nfunction copyStencilFaceState(dst, src) {\n    if (dst === undefined) {\n        dst = {};\n    }\n    dst.compare = src.compare;\n    dst.depthFailOp = src.depthFailOp;\n    dst.passOp = src.passOp;\n    dst.failOp = src.failOp;\n    dst.mask = src.mask;\n    return dst;\n}\nfunction copyAttachmentState(dst, src) {\n    if (dst === undefined) {\n        dst = {\n            rgbBlendState: {},\n            alphaBlendState: {},\n            channelWriteMask: 0,\n        };\n    }\n    copyChannelBlendState(dst.rgbBlendState, src.rgbBlendState);\n    copyChannelBlendState(dst.alphaBlendState, src.alphaBlendState);\n    dst.channelWriteMask = src.channelWriteMask;\n    return dst;\n}\nfunction copyAttachmentsState(dst, src) {\n    if (dst.length !== src.length)\n        dst.length = src.length;\n    for (var i = 0; i < src.length; i++)\n        dst[i] = copyAttachmentState(dst[i], src[i]);\n}\nfunction setMegaStateFlags(dst, src) {\n    if (src.attachmentsState !== undefined) {\n        copyAttachmentsState(dst.attachmentsState, src.attachmentsState);\n    }\n    if (dst.blendConstant && src.blendConstant) {\n        colorCopy(dst.blendConstant, src.blendConstant);\n    }\n    dst.depthCompare = fallbackUndefined(src.depthCompare, dst.depthCompare);\n    dst.depthWrite = fallbackUndefined(src.depthWrite, dst.depthWrite);\n    dst.stencilWrite = fallbackUndefined(src.stencilWrite, dst.stencilWrite);\n    if (dst.stencilFront && src.stencilFront) {\n        copyStencilFaceState(dst.stencilFront, src.stencilFront);\n    }\n    if (dst.stencilBack && src.stencilBack) {\n        copyStencilFaceState(dst.stencilBack, src.stencilBack);\n    }\n    dst.cullMode = fallbackUndefined(src.cullMode, dst.cullMode);\n    dst.frontFace = fallbackUndefined(src.frontFace, dst.frontFace);\n    dst.polygonOffset = fallbackUndefined(src.polygonOffset, dst.polygonOffset);\n    dst.polygonOffsetFactor = fallbackUndefined(src.polygonOffsetFactor, dst.polygonOffsetFactor);\n    dst.polygonOffsetUnits = fallbackUndefined(src.polygonOffsetUnits, dst.polygonOffsetUnits);\n}\nfunction copyMegaState(src) {\n    var dst = Object.assign({}, src);\n    // Copy fields that need copying.\n    dst.attachmentsState = [];\n    copyAttachmentsState(dst.attachmentsState, src.attachmentsState);\n    dst.blendConstant = dst.blendConstant && colorNewCopy(dst.blendConstant);\n    dst.stencilFront = copyStencilFaceState(undefined, src.stencilFront);\n    dst.stencilBack = copyStencilFaceState(undefined, src.stencilBack);\n    return dst;\n}\nfunction copyAttachmentStateFromSimple(dst, src) {\n    if (src.channelWriteMask !== undefined) {\n        dst.channelWriteMask = src.channelWriteMask;\n    }\n    if (src.rgbBlendMode !== undefined) {\n        dst.rgbBlendState.blendMode = src.rgbBlendMode;\n    }\n    if (src.alphaBlendMode !== undefined) {\n        dst.alphaBlendState.blendMode = src.alphaBlendMode;\n    }\n    if (src.rgbBlendSrcFactor !== undefined) {\n        dst.rgbBlendState.blendSrcFactor = src.rgbBlendSrcFactor;\n    }\n    if (src.alphaBlendSrcFactor !== undefined) {\n        dst.alphaBlendState.blendSrcFactor = src.alphaBlendSrcFactor;\n    }\n    if (src.rgbBlendDstFactor !== undefined) {\n        dst.rgbBlendState.blendDstFactor = src.rgbBlendDstFactor;\n    }\n    if (src.alphaBlendDstFactor !== undefined) {\n        dst.alphaBlendState.blendDstFactor = src.alphaBlendDstFactor;\n    }\n}\nvar defaultBlendState = {\n    blendMode: exports.BlendMode.ADD,\n    blendSrcFactor: exports.BlendFactor.ONE,\n    blendDstFactor: exports.BlendFactor.ZERO,\n};\nvar defaultMegaState = {\n    attachmentsState: [\n        {\n            channelWriteMask: exports.ChannelWriteMask.ALL,\n            rgbBlendState: defaultBlendState,\n            alphaBlendState: defaultBlendState,\n        },\n    ],\n    blendConstant: colorNewCopy(TransparentBlack),\n    depthWrite: true,\n    depthCompare: exports.CompareFunction.LEQUAL,\n    stencilWrite: false,\n    stencilFront: {\n        compare: exports.CompareFunction.ALWAYS,\n        passOp: exports.StencilOp.KEEP,\n        depthFailOp: exports.StencilOp.KEEP,\n        failOp: exports.StencilOp.KEEP,\n    },\n    stencilBack: {\n        compare: exports.CompareFunction.ALWAYS,\n        passOp: exports.StencilOp.KEEP,\n        depthFailOp: exports.StencilOp.KEEP,\n        failOp: exports.StencilOp.KEEP,\n    },\n    cullMode: exports.CullMode.NONE,\n    frontFace: exports.FrontFace.CCW,\n    polygonOffset: false,\n    polygonOffsetFactor: 0,\n    polygonOffsetUnits: 0,\n};\nfunction makeMegaState(other, src) {\n    if (other === void 0) { other = null; }\n    if (src === void 0) { src = defaultMegaState; }\n    var dst = copyMegaState(src);\n    if (other !== null)\n        setMegaStateFlags(dst, other);\n    return dst;\n}\nvar fullscreenMegaState = makeMegaState({ depthCompare: exports.CompareFunction.ALWAYS, depthWrite: false }, defaultMegaState);\nfunction setAttachmentStateSimple(dst, simple) {\n    if (dst.attachmentsState === undefined) {\n        dst.attachmentsState = [];\n        copyAttachmentsState(dst.attachmentsState, defaultMegaState.attachmentsState);\n    }\n    copyAttachmentStateFromSimple(dst.attachmentsState[0], simple);\n    return dst;\n}\nvar defaultBindingLayoutSamplerDescriptor = {\n    texture: null,\n    sampler: null,\n    formatKind: exports.SamplerFormatKind.Float,\n    dimension: exports.TextureDimension.TEXTURE_2D,\n};\n\nfunction arrayEqual(a, b, e) {\n    if (a.length !== b.length)\n        return false;\n    for (var i = 0; i < a.length; i++)\n        if (!e(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction arrayCopy(a, copyFunc) {\n    var b = Array(a.length);\n    for (var i = 0; i < a.length; i++)\n        b[i] = copyFunc(a[i]);\n    return b;\n}\nfunction textureBindingEquals(a, b) {\n    return a.texture === b.texture && a.binding === b.binding;\n}\nfunction bufferBindingEquals(a, b) {\n    return (a.buffer === b.buffer &&\n        a.size === b.size &&\n        a.binding === b.binding &&\n        a.offset === b.offset);\n}\nfunction samplerBindingEquals(a, b) {\n    if (a === null)\n        return b === null;\n    if (b === null)\n        return false;\n    return (a.sampler === b.sampler &&\n        a.texture === b.texture &&\n        a.dimension === b.dimension &&\n        a.formatKind === b.formatKind &&\n        a.comparison === b.comparison);\n}\nfunction bindingsDescriptorEquals(a, b) {\n    a.samplerBindings = a.samplerBindings || [];\n    a.uniformBufferBindings = a.uniformBufferBindings || [];\n    a.storageBufferBindings = a.storageBufferBindings || [];\n    a.storageTextureBindings = a.storageTextureBindings || [];\n    b.samplerBindings = b.samplerBindings || [];\n    b.uniformBufferBindings = b.uniformBufferBindings || [];\n    b.storageBufferBindings = b.storageBufferBindings || [];\n    b.storageTextureBindings = b.storageTextureBindings || [];\n    if (a.samplerBindings.length !== b.samplerBindings.length)\n        return false;\n    if (!arrayEqual(a.samplerBindings, b.samplerBindings, samplerBindingEquals))\n        return false;\n    if (!arrayEqual(a.uniformBufferBindings, b.uniformBufferBindings, bufferBindingEquals))\n        return false;\n    if (!arrayEqual(a.storageBufferBindings, b.storageBufferBindings, bufferBindingEquals))\n        return false;\n    if (!arrayEqual(a.storageTextureBindings, b.storageTextureBindings, textureBindingEquals))\n        return false;\n    return true;\n}\nfunction channelBlendStateEquals(a, b) {\n    return (a.blendMode == b.blendMode &&\n        a.blendSrcFactor === b.blendSrcFactor &&\n        a.blendDstFactor === b.blendDstFactor);\n}\nfunction attachmentStateEquals(a, b) {\n    if (!channelBlendStateEquals(a.rgbBlendState, b.rgbBlendState))\n        return false;\n    if (!channelBlendStateEquals(a.alphaBlendState, b.alphaBlendState))\n        return false;\n    if (a.channelWriteMask !== b.channelWriteMask)\n        return false;\n    return true;\n}\nfunction stencilFaceStateEquals(a, b) {\n    return (a.compare == b.compare &&\n        a.depthFailOp === b.depthFailOp &&\n        a.failOp === b.failOp &&\n        a.passOp === b.passOp &&\n        a.mask === b.mask);\n}\nfunction megaStateDescriptorEquals(a, b) {\n    if (!arrayEqual(a.attachmentsState, b.attachmentsState, attachmentStateEquals))\n        return false;\n    if (a.blendConstant &&\n        b.blendConstant &&\n        !colorEqual(a.blendConstant, b.blendConstant))\n        return false;\n    if (a.stencilFront &&\n        b.stencilFront &&\n        !stencilFaceStateEquals(a.stencilFront, b.stencilFront))\n        return false;\n    if (a.stencilBack &&\n        b.stencilBack &&\n        !stencilFaceStateEquals(a.stencilBack, b.stencilBack))\n        return false;\n    return (a.depthCompare === b.depthCompare &&\n        a.depthWrite === b.depthWrite &&\n        a.stencilWrite === b.stencilWrite &&\n        a.cullMode === b.cullMode &&\n        a.frontFace === b.frontFace &&\n        a.polygonOffset === b.polygonOffset &&\n        a.polygonOffsetFactor === b.polygonOffsetFactor &&\n        a.polygonOffsetUnits === b.polygonOffsetUnits);\n}\nfunction programEquals(a, b) {\n    return a.id === b.id;\n}\nfunction formatEquals(a, b) {\n    return a === b;\n}\nfunction renderPipelineDescriptorEquals(a, b) {\n    if (a.topology !== b.topology)\n        return false;\n    if (a.inputLayout !== b.inputLayout)\n        return false;\n    if (a.sampleCount !== b.sampleCount)\n        return false;\n    if (a.megaStateDescriptor &&\n        b.megaStateDescriptor &&\n        !megaStateDescriptorEquals(a.megaStateDescriptor, b.megaStateDescriptor))\n        return false;\n    if (!programEquals(a.program, b.program))\n        return false;\n    if (!arrayEqual(a.colorAttachmentFormats, b.colorAttachmentFormats, formatEquals))\n        return false;\n    if (a.depthStencilAttachmentFormat !== b.depthStencilAttachmentFormat)\n        return false;\n    return true;\n}\nfunction vertexAttributeDescriptorEquals(a, b) {\n    return (a.offset === b.offset &&\n        a.shaderLocation === b.shaderLocation &&\n        a.format === b.format &&\n        a.divisor === b.divisor);\n}\nfunction inputLayoutBufferDescriptorEquals(a, b) {\n    if (util.isNil(a))\n        return util.isNil(b);\n    if (util.isNil(b))\n        return false;\n    return (a.arrayStride === b.arrayStride &&\n        a.stepMode === b.stepMode &&\n        arrayEqual(a.attributes, b.attributes, vertexAttributeDescriptorEquals));\n}\nfunction inputLayoutDescriptorEquals(a, b) {\n    if (a.indexBufferFormat !== b.indexBufferFormat)\n        return false;\n    if (!arrayEqual(a.vertexBufferDescriptors, b.vertexBufferDescriptors, inputLayoutBufferDescriptorEquals))\n        return false;\n    if (!programEquals(a.program, b.program))\n        return false;\n    return true;\n}\nfunction samplerDescriptorEquals(a, b) {\n    return (a.addressModeU === b.addressModeU &&\n        a.addressModeV === b.addressModeV &&\n        a.minFilter === b.minFilter &&\n        a.magFilter === b.magFilter &&\n        a.mipmapFilter === b.mipmapFilter &&\n        a.lodMinClamp === b.lodMinClamp &&\n        a.lodMaxClamp === b.lodMaxClamp &&\n        a.maxAnisotropy === b.maxAnisotropy &&\n        a.compareFunction === b.compareFunction);\n}\nfunction samplerBindingCopy(a) {\n    var sampler = a.sampler;\n    var texture = a.texture;\n    var dimension = a.dimension;\n    var formatKind = a.formatKind;\n    var comparison = a.comparison;\n    return { sampler: sampler, texture: texture, dimension: dimension, formatKind: formatKind, comparison: comparison };\n}\nfunction bufferBindingCopy(a) {\n    var buffer = a.buffer;\n    var size = a.size;\n    var binding = a.binding;\n    var offset = a.offset;\n    return { binding: binding, buffer: buffer, offset: offset, size: size };\n}\nfunction textureBindingCopy(a) {\n    var binding = a.binding;\n    var texture = a.texture;\n    return { binding: binding, texture: texture };\n}\nfunction bindingsDescriptorCopy(a) {\n    var samplerBindings = a.samplerBindings && arrayCopy(a.samplerBindings, samplerBindingCopy);\n    var uniformBufferBindings = a.uniformBufferBindings &&\n        arrayCopy(a.uniformBufferBindings, bufferBindingCopy);\n    var storageBufferBindings = a.storageBufferBindings &&\n        arrayCopy(a.storageBufferBindings, bufferBindingCopy);\n    var storageTextureBindings = a.storageTextureBindings &&\n        arrayCopy(a.storageTextureBindings, textureBindingCopy);\n    return {\n        samplerBindings: samplerBindings,\n        uniformBufferBindings: uniformBufferBindings,\n        storageBufferBindings: storageBufferBindings,\n        storageTextureBindings: storageTextureBindings,\n        pipeline: a.pipeline,\n    };\n}\nfunction renderPipelineDescriptorCopy(a) {\n    var inputLayout = a.inputLayout;\n    var program = a.program;\n    var topology = a.topology;\n    var megaStateDescriptor = a.megaStateDescriptor && copyMegaState(a.megaStateDescriptor);\n    var colorAttachmentFormats = a.colorAttachmentFormats.slice();\n    var depthStencilAttachmentFormat = a.depthStencilAttachmentFormat;\n    var sampleCount = a.sampleCount;\n    return {\n        inputLayout: inputLayout,\n        megaStateDescriptor: megaStateDescriptor,\n        program: program,\n        topology: topology,\n        colorAttachmentFormats: colorAttachmentFormats,\n        depthStencilAttachmentFormat: depthStencilAttachmentFormat,\n        sampleCount: sampleCount,\n    };\n}\nfunction vertexAttributeDescriptorCopy(a) {\n    var shaderLocation = a.shaderLocation;\n    var format = a.format;\n    var offset = a.offset;\n    var divisor = a.divisor;\n    return {\n        shaderLocation: shaderLocation,\n        format: format,\n        offset: offset,\n        divisor: divisor,\n    };\n}\nfunction inputLayoutBufferDescriptorCopy(a) {\n    if (!util.isNil(a)) {\n        var arrayStride = a.arrayStride;\n        var stepMode = a.stepMode;\n        var attributes = arrayCopy(a.attributes, vertexAttributeDescriptorCopy);\n        return { arrayStride: arrayStride, stepMode: stepMode, attributes: attributes };\n    }\n    else {\n        return a;\n    }\n}\nfunction inputLayoutDescriptorCopy(a) {\n    var vertexBufferDescriptors = arrayCopy(a.vertexBufferDescriptors, inputLayoutBufferDescriptorCopy);\n    var indexBufferFormat = a.indexBufferFormat;\n    var program = a.program;\n    return {\n        vertexBufferDescriptors: vertexBufferDescriptors,\n        indexBufferFormat: indexBufferFormat,\n        program: program,\n    };\n}\n\nvar _a;\n// if array name then clean the array brackets\nvar UNIFORM_NAME_REGEXP = /([^[]*)(\\[[0-9]+\\])?/;\nfunction parseUniformName(name) {\n    // Shortcut to avoid redundant or bad matches\n    if (name[name.length - 1] !== ']') {\n        return {\n            name: name,\n            length: 1,\n            isArray: false,\n        };\n    }\n    var matches = name.match(UNIFORM_NAME_REGEXP);\n    if (!matches || matches.length < 2) {\n        throw new Error(\"Failed to parse GLSL uniform name \".concat(name));\n    }\n    return {\n        name: matches[1],\n        length: Number(matches[2]) || 1,\n        isArray: Boolean(matches[2]),\n    };\n}\nfunction getSamplerSetter() {\n    var cache = null;\n    return function (gl, location, \n    // eslint-disable-next-line\n    value) {\n        var update = cache !== value;\n        if (update) {\n            gl.uniform1i(location, value);\n            cache = value;\n        }\n        return update;\n    };\n}\nfunction getArraySetter(functionName, toArray, size, uniformSetter) {\n    var cache = null;\n    var cacheLength = null;\n    // eslint-disable-next-line\n    return function (gl, location, value) {\n        var arrayValue = toArray(value, size);\n        var length = arrayValue.length;\n        var update = false;\n        if (cache === null) {\n            cache = new Float32Array(length);\n            cacheLength = length;\n            update = true;\n        }\n        else {\n            assert(cacheLength === length, 'Uniform length cannot change.');\n            for (var i = 0; i < length; ++i) {\n                if (arrayValue[i] !== cache[i]) {\n                    update = true;\n                    break;\n                }\n            }\n        }\n        if (update) {\n            uniformSetter(gl, functionName, location, arrayValue);\n            cache.set(arrayValue);\n        }\n        return update;\n    };\n}\nfunction setVectorUniform(gl, functionName, location, \n// eslint-disable-next-line\nvalue) {\n    gl[functionName](location, value);\n}\nfunction setMatrixUniform(gl, functionName, location, \n// eslint-disable-next-line\nvalue) {\n    gl[functionName](location, false, value);\n}\nvar FLOAT_ARRAY = {};\nvar INT_ARRAY = {};\nvar UINT_ARRAY = {};\nvar array1 = [0];\nfunction toTypedArray(value, uniformLength, Type, \n// eslint-disable-next-line\ncache) {\n    // convert boolean uniforms to Number\n    if (uniformLength === 1 && typeof value === 'boolean') {\n        value = value ? 1 : 0;\n    }\n    if (Number.isFinite(value)) {\n        array1[0] = value;\n        value = array1;\n    }\n    var length = value.length;\n    if (value instanceof Type) {\n        return value;\n    }\n    var result = cache[length];\n    if (!result) {\n        result = new Type(length);\n        cache[length] = result;\n    }\n    for (var i = 0; i < length; i++) {\n        result[i] = value[i];\n    }\n    return result;\n}\nfunction toFloatArray(value, uniformLength) {\n    return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);\n}\nfunction toIntArray(value, uniformLength) {\n    return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);\n}\nfunction toUIntArray(value, uniformLength) {\n    return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);\n}\nvar UNIFORM_SETTERS = (_a = {},\n    // WEBGL1\n    _a[exports.GL.FLOAT] = getArraySetter.bind(null, 'uniform1fv', toFloatArray, 1, setVectorUniform),\n    _a[exports.GL.FLOAT_VEC2] = getArraySetter.bind(null, 'uniform2fv', toFloatArray, 2, setVectorUniform),\n    _a[exports.GL.FLOAT_VEC3] = getArraySetter.bind(null, 'uniform3fv', toFloatArray, 3, setVectorUniform),\n    _a[exports.GL.FLOAT_VEC4] = getArraySetter.bind(null, 'uniform4fv', toFloatArray, 4, setVectorUniform),\n    _a[exports.GL.INT] = getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),\n    _a[exports.GL.INT_VEC2] = getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),\n    _a[exports.GL.INT_VEC3] = getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),\n    _a[exports.GL.INT_VEC4] = getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),\n    _a[exports.GL.BOOL] = getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),\n    _a[exports.GL.BOOL_VEC2] = getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),\n    _a[exports.GL.BOOL_VEC3] = getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),\n    _a[exports.GL.BOOL_VEC4] = getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),\n    // uniformMatrix(false): don't transpose the matrix\n    _a[exports.GL.FLOAT_MAT2] = getArraySetter.bind(null, 'uniformMatrix2fv', toFloatArray, 4, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT3] = getArraySetter.bind(null, 'uniformMatrix3fv', toFloatArray, 9, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT4] = getArraySetter.bind(null, 'uniformMatrix4fv', toFloatArray, 16, setMatrixUniform),\n    // WEBGL2 - unsigned integers, irregular matrices, additional texture samplers\n    _a[exports.GL.UNSIGNED_INT] = getArraySetter.bind(null, 'uniform1uiv', toUIntArray, 1, setVectorUniform),\n    _a[exports.GL.UNSIGNED_INT_VEC2] = getArraySetter.bind(null, 'uniform2uiv', toUIntArray, 2, setVectorUniform),\n    _a[exports.GL.UNSIGNED_INT_VEC3] = getArraySetter.bind(null, 'uniform3uiv', toUIntArray, 3, setVectorUniform),\n    _a[exports.GL.UNSIGNED_INT_VEC4] = getArraySetter.bind(null, 'uniform4uiv', toUIntArray, 4, setVectorUniform),\n    // uniformMatrix(false): don't transpose the matrix\n    _a[exports.GL.FLOAT_MAT2x3] = getArraySetter.bind(null, 'uniformMatrix2x3fv', toFloatArray, 6, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT2x4] = getArraySetter.bind(null, 'uniformMatrix2x4fv', toFloatArray, 8, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT3x2] = getArraySetter.bind(null, 'uniformMatrix3x2fv', toFloatArray, 6, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT3x4] = getArraySetter.bind(null, 'uniformMatrix3x4fv', toFloatArray, 12, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT4x2] = getArraySetter.bind(null, 'uniformMatrix4x2fv', toFloatArray, 8, setMatrixUniform),\n    _a[exports.GL.FLOAT_MAT4x3] = getArraySetter.bind(null, 'uniformMatrix4x3fv', toFloatArray, 12, setMatrixUniform),\n    _a[exports.GL.SAMPLER_2D] = getSamplerSetter,\n    _a[exports.GL.SAMPLER_CUBE] = getSamplerSetter,\n    _a[exports.GL.SAMPLER_3D] = getSamplerSetter,\n    _a[exports.GL.SAMPLER_2D_SHADOW] = getSamplerSetter,\n    _a[exports.GL.SAMPLER_2D_ARRAY] = getSamplerSetter,\n    _a[exports.GL.SAMPLER_2D_ARRAY_SHADOW] = getSamplerSetter,\n    _a[exports.GL.SAMPLER_CUBE_SHADOW] = getSamplerSetter,\n    _a[exports.GL.INT_SAMPLER_2D] = getSamplerSetter,\n    _a[exports.GL.INT_SAMPLER_3D] = getSamplerSetter,\n    _a[exports.GL.INT_SAMPLER_CUBE] = getSamplerSetter,\n    _a[exports.GL.INT_SAMPLER_2D_ARRAY] = getSamplerSetter,\n    _a[exports.GL.UNSIGNED_INT_SAMPLER_2D] = getSamplerSetter,\n    _a[exports.GL.UNSIGNED_INT_SAMPLER_3D] = getSamplerSetter,\n    _a[exports.GL.UNSIGNED_INT_SAMPLER_CUBE] = getSamplerSetter,\n    _a[exports.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = getSamplerSetter,\n    _a);\nfunction getUniformSetter(gl, location, info) {\n    var setter = UNIFORM_SETTERS[info.type];\n    if (!setter) {\n        throw new Error(\"Unknown GLSL uniform type \".concat(info.type));\n    }\n    return setter().bind(null, gl, location);\n}\n\nvar dtypes = {\n    '[object Int8Array]': 5120,\n    '[object Int16Array]': 5122,\n    '[object Int32Array]': 5124,\n    '[object Uint8Array]': 5121,\n    '[object Uint8ClampedArray]': 5121,\n    '[object Uint16Array]': 5123,\n    '[object Uint32Array]': 5125,\n    '[object Float32Array]': 5126,\n    '[object Float64Array]': 5121,\n    '[object ArrayBuffer]': 5121,\n};\n// eslint-disable-next-line\nfunction isTypedArray(x) {\n    return Object.prototype.toString.call(x) in dtypes;\n}\n\n// const ES100_REPLACEMENTS: [RegExp, string][] = [\n//   // In GLSL 1.00 ES these functions are provided by an extension\n//   [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('],\n//   // Overloads in GLSL 3.00 map to individual functions. Note that we cannot\n//   // differentiate 2D,2DProj,Cube without type analysis so we choose the most common variant.\n//   [/\\btexture\\(/g, 'texture2D('],\n//   [/\\btextureLod\\(/g, 'texture2DLodEXT('],\n// ];\nfunction defineStr(k, v) {\n    return \"#define \".concat(k, \" \").concat(v);\n}\nfunction getDefines(shader) {\n    var defines = {};\n    shader.replace(/^\\s*#define\\s*(\\S*)\\s*(\\S*)\\s*$/gm, function (_, name, value) {\n        var v = Number(value);\n        defines[name] = isNaN(v) ? value : v;\n        return '';\n    });\n    return defines;\n}\nfunction getAttributeLocations(vert, defines) {\n    var locations = [];\n    vert.replace(/^\\s*layout\\(location\\s*=\\s*(\\S*)\\)\\s*in\\s+\\S+\\s*(.*);$/gm, function (_, location, name) {\n        var l = Number(location);\n        locations.push({ location: isNaN(l) ? defines[location] : l, name: name });\n        return '';\n    });\n    return locations;\n}\nfunction getUniforms(vert) {\n    var uniformNames = [];\n    var structs = [];\n    vert.replace(/\\s*struct\\s*(.*)\\s*{((?:\\s*.*\\s*)*?)};/g, function (_, type, uniformStr) {\n        var uniforms = [];\n        uniformStr\n            .trim()\n            .replace('\\r\\n', '\\n')\n            .split('\\n')\n            .forEach(function (line) {\n            var _a = tslib.__read(line.trim().split(/\\s+/), 2), type = _a[0], name = _a[1];\n            uniforms.push({\n                type: type.trim(),\n                name: name.replace(';', '').trim(),\n            });\n        });\n        structs.push({\n            type: type.trim(),\n            uniforms: uniforms,\n        });\n        return '';\n    });\n    vert.replace(/\\s*uniform(?:\\s+)(?:\\w+)(?:\\s?){([^]*?)};?/g, function (_, uniforms) {\n        uniforms\n            .trim()\n            .replace('\\r\\n', '\\n')\n            .split('\\n')\n            .forEach(function (line) {\n            var result = line.trim().split(' ');\n            var type = result[0] || '';\n            var name = result[1] || '';\n            // DirectionalLight directionalLights[  NUM_DIR_LIGHTS ];\n            var isArray = name.indexOf('[') > -1;\n            name = name.replace(';', '').replace('[', '').trim();\n            // ignore conditional comments\n            if (type.startsWith('#')) {\n                return;\n            }\n            // account for structs\n            if (type) {\n                var struct = structs.find(function (struct) { return type === struct.type; });\n                if (struct) {\n                    if (isArray) {\n                        var _loop_1 = function (i) {\n                            struct.uniforms.forEach(function (uniform) {\n                                uniformNames.push(\"\".concat(name, \"[\").concat(i, \"].\").concat(uniform.name));\n                            });\n                        };\n                        for (var i = 0; i < 5; i++) {\n                            _loop_1(i);\n                        }\n                    }\n                    else {\n                        struct.uniforms.forEach(function (uniform) {\n                            uniformNames.push(\"\".concat(name, \".\").concat(uniform.name));\n                        });\n                    }\n                }\n            }\n            if (name) {\n                uniformNames.push(name);\n            }\n        });\n        return '';\n    });\n    return uniformNames;\n}\nfunction parseBinding(layout) {\n    if (layout === undefined)\n        return null;\n    var g = /binding\\s*=\\s*(\\d+)/.exec(layout);\n    if (g !== null) {\n        var bindingNum = parseInt(g[1], 10);\n        if (!Number.isNaN(bindingNum))\n            return bindingNum;\n    }\n    return null;\n}\nfunction getSeparateSamplerTypes(combinedSamplerType) {\n    var samplerType = '';\n    var textureType = combinedSamplerType;\n    // if (combinedSamplerType.endsWith(`Shadow`)) {\n    //   textureType = textureType.slice(0, -6);\n    //   samplerType = `Shadow`;\n    // }\n    return [textureType, samplerType];\n}\nfunction preprocessShader_GLSL(vendorInfo, type, source, defines, usePrecision) {\n    var _a;\n    if (defines === void 0) { defines = null; }\n    if (usePrecision === void 0) { usePrecision = true; }\n    var isGLSL100 = vendorInfo.glslVersion === '#version 100';\n    var useMRT = type === 'frag' &&\n        ((_a = source.match(/^\\s*layout\\(location\\s*=\\s*\\d*\\)\\s*out\\s+vec4\\s*(.*);$/gm)) === null || _a === void 0 ? void 0 : _a.length) > 1;\n    var lines = source\n        .replace('\\r\\n', '\\n')\n        .split('\\n')\n        .map(function (n) {\n        // Remove comments.\n        return n.replace(/[/][/].*$/, '');\n    })\n        .filter(function (n) {\n        // Filter whitespace.\n        var isEmpty = !n || /^\\s+$/.test(n);\n        return !isEmpty;\n    });\n    // #define KEY VAR\n    var definesString = '';\n    if (defines !== null)\n        definesString = Object.keys(defines)\n            .map(function (key) { return defineStr(key, defines[key]); })\n            .join('\\n');\n    var precision = lines.find(function (line) { return line.startsWith('precision'); }) ||\n        'precision mediump float;';\n    var rest = usePrecision\n        ? lines.filter(function (line) { return !line.startsWith('precision'); }).join('\\n')\n        : lines.join('\\n');\n    var extraDefines = '';\n    if (vendorInfo.viewportOrigin === exports.ViewportOrigin.UPPER_LEFT) {\n        extraDefines += \"\".concat(defineStr(\"VIEWPORT_ORIGIN_TL\", \"1\"), \"\\n\");\n    }\n    if (vendorInfo.clipSpaceNearZ === exports.ClipSpaceNearZ.ZERO) {\n        extraDefines += \"\".concat(defineStr(\"CLIPSPACE_NEAR_ZERO\", \"1\"), \"\\n\");\n    }\n    if (vendorInfo.explicitBindingLocations) {\n        var set_1 = 0, implicitBinding_1 = 0, location_1 = 0;\n        rest = rest.replace(/^\\s*(layout\\((.*)\\))?\\s*uniform(.+{)$/gm, function (substr, cap, layout, rest) {\n            var layout2 = layout ? \"\".concat(layout, \", \") : \"\";\n            return \"layout(\".concat(layout2, \"set = \").concat(set_1, \", binding = \").concat(implicitBinding_1++, \") uniform \").concat(rest);\n        });\n        // XXX(jstpierre): WebGPU now binds UBOs and textures in different sets as a porting hack, hrm...\n        set_1++;\n        implicitBinding_1 = 0;\n        assert(vendorInfo.separateSamplerTextures);\n        rest = rest.replace(/^\\s*(layout\\((.*)\\))?\\s*uniform sampler(\\w+) (.*);/gm, function (substr, cap, layout, combinedSamplerType, samplerName) {\n            var binding = parseBinding(layout);\n            if (binding === null)\n                binding = implicitBinding_1++;\n            var _a = tslib.__read(getSeparateSamplerTypes(combinedSamplerType), 2), textureType = _a[0], samplerType = _a[1];\n            return type === 'frag'\n                ? \"\\nlayout(set = \".concat(set_1, \", binding = \").concat(binding * 2 + 0, \") uniform texture\").concat(textureType, \" T_\").concat(samplerName, \";\\nlayout(set = \").concat(set_1, \", binding = \").concat(binding * 2 + 1, \") uniform sampler\").concat(samplerType, \" S_\").concat(samplerName, \";\").trim()\n                : '';\n        });\n        rest = rest.replace(type === 'frag' ? /^\\s*\\b(varying|in)\\b/gm : /^\\s*\\b(varying|out)\\b/gm, function (substr, tok) {\n            return \"layout(location = \".concat(location_1++, \") \").concat(tok);\n        });\n        /**\n         * @see https://github.com/gfx-rs/naga/issues/1994\n         */\n        extraDefines += \"\".concat(defineStr(\"gl_VertexID\", \"gl_VertexIndex\"), \"\\n\");\n        extraDefines += \"\".concat(defineStr(\"gl_InstanceID\", \"gl_InstanceIndex\"), \"\\n\");\n        // Workaround for Naga\n        // https://github.com/gfx-rs/naga/issues/1353\n        precision = precision.replace(/^precision (.*) sampler(.*);$/gm, '');\n    }\n    else {\n        var implicitBinding_2 = 0;\n        rest = rest.replace(/^\\s*(layout\\((.*)\\))?\\s*uniform sampler(\\w+) (.*);/gm, function (substr, cap, layout, combinedSamplerType, samplerName) {\n            var binding = parseBinding(layout);\n            if (binding === null)\n                binding = implicitBinding_2++;\n            return \"uniform sampler\".concat(combinedSamplerType, \" \").concat(samplerName, \"; // BINDING=\").concat(binding);\n        });\n    }\n    rest = rest.replace(/\\bPU_SAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n        return \"SAMPLER_\".concat(combinedSamplerType, \"(P_\").concat(samplerName, \")\");\n    });\n    rest = rest.replace(/\\bPF_SAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n        return \"PP_SAMPLER_\".concat(combinedSamplerType, \"(P_\").concat(samplerName, \")\");\n    });\n    rest = rest.replace(/\\bPU_TEXTURE\\((.*?)\\)/g, function (substr, samplerName) {\n        return \"TEXTURE(P_\".concat(samplerName, \")\");\n    });\n    if (vendorInfo.separateSamplerTextures) {\n        rest = rest.replace(/\\bPD_SAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n            var _a = tslib.__read(getSeparateSamplerTypes(combinedSamplerType), 2), textureType = _a[0], samplerType = _a[1];\n            return \"texture\".concat(textureType, \" T_P_\").concat(samplerName, \", sampler\").concat(samplerType, \" S_P_\").concat(samplerName);\n        });\n        rest = rest.replace(/\\bPP_SAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n            return \"T_\".concat(samplerName, \", S_\").concat(samplerName);\n        });\n        rest = rest.replace(/\\bSAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n            return \"sampler\".concat(combinedSamplerType, \"(T_\").concat(samplerName, \", S_\").concat(samplerName, \")\");\n        });\n        rest = rest.replace(/\\bTEXTURE\\((.*?)\\)/g, function (substr, samplerName) {\n            return \"T_\".concat(samplerName);\n        });\n    }\n    else {\n        var samplerNames_1 = [];\n        rest = rest.replace(/\\bPD_SAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n            return \"sampler\".concat(combinedSamplerType, \" P_\").concat(samplerName);\n        });\n        rest = rest.replace(/\\bPP_SAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n            return samplerName;\n        });\n        rest = rest.replace(/\\bSAMPLER_(\\w+)\\((.*?)\\)/g, function (substr, combinedSamplerType, samplerName) {\n            samplerNames_1.push([samplerName, combinedSamplerType]);\n            return samplerName;\n        });\n        if (isGLSL100) {\n            samplerNames_1.forEach(function (_a) {\n                var _b = tslib.__read(_a, 2), samplerName = _b[0], combinedSamplerType = _b[1];\n                // texture(u_T) -> texture2D(u_T) or textureCube(u_T)\n                rest = rest.replace(new RegExp(\"texture\\\\(\".concat(samplerName), 'g'), function () {\n                    return \"texture\".concat(combinedSamplerType, \"(\").concat(samplerName);\n                });\n            });\n        }\n        rest = rest.replace(/\\bTEXTURE\\((.*?)\\)/g, function (substr, samplerName) {\n            return samplerName;\n        });\n    }\n    // using #define means we can't use `const in/out` in params\n    //   ${isGLSL100 && type === 'vert' ? '#define in attribute\\n#define out varying' : ''}\n    // ${isGLSL100 && type === 'frag' ? '#define in varying' : ''}\n    // headless-gl will throw the following error if we prepend `#version 100`:\n    // #version directive must occur before anything else, except for comments and white space\n    var concat = \"\".concat(isGLSL100 ? '' : vendorInfo.glslVersion, \"\\n\").concat(isGLSL100 && useMRT ? '#extension GL_EXT_draw_buffers : require\\n' : '', \"\\n\").concat(isGLSL100 && type === 'frag'\n        ? '#extension GL_OES_standard_derivatives : enable\\n'\n        : '').concat(usePrecision ? precision : '', \"\\n\").concat(extraDefines ? extraDefines : '').concat(definesString ? definesString + '\\n' : '', \"\\n\").concat(rest, \"\\n\").trim();\n    // out vec4 outputColor; -> layout(location = 0) out vec4 outputColor;\n    if (vendorInfo.explicitBindingLocations && type === 'frag') {\n        concat = concat.replace(/^\\b(out)\\b/g, function (substr, tok) {\n            return \"layout(location = 0) \".concat(tok);\n        });\n    }\n    // GLSL 300 -> 100\n    // @see https://webgl2fundamentals.org/webgl/lessons/webgl1-to-webgl2.html\n    if (isGLSL100) {\n        // in -> varying\n        if (type === 'frag') {\n            concat = concat.replace(/^\\s*in\\s+(\\S+)\\s*(.*);$/gm, function (_, dataType, name) {\n                return \"varying \".concat(dataType, \" \").concat(name, \";\\n\");\n            });\n        }\n        if (type === 'vert') {\n            // out -> varying\n            concat = concat.replace(/^\\s*out\\s+(\\S+)\\s*(.*);$/gm, function (_, dataType, name) {\n                return \"varying \".concat(dataType, \" \").concat(name, \";\\n\");\n            });\n            // in -> attribute\n            concat = concat.replace(\n            // /^\\s*layout\\(location\\s*=\\s*\\d*\\)\\s*in\\s*(.*)\\s*(.*);$/gm,\n            /^\\s*layout\\(location\\s*=\\s*\\S*\\)\\s*in\\s+(\\S+)\\s*(.*);$/gm, function (_, dataType, name) {\n                return \"attribute \".concat(dataType, \" \").concat(name, \";\\n\");\n            });\n        }\n        // interface blocks supported in GLSL ES 3.00 and above only\n        concat = concat.replace(/\\s*uniform\\s*.*\\s*{((?:\\s*.*\\s*)*?)};/g, function (substr, uniforms) {\n            return uniforms.trim().replace(/^.*$/gm, function (uniform) {\n                // eg. #ifdef\n                var trimmed = uniform.trim();\n                if (trimmed.startsWith('#')) {\n                    return trimmed;\n                }\n                return uniform ? \"uniform \".concat(trimmed) : '';\n            });\n        });\n        if (type === 'frag') {\n            if (useMRT) {\n                var gBuffers_1 = [];\n                concat = concat.replace(/^\\s*layout\\(location\\s*=\\s*\\d*\\)\\s*out\\s+vec4\\s*(.*);$/gm, function (_, buffer) {\n                    gBuffers_1.push(buffer);\n                    return \"vec4 \".concat(buffer, \";\\n\");\n                });\n                var lastIndexOfMain = concat.lastIndexOf('}');\n                concat =\n                    concat.substring(0, lastIndexOfMain) +\n                        \"\\n    \".concat(gBuffers_1\n                            .map(function (gBuffer, i) { return \"gl_FragData[\".concat(i, \"] = \").concat(gBuffer, \";\\n    \"); })\n                            .join('\\n')) +\n                        concat.substring(lastIndexOfMain);\n            }\n            else {\n                var glFragColor_1;\n                concat = concat.replace(/^\\s*out\\s+(\\S+)\\s*(.*);$/gm, function (_, dataType, name) {\n                    glFragColor_1 = name;\n                    return \"\".concat(dataType, \" \").concat(name, \";\\n\");\n                });\n                if (glFragColor_1) {\n                    var lastIndexOfMain = concat.lastIndexOf('}');\n                    concat =\n                        concat.substring(0, lastIndexOfMain) +\n                            \"\\n  gl_FragColor = vec4(\".concat(glFragColor_1, \");\\n\") +\n                            concat.substring(lastIndexOfMain);\n                }\n            }\n        }\n        // remove layout(location = 0)\n        concat = concat.replace(/^\\s*layout\\((.*)\\)/gm, '');\n        // replace texture with texture2D\n        // for (const [pattern, replacement] of ES100_REPLACEMENTS) {\n        //   concat = concat.replace(pattern, replacement);\n        // }\n    }\n    return concat;\n}\nfunction preprocessProgram_GLSL(vendorInfo, vert, frag, defines) {\n    if (defines === void 0) { defines = null; }\n    var preprocessedVert = preprocessShader_GLSL(vendorInfo, 'vert', vert, defines);\n    var preprocessedFrag = preprocessShader_GLSL(vendorInfo, 'frag', frag, defines);\n    return { vert: vert, frag: frag, preprocessedVert: preprocessedVert, preprocessedFrag: preprocessedFrag };\n}\n\nvar ResourceBase_GL = /** @class */ (function (_super) {\n    tslib.__extends(ResourceBase_GL, _super);\n    function ResourceBase_GL(_a) {\n        var id = _a.id, device = _a.device;\n        var _this = _super.call(this) || this;\n        _this.id = id;\n        _this.device = device;\n        if (_this.device['resourceCreationTracker'] !== null) {\n            _this.device['resourceCreationTracker'].trackResourceCreated(_this);\n        }\n        return _this;\n    }\n    ResourceBase_GL.prototype.destroy = function () {\n        if (this.device['resourceCreationTracker'] !== null) {\n            this.device['resourceCreationTracker'].trackResourceDestroyed(this);\n        }\n    };\n    return ResourceBase_GL;\n}(EventEmitter));\n\nvar Bindings_GL = /** @class */ (function (_super) {\n    tslib.__extends(Bindings_GL, _super);\n    function Bindings_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Bindings;\n        var uniformBufferBindings = descriptor.uniformBufferBindings, samplerBindings = descriptor.samplerBindings;\n        _this.uniformBufferBindings = uniformBufferBindings || [];\n        _this.samplerBindings = samplerBindings || [];\n        _this.bindingLayouts = _this.createBindingLayouts();\n        return _this;\n    }\n    Bindings_GL.prototype.createBindingLayouts = function () {\n        var firstUniformBuffer = 0;\n        var firstSampler = 0;\n        var bindingLayoutTables = [];\n        // Support only 1 bindGroup for now.\n        var numUniformBuffers = this.uniformBufferBindings.length;\n        var numSamplers = this.samplerBindings.length;\n        bindingLayoutTables.push({\n            firstUniformBuffer: firstUniformBuffer,\n            numUniformBuffers: numUniformBuffers,\n            firstSampler: firstSampler,\n            numSamplers: numSamplers,\n        });\n        firstUniformBuffer += numUniformBuffers;\n        firstSampler += numSamplers;\n        return {\n            numUniformBuffers: firstUniformBuffer,\n            numSamplers: firstSampler,\n            bindingLayoutTables: bindingLayoutTables,\n        };\n    };\n    return Bindings_GL;\n}(ResourceBase_GL));\n\n// @see https://github.com/visgl/luma.gl/blob/30a1039573576d73641de7c1ba222e8992eb526e/modules/gltools/src/utils/webgl-checks.ts#L22\nvar isWebGL2Flag;\nfunction isWebGL2(gl) {\n    if (isWebGL2Flag !== undefined) {\n        return isWebGL2Flag;\n    }\n    if (typeof WebGL2RenderingContext !== 'undefined' &&\n        gl instanceof WebGL2RenderingContext) {\n        isWebGL2Flag = true;\n        return true;\n    }\n    // Look for debug contexts, headless gl etc\n    // @ts-ignore\n    isWebGL2Flag = Boolean(gl && gl._version === 2);\n    return isWebGL2Flag;\n}\nfunction isTextureFormatCompressed(fmt) {\n    var typeFlags = getFormatTypeFlags(fmt);\n    switch (typeFlags) {\n        case exports.FormatTypeFlags.BC1:\n        case exports.FormatTypeFlags.BC2:\n        case exports.FormatTypeFlags.BC3:\n        case exports.FormatTypeFlags.BC4_UNORM:\n        case exports.FormatTypeFlags.BC4_SNORM:\n        case exports.FormatTypeFlags.BC5_UNORM:\n        case exports.FormatTypeFlags.BC5_SNORM:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isFormatSizedInteger(fmt) {\n    var flags = getFormatFlags(fmt);\n    if (flags & exports.FormatFlags.Normalized)\n        return false;\n    var typeFlags = getFormatTypeFlags(fmt);\n    // Check for integer types.\n    if (typeFlags === exports.FormatTypeFlags.S8 ||\n        typeFlags === exports.FormatTypeFlags.S16 ||\n        typeFlags === exports.FormatTypeFlags.S32)\n        return true;\n    if (typeFlags === exports.FormatTypeFlags.U8 ||\n        typeFlags === exports.FormatTypeFlags.U16 ||\n        typeFlags === exports.FormatTypeFlags.U32)\n        return true;\n    return false;\n}\nfunction translateBufferHint(hint) {\n    switch (hint) {\n        case exports.BufferFrequencyHint.STATIC:\n            return exports.GL.STATIC_DRAW;\n        case exports.BufferFrequencyHint.DYNAMIC:\n            return exports.GL.DYNAMIC_DRAW;\n    }\n}\nfunction translateBufferUsageToTarget(usage) {\n    if (usage & exports.BufferUsage.INDEX) {\n        return exports.GL.ELEMENT_ARRAY_BUFFER;\n    }\n    else if (usage & exports.BufferUsage.VERTEX) {\n        return exports.GL.ARRAY_BUFFER;\n    }\n    else if (usage & exports.BufferUsage.UNIFORM) {\n        return exports.GL.UNIFORM_BUFFER;\n    }\n}\nfunction translatePrimitiveTopology(topology) {\n    switch (topology) {\n        case exports.PrimitiveTopology.TRIANGLES:\n            return exports.GL.TRIANGLES;\n        case exports.PrimitiveTopology.POINTS:\n            return exports.GL.POINTS;\n        case exports.PrimitiveTopology.TRIANGLE_STRIP:\n            return exports.GL.TRIANGLE_STRIP;\n        case exports.PrimitiveTopology.LINES:\n            return exports.GL.LINES;\n        case exports.PrimitiveTopology.LINE_STRIP:\n            return exports.GL.LINE_STRIP;\n        default:\n            throw new Error('Unknown primitive topology mode');\n    }\n}\nfunction translateType(flags) {\n    switch (flags) {\n        case exports.FormatTypeFlags.U8:\n            return exports.GL.UNSIGNED_BYTE;\n        case exports.FormatTypeFlags.U16:\n            return exports.GL.UNSIGNED_SHORT;\n        case exports.FormatTypeFlags.U32:\n            return exports.GL.UNSIGNED_INT;\n        case exports.FormatTypeFlags.S8:\n            return exports.GL.BYTE;\n        case exports.FormatTypeFlags.S16:\n            return exports.GL.SHORT;\n        case exports.FormatTypeFlags.S32:\n            return exports.GL.INT;\n        case exports.FormatTypeFlags.F16:\n            return exports.GL.HALF_FLOAT;\n        case exports.FormatTypeFlags.F32:\n            return exports.GL.FLOAT;\n        default:\n            throw new Error('whoops');\n    }\n}\nfunction translateSize(flags) {\n    switch (flags) {\n        case exports.FormatCompFlags.R:\n            return 1;\n        case exports.FormatCompFlags.RG:\n            return 2;\n        case exports.FormatCompFlags.RGB:\n            return 3;\n        case exports.FormatCompFlags.RGBA:\n            return 4;\n        default:\n            return 1;\n    }\n}\nfunction translateVertexFormat$1(fmt) {\n    var typeFlags = getFormatTypeFlags(fmt);\n    var compFlags = getFormatCompFlags(fmt);\n    var flags = getFormatFlags(fmt);\n    var type = translateType(typeFlags);\n    var size = translateSize(compFlags);\n    var normalized = !!(flags & exports.FormatFlags.Normalized);\n    return { size: size, type: type, normalized: normalized };\n}\nfunction translateIndexFormat$1(format) {\n    switch (format) {\n        case exports.Format.U8_R:\n            return exports.GL.UNSIGNED_BYTE;\n        case exports.Format.U16_R:\n            return exports.GL.UNSIGNED_SHORT;\n        case exports.Format.U32_R:\n            return exports.GL.UNSIGNED_INT;\n        default:\n            throw new Error('whoops');\n    }\n}\nfunction translateAddressMode$1(wrapMode) {\n    switch (wrapMode) {\n        case exports.AddressMode.CLAMP_TO_EDGE:\n            return exports.GL.CLAMP_TO_EDGE;\n        case exports.AddressMode.REPEAT:\n            return exports.GL.REPEAT;\n        case exports.AddressMode.MIRRORED_REPEAT:\n            return exports.GL.MIRRORED_REPEAT;\n        default:\n            throw new Error('whoops');\n    }\n}\nfunction translateFilterMode(filter, mipmapFilter) {\n    if (mipmapFilter === exports.MipmapFilterMode.LINEAR &&\n        filter === exports.FilterMode.BILINEAR) {\n        return exports.GL.LINEAR_MIPMAP_LINEAR;\n    }\n    if (mipmapFilter === exports.MipmapFilterMode.LINEAR && filter === exports.FilterMode.POINT) {\n        return exports.GL.NEAREST_MIPMAP_LINEAR;\n    }\n    if (mipmapFilter === exports.MipmapFilterMode.NEAREST &&\n        filter === exports.FilterMode.BILINEAR) {\n        return exports.GL.LINEAR_MIPMAP_NEAREST;\n    }\n    if (mipmapFilter === exports.MipmapFilterMode.NEAREST &&\n        filter === exports.FilterMode.POINT) {\n        return exports.GL.NEAREST_MIPMAP_NEAREST;\n    }\n    if (mipmapFilter === exports.MipmapFilterMode.NO_MIP &&\n        filter === exports.FilterMode.BILINEAR) {\n        return exports.GL.LINEAR;\n    }\n    if (mipmapFilter === exports.MipmapFilterMode.NO_MIP && filter === exports.FilterMode.POINT) {\n        return exports.GL.NEAREST;\n    }\n    throw new Error('Unknown texture filter mode');\n}\nfunction getPlatformBuffer$1(buffer_, byteOffset) {\n    if (byteOffset === void 0) { byteOffset = 0; }\n    var buffer = buffer_;\n    return buffer.gl_buffer_pages[(byteOffset / buffer.pageByteSize) | 0];\n}\nfunction getPlatformTexture(texture_) {\n    var texture = texture_;\n    return texture.gl_texture;\n}\nfunction getPlatformSampler$1(sampler_) {\n    var sampler = sampler_;\n    return sampler.gl_sampler;\n}\n// eslint-disable-next-line\nfunction assignPlatformName(o, name) {\n    o.name = name;\n    o.__SPECTOR_Metadata = { name: name };\n}\nfunction findall(haystack, needle) {\n    var results = [];\n    while (true) {\n        var result = needle.exec(haystack);\n        if (!result)\n            break;\n        results.push(result);\n    }\n    return results;\n}\nfunction isBlendStateNone(blendState) {\n    return (blendState.blendMode == exports.BlendMode.ADD &&\n        blendState.blendSrcFactor == exports.BlendFactor.ONE &&\n        blendState.blendDstFactor === exports.BlendFactor.ZERO);\n}\nfunction translateQueryPoolType$1(type) {\n    switch (type) {\n        case exports.QueryPoolType.OcclusionConservative:\n            return exports.GL.ANY_SAMPLES_PASSED_CONSERVATIVE;\n        default:\n            throw new Error('whoops');\n    }\n}\nfunction translateTextureDimension$1(dimension) {\n    if (dimension === exports.TextureDimension.TEXTURE_2D)\n        return exports.GL.TEXTURE_2D;\n    else if (dimension === exports.TextureDimension.TEXTURE_2D_ARRAY)\n        return exports.GL.TEXTURE_2D_ARRAY;\n    else if (dimension === exports.TextureDimension.TEXTURE_CUBE_MAP)\n        return exports.GL.TEXTURE_CUBE_MAP;\n    else if (dimension === exports.TextureDimension.TEXTURE_3D)\n        return exports.GL.TEXTURE_3D;\n    else\n        throw new Error('whoops');\n}\nfunction isBlockCompressSized(w, h, bw, bh) {\n    if (w % bw !== 0)\n        return false;\n    if (h % bh !== 0)\n        return false;\n    return true;\n}\n\nvar Buffer_GL = /** @class */ (function (_super) {\n    tslib.__extends(Buffer_GL, _super);\n    function Buffer_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Buffer;\n        var viewOrSize = descriptor.viewOrSize, usage = descriptor.usage, _b = descriptor.hint, hint = _b === void 0 ? exports.BufferFrequencyHint.STATIC : _b;\n        var uniformBufferMaxPageByteSize = device.uniformBufferMaxPageByteSize, gl = device.gl;\n        var isUBO = usage & exports.BufferUsage.UNIFORM;\n        if (!isUBO) {\n            if (isWebGL2(gl)) {\n                // Temporarily unbind VAO when creating buffers to not stomp on the VAO configuration.\n                gl.bindVertexArray(null);\n            }\n            else {\n                device.OES_vertex_array_object.bindVertexArrayOES(null);\n            }\n        }\n        // const byteSize = isNumber(viewOrSize)\n        //   ? viewOrSize * 4\n        //   : viewOrSize.byteLength * 4;\n        var byteSize = util.isNumber(viewOrSize)\n            ? align(viewOrSize, 4)\n            : align(viewOrSize.byteLength, 4);\n        _this.gl_buffer_pages = [];\n        var pageByteSize;\n        if (isUBO) {\n            // assert(byteSize % uniformBufferMaxPageByteSize === 0);\n            var byteSizeLeft = byteSize;\n            while (byteSizeLeft > 0) {\n                _this.gl_buffer_pages.push(_this.createBufferPage(Math.min(byteSizeLeft, uniformBufferMaxPageByteSize), usage, hint));\n                byteSizeLeft -= uniformBufferMaxPageByteSize;\n            }\n            pageByteSize = uniformBufferMaxPageByteSize;\n            // TODO: uniform in WebGL1\n        }\n        else {\n            _this.gl_buffer_pages.push(_this.createBufferPage(byteSize, usage, hint));\n            pageByteSize = byteSize;\n        }\n        _this.pageByteSize = pageByteSize;\n        _this.byteSize = byteSize;\n        _this.usage = usage;\n        _this.gl_target = translateBufferUsageToTarget(usage);\n        // init data\n        if (!util.isNumber(viewOrSize)) {\n            _this.setSubData(0, new Uint8Array(viewOrSize.buffer));\n        }\n        if (!isUBO) {\n            if (isWebGL2(gl)) {\n                gl.bindVertexArray(_this.device['currentBoundVAO']);\n            }\n            else {\n                device.OES_vertex_array_object.bindVertexArrayOES(_this.device['currentBoundVAO']);\n            }\n        }\n        return _this;\n    }\n    Buffer_GL.prototype.setSubData = function (dstByteOffset, data, srcByteOffset, byteSize) {\n        if (srcByteOffset === void 0) { srcByteOffset = 0; }\n        if (byteSize === void 0) { byteSize = data.byteLength - srcByteOffset; }\n        var gl = this.device.gl;\n        var \n        // gl_target,\n        // byteSize: dstByteSize,\n        dstPageByteSize = this.pageByteSize;\n        // Account for setSubData being called with a dstByteOffset that is beyond the end of the buffer.\n        // if (isWebGL2(gl) && gl_target === gl.UNIFORM_BUFFER) {\n        //   // Manually check asserts for speed.\n        //   if (!(dstByteOffset % dstPageByteSize === 0))\n        //     throw new Error(\n        //       `Assert fail: (dstByteOffset [${dstByteOffset}] % dstPageByteSize [${dstPageByteSize}]) === 0`,\n        //     );\n        //   if (!(byteSize % dstPageByteSize === 0))\n        //     throw new Error(\n        //       `Assert fail: (byteSize [${byteSize}] % dstPageByteSize [${dstPageByteSize}]) === 0`,\n        //     );\n        // }\n        // if (!(dstByteOffset + byteSize <= dstByteSize)) {\n        //   throw new Error(\n        //     `Assert fail: (dstByteOffset [${dstByteOffset}] + byteSize [${byteSize}]) <= dstByteSize [${dstByteSize}], gl_target ${gl_target}`,\n        //   );\n        //   // exceed, need to recreate\n        // }\n        var virtBufferByteOffsetEnd = dstByteOffset + byteSize;\n        var virtBufferByteOffset = dstByteOffset;\n        var physBufferByteOffset = dstByteOffset % dstPageByteSize;\n        while (virtBufferByteOffset < virtBufferByteOffsetEnd) {\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer#parameters\n            var target = isWebGL2(gl) ? gl.COPY_WRITE_BUFFER : this.gl_target;\n            var buffer = getPlatformBuffer$1(this, virtBufferByteOffset);\n            // @ts-ignore\n            if (buffer.ubo) {\n                return;\n            }\n            gl.bindBuffer(target, buffer);\n            // only WebGL2 support srcOffset & length\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferSubData\n            if (isWebGL2(gl)) {\n                gl.bufferSubData(target, physBufferByteOffset, data, srcByteOffset, Math.min(virtBufferByteOffsetEnd - virtBufferByteOffset, dstPageByteSize));\n            }\n            else {\n                gl.bufferSubData(target, physBufferByteOffset, data);\n            }\n            virtBufferByteOffset += dstPageByteSize;\n            physBufferByteOffset = 0;\n            srcByteOffset += dstPageByteSize;\n            this.device['debugGroupStatisticsBufferUpload']();\n        }\n    };\n    Buffer_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        for (var i = 0; i < this.gl_buffer_pages.length; i++) {\n            // no ubo in WebGL1\n            // @ts-ignore\n            if (!this.gl_buffer_pages[i].ubo) {\n                this.device.gl.deleteBuffer(this.gl_buffer_pages[i]);\n            }\n        }\n        this.gl_buffer_pages = [];\n    };\n    Buffer_GL.prototype.createBufferPage = function (byteSize, usage, hint) {\n        var gl = this.device.gl;\n        var isUBO = usage & exports.BufferUsage.UNIFORM;\n        if (!isWebGL2(gl) && isUBO) {\n            return {\n                ubo: true,\n            };\n        }\n        else {\n            var gl_buffer = this.device.ensureResourceExists(gl.createBuffer());\n            var gl_target = translateBufferUsageToTarget(usage);\n            var gl_hint = translateBufferHint(hint);\n            gl.bindBuffer(gl_target, gl_buffer);\n            gl.bufferData(gl_target, byteSize, gl_hint);\n            return gl_buffer;\n        }\n    };\n    return Buffer_GL;\n}(ResourceBase_GL));\n\nvar InputLayout_GL = /** @class */ (function (_super) {\n    tslib.__extends(InputLayout_GL, _super);\n    function InputLayout_GL(_a) {\n        var e_1, _b, e_2, _c;\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _d;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.InputLayout;\n        var vertexBufferDescriptors = descriptor.vertexBufferDescriptors, indexBufferFormat = descriptor.indexBufferFormat, program = descriptor.program;\n        assert(indexBufferFormat === exports.Format.U16_R ||\n            indexBufferFormat === exports.Format.U32_R ||\n            indexBufferFormat === null);\n        var indexBufferType = indexBufferFormat !== null\n            ? translateIndexFormat$1(indexBufferFormat)\n            : null;\n        var indexBufferCompByteSize = indexBufferFormat !== null\n            ? getFormatCompByteSize(indexBufferFormat)\n            : null;\n        var gl = _this.device.gl;\n        var vao = _this.device.ensureResourceExists(isWebGL2(gl)\n            ? gl.createVertexArray()\n            : device.OES_vertex_array_object.createVertexArrayOES());\n        if (isWebGL2(gl)) {\n            gl.bindVertexArray(vao);\n        }\n        else {\n            device.OES_vertex_array_object.bindVertexArrayOES(vao);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, getPlatformBuffer$1(_this.device['fallbackVertexBuffer']));\n        try {\n            // const vertexBufferFormats = [];\n            for (var _e = tslib.__values(descriptor.vertexBufferDescriptors), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var vertexBufferDescriptor = _f.value;\n                var stepMode = vertexBufferDescriptor.stepMode, attributes = vertexBufferDescriptor.attributes;\n                try {\n                    for (var attributes_1 = (e_2 = void 0, tslib.__values(attributes)), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\n                        var attribute = attributes_1_1.value;\n                        var shaderLocation = attribute.shaderLocation, format = attribute.format, _g = attribute.divisor, divisor = _g === void 0 ? 1 : _g;\n                        // find location by name in WebGL1\n                        var location_1 = isWebGL2(gl)\n                            ? shaderLocation\n                            : (_d = program.attributes[shaderLocation]) === null || _d === void 0 ? void 0 : _d.location;\n                        var vertexFormat = translateVertexFormat$1(format);\n                        // @ts-ignore\n                        attribute.vertexFormat = vertexFormat;\n                        if (!util.isNil(location_1)) {\n                            if (isFormatSizedInteger(format)) {\n                                // See https://groups.google.com/d/msg/angleproject/yQb5DaCzcWg/Ova0E3wcAQAJ for more info.\n                                // console.warn(\"Vertex format uses sized integer types; this will cause a shader recompile on ANGLE platforms\");\n                                // debugger;\n                            }\n                            var size = vertexFormat.size, type = vertexFormat.type, normalized = vertexFormat.normalized;\n                            gl.vertexAttribPointer(location_1, size, type, normalized, 0, 0);\n                            if (stepMode === exports.VertexStepMode.INSTANCE) {\n                                if (isWebGL2(gl)) {\n                                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/vertexAttribDivisor\n                                    gl.vertexAttribDivisor(location_1, divisor);\n                                }\n                                else {\n                                    device.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(location_1, divisor);\n                                }\n                            }\n                            gl.enableVertexAttribArray(location_1);\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (attributes_1_1 && !attributes_1_1.done && (_c = attributes_1.return)) _c.call(attributes_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (isWebGL2(gl)) {\n            gl.bindVertexArray(null);\n        }\n        else {\n            device.OES_vertex_array_object.bindVertexArrayOES(null);\n        }\n        _this.vertexBufferDescriptors = vertexBufferDescriptors;\n        _this.vao = vao;\n        _this.indexBufferFormat = indexBufferFormat;\n        _this.indexBufferType = indexBufferType;\n        _this.indexBufferCompByteSize = indexBufferCompByteSize;\n        _this.program = program;\n        return _this;\n    }\n    InputLayout_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (this.device['currentBoundVAO'] === this.vao) {\n            if (isWebGL2(this.device.gl)) {\n                this.device.gl.bindVertexArray(null);\n                this.device.gl.deleteVertexArray(this.vao);\n            }\n            else {\n                this.device.OES_vertex_array_object.bindVertexArrayOES(null);\n                this.device.OES_vertex_array_object.deleteVertexArrayOES(this.vao);\n            }\n            this.device['currentBoundVAO'] = null;\n        }\n    };\n    return InputLayout_GL;\n}(ResourceBase_GL));\n\nvar Texture_GL = /** @class */ (function (_super) {\n    tslib.__extends(Texture_GL, _super);\n    function Texture_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor, fake = _a.fake;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Texture;\n        // Default values.\n        descriptor = tslib.__assign({ dimension: exports.TextureDimension.TEXTURE_2D, depthOrArrayLayers: 1, mipLevelCount: 1 }, descriptor);\n        var gl = _this.device.gl;\n        var gl_target;\n        var gl_texture;\n        var mipLevelCount = _this.clampmipLevelCount(descriptor);\n        _this.immutable = descriptor.usage === exports.TextureUsage.RENDER_TARGET;\n        _this.pixelStore = descriptor.pixelStore;\n        _this.format = descriptor.format;\n        _this.dimension = descriptor.dimension;\n        _this.formatKind = getFormatSamplerKind(descriptor.format);\n        _this.width = descriptor.width;\n        _this.height = descriptor.height;\n        _this.depthOrArrayLayers = descriptor.depthOrArrayLayers;\n        _this.mipmaps = mipLevelCount >= 1;\n        if (!fake) {\n            gl_texture = _this.device.ensureResourceExists(gl.createTexture());\n            var gl_type = _this.device.translateTextureType(descriptor.format);\n            var internalformat = _this.device.translateTextureInternalFormat(descriptor.format);\n            _this.device.setActiveTexture(gl.TEXTURE0);\n            _this.device['currentTextures'][0] = null;\n            _this.preprocessImage();\n            if (descriptor.dimension === exports.TextureDimension.TEXTURE_2D) {\n                gl_target = exports.GL.TEXTURE_2D;\n                gl.bindTexture(gl_target, gl_texture);\n                if (_this.immutable) {\n                    if (isWebGL2(gl)) {\n                        // texStorage2D will create an immutable texture(fixed size)\n                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texStorage2D\n                        // @see https://github.com/visgl/luma.gl/issues/193\n                        // @see https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_immutable.html\n                        gl.texStorage2D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height);\n                    }\n                    else {\n                        // texImage2D: level must be 0 for DEPTH_COMPONENT format\n                        // const level = internalformat === GL.DEPTH_COMPONENT || this.isNPOT() ? 0 : mipLevelCount;\n                        var level = internalformat === exports.GL.DEPTH_COMPONENT || _this.isNPOT() ? 0 : 0;\n                        if ((_this.format === exports.Format.D32F || _this.format === exports.Format.D24_S8) &&\n                            !isWebGL2(gl) &&\n                            !device.WEBGL_depth_texture) ;\n                        else {\n                            // if (!isWebGL2(gl)) {\n                            //   if (internalformat === GL.RGBA4) {\n                            //     internalformat = GL.RGBA;\n                            //   }\n                            // }\n                            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n                            gl.texImage2D(gl_target, level, internalformat, descriptor.width, descriptor.height, 0, internalformat, gl_type, null);\n                            // @see https://stackoverflow.com/questions/21954036/dartweb-gl-render-warning-texture-bound-to-texture-unit-0-is-not-renderable\n                            // [.WebGL-0x106ad0400]RENDER WARNING: texture bound to texture unit 0 is not renderable. It might be non-power-of-2 or have incompatible texture filtering (maybe)?\n                            if (_this.mipmaps) {\n                                _this.mipmaps = false;\n                                gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_MIN_FILTER, exports.GL.LINEAR);\n                                gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_WRAP_S, exports.GL.CLAMP_TO_EDGE);\n                                gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_WRAP_T, exports.GL.CLAMP_TO_EDGE);\n                            }\n                        }\n                    }\n                }\n                assert(descriptor.depthOrArrayLayers === 1);\n            }\n            else if (descriptor.dimension === exports.TextureDimension.TEXTURE_2D_ARRAY) {\n                gl_target = exports.GL.TEXTURE_2D_ARRAY;\n                gl.bindTexture(gl_target, gl_texture);\n                if (_this.immutable) {\n                    if (isWebGL2(gl)) {\n                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/texStorage3D\n                        gl.texStorage3D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height, descriptor.depthOrArrayLayers);\n                    }\n                }\n            }\n            else if (descriptor.dimension === exports.TextureDimension.TEXTURE_3D) {\n                gl_target = exports.GL.TEXTURE_3D;\n                gl.bindTexture(gl_target, gl_texture);\n                if (_this.immutable) {\n                    if (isWebGL2(gl)) {\n                        gl.texStorage3D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height, descriptor.depthOrArrayLayers);\n                    }\n                }\n            }\n            else if (descriptor.dimension === exports.TextureDimension.TEXTURE_CUBE_MAP) {\n                gl_target = exports.GL.TEXTURE_CUBE_MAP;\n                gl.bindTexture(gl_target, gl_texture);\n                if (_this.immutable) {\n                    if (isWebGL2(gl)) {\n                        gl.texStorage2D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height);\n                    }\n                }\n                assert(descriptor.depthOrArrayLayers === 6);\n            }\n            else {\n                throw new Error('whoops');\n            }\n        }\n        _this.gl_texture = gl_texture;\n        _this.gl_target = gl_target;\n        _this.mipLevelCount = mipLevelCount;\n        return _this;\n    }\n    Texture_GL.prototype.setImageData = function (levelDatas, lod) {\n        if (lod === void 0) { lod = 0; }\n        var gl = this.device.gl;\n        isTextureFormatCompressed(this.format);\n        // @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-2.md#3d-texture\n        var is3D = this.gl_target === exports.GL.TEXTURE_3D ||\n            this.gl_target === exports.GL.TEXTURE_2D_ARRAY;\n        var isCube = this.gl_target === exports.GL.TEXTURE_CUBE_MAP;\n        var isTA = isTypedArray(levelDatas[0]);\n        this.device.setActiveTexture(gl.TEXTURE0);\n        this.device['currentTextures'][0] = null;\n        var data = levelDatas[0];\n        var width;\n        var height;\n        if (isTA) {\n            width = this.width;\n            height = this.height;\n        }\n        else {\n            // FIXME: Property 'width' does not exist on type 'TexImageSource'.\n            // Property 'width' does not exist on type 'VideoFrame'.\n            // @ts-ignore\n            width = data.width;\n            // @ts-ignore\n            height = data.height;\n            // update size\n            this.width = width;\n            this.height = height;\n        }\n        gl.bindTexture(this.gl_target, this.gl_texture);\n        var gl_format = this.device.translateTextureFormat(this.format);\n        // In WebGL 1, this must be the same as internalformat\n        var gl_internal_format = isWebGL2(gl)\n            ? this.device.translateInternalTextureFormat(this.format)\n            : gl_format;\n        var gl_type = this.device.translateTextureType(this.format);\n        this.preprocessImage();\n        for (var z = 0; z < this.depthOrArrayLayers; z++) {\n            var levelData = levelDatas[z];\n            var gl_target = this.gl_target;\n            if (isCube) {\n                gl_target = exports.GL.TEXTURE_CUBE_MAP_POSITIVE_X + (z % 6);\n            }\n            if (this.immutable) {\n                // must use texSubImage2D instead of texImage2D, since texture is immutable\n                // @see https://stackoverflow.com/questions/56123201/unity-plugin-texture-is-immutable?rq=1\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texSubImage2D\n                gl.texSubImage2D(gl_target, lod, 0, 0, width, height, gl_format, gl_type, levelData);\n            }\n            else {\n                if (isWebGL2(gl)) {\n                    if (is3D) {\n                        gl.texImage3D(gl_target, lod, gl_internal_format, width, height, this.depthOrArrayLayers, 0, // border must be 0\n                        gl_format, // TODO: can be different with gl_format\n                        gl_type, levelData);\n                    }\n                    else {\n                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n                        gl.texImage2D(gl_target, lod, gl_internal_format, width, height, 0, // border must be 0\n                        gl_format, // TODO: can be different with gl_format\n                        gl_type, levelData);\n                    }\n                }\n                else {\n                    // WebGL1: upload Array & Image separately\n                    if (isTA) {\n                        gl.texImage2D(gl_target, lod, gl_format, width, height, 0, gl_format, gl_type, levelData);\n                    }\n                    else {\n                        gl.texImage2D(gl_target, lod, gl_format, gl_format, gl_type, levelData);\n                    }\n                }\n            }\n        }\n        if (this.mipmaps) {\n            this.generateMipmap(is3D);\n        }\n    };\n    Texture_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.device.gl.deleteTexture(getPlatformTexture(this));\n    };\n    Texture_GL.prototype.clampmipLevelCount = function (descriptor) {\n        if (descriptor.dimension === exports.TextureDimension.TEXTURE_2D_ARRAY &&\n            descriptor.depthOrArrayLayers > 1) {\n            var typeFlags = getFormatTypeFlags(descriptor.format);\n            if (typeFlags === exports.FormatTypeFlags.BC1) {\n                // Chrome/ANGLE seems to have issues with compressed miplevels of size 1/2, so clamp before they arrive...\n                // https://bugs.chromium.org/p/angleproject/issues/detail?id=4056\n                var w = descriptor.width, h = descriptor.height;\n                for (var i = 0; i < descriptor.mipLevelCount; i++) {\n                    if (w <= 2 || h <= 2)\n                        return i - 1;\n                    w = Math.max((w / 2) | 0, 1);\n                    h = Math.max((h / 2) | 0, 1);\n                }\n            }\n        }\n        return descriptor.mipLevelCount;\n    };\n    Texture_GL.prototype.preprocessImage = function () {\n        var gl = this.device.gl;\n        if (this.pixelStore) {\n            if (this.pixelStore.unpackFlipY) {\n                gl.pixelStorei(exports.GL.UNPACK_FLIP_Y_WEBGL, true);\n            }\n            if (this.pixelStore.packAlignment) {\n                gl.pixelStorei(exports.GL.PACK_ALIGNMENT, this.pixelStore.packAlignment);\n            }\n            if (this.pixelStore.unpackAlignment) {\n                gl.pixelStorei(exports.GL.UNPACK_ALIGNMENT, this.pixelStore.unpackAlignment);\n            }\n        }\n    };\n    Texture_GL.prototype.generateMipmap = function (is3D) {\n        if (is3D === void 0) { is3D = false; }\n        var gl = this.device.gl;\n        if (!isWebGL2(gl) && this.isNPOT()) {\n            return this;\n        }\n        if (this.gl_texture && this.gl_target) {\n            gl.bindTexture(this.gl_target, this.gl_texture);\n            if (is3D) {\n                gl.texParameteri(this.gl_target, exports.GL.TEXTURE_BASE_LEVEL, 0);\n                gl.texParameteri(this.gl_target, exports.GL.TEXTURE_MAX_LEVEL, Math.log2(this.width));\n                gl.texParameteri(this.gl_target, exports.GL.TEXTURE_MIN_FILTER, exports.GL.LINEAR_MIPMAP_LINEAR);\n                gl.texParameteri(this.gl_target, exports.GL.TEXTURE_MAG_FILTER, exports.GL.LINEAR);\n            }\n            else {\n                gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_MIN_FILTER, exports.GL.NEAREST_MIPMAP_LINEAR);\n            }\n            gl.generateMipmap(this.gl_target);\n            gl.bindTexture(this.gl_target, null);\n        }\n        return this;\n    };\n    Texture_GL.prototype.isNPOT = function () {\n        var gl = this.device.gl;\n        if (isWebGL2(gl)) {\n            // NPOT restriction is only for WebGL1\n            return false;\n        }\n        return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n    };\n    return Texture_GL;\n}(ResourceBase_GL));\n\nvar RenderTarget_GL = /** @class */ (function (_super) {\n    tslib.__extends(RenderTarget_GL, _super);\n    function RenderTarget_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.RenderTarget;\n        _this.gl_renderbuffer = null;\n        _this.texture = null;\n        var gl = _this.device.gl;\n        var format = descriptor.format, width = descriptor.width, height = descriptor.height, _b = descriptor.sampleCount, sampleCount = _b === void 0 ? 1 : _b, texture = descriptor.texture;\n        var useRenderbuffer = false;\n        // @see https://blog.tojicode.com/2012/07/using-webgldepthtexture.html\n        if ((format === exports.Format.D32F || format === exports.Format.D24_S8) &&\n            texture &&\n            !isWebGL2(gl) &&\n            !device.WEBGL_depth_texture) {\n            texture.destroy();\n            _this.texture = null;\n            useRenderbuffer = true;\n        }\n        if (!useRenderbuffer && texture) {\n            _this.texture = texture;\n        }\n        else {\n            _this.gl_renderbuffer = _this.device.ensureResourceExists(gl.createRenderbuffer());\n            gl.bindRenderbuffer(gl.RENDERBUFFER, _this.gl_renderbuffer);\n            var gl_format = _this.device.translateTextureInternalFormat(format, true);\n            if (isWebGL2(gl)) {\n                if (sampleCount > 1) {\n                    // @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-2.md#multisampled-renderbuffers\n                    gl.renderbufferStorageMultisample(exports.GL.RENDERBUFFER, sampleCount, gl_format, width, height);\n                }\n                else {\n                    gl.renderbufferStorage(exports.GL.RENDERBUFFER, gl_format, width, height);\n                }\n            }\n            else {\n                // WebGL1 can only use FXAA or other post-processing methods\n                gl.renderbufferStorage(exports.GL.RENDERBUFFER, gl_format, width, height);\n            }\n        }\n        _this.format = format;\n        _this.width = width;\n        _this.height = height;\n        _this.sampleCount = sampleCount;\n        return _this;\n    }\n    RenderTarget_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (this.gl_renderbuffer !== null) {\n            this.device.gl.deleteRenderbuffer(this.gl_renderbuffer);\n        }\n        if (this.texture) {\n            this.texture.destroy();\n        }\n    };\n    return RenderTarget_GL;\n}(ResourceBase_GL));\n\n// const quadVert = `\n// layout(location = 0) in vec2 a_Position;\n// out vec2 v_TexCoord;\n// void main() {\n//   v_TexCoord = 0.5 * (a_Position + 1.0);\n//   gl_Position = vec4(a_Position, 0., 1.);\n//   #ifdef VIEWPORT_ORIGIN_TL\n//     v_TexCoord.y = 1.0 - v_TexCoord.y;\n//   #endif\n// }\n// `;\nvar ProgramCompileState_GL;\n(function (ProgramCompileState_GL) {\n    ProgramCompileState_GL[ProgramCompileState_GL[\"NeedsCompile\"] = 0] = \"NeedsCompile\";\n    ProgramCompileState_GL[ProgramCompileState_GL[\"Compiling\"] = 1] = \"Compiling\";\n    ProgramCompileState_GL[ProgramCompileState_GL[\"NeedsBind\"] = 2] = \"NeedsBind\";\n    ProgramCompileState_GL[ProgramCompileState_GL[\"ReadyToUse\"] = 3] = \"ReadyToUse\";\n})(ProgramCompileState_GL || (ProgramCompileState_GL = {}));\nvar Program_GL = /** @class */ (function (_super) {\n    tslib.__extends(Program_GL, _super);\n    function Program_GL(_a, rawVertexGLSL) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.rawVertexGLSL = rawVertexGLSL;\n        _this.type = exports.ResourceType.Program;\n        // eslint-disable-next-line\n        _this.uniformSetters = {};\n        _this.attributes = [];\n        var gl = _this.device.gl;\n        _this.descriptor = descriptor;\n        _this.gl_program = _this.device.ensureResourceExists(gl.createProgram());\n        _this.gl_shader_vert = null;\n        _this.gl_shader_frag = null;\n        _this.compileState = ProgramCompileState_GL.NeedsCompile;\n        _this.tryCompileProgram();\n        return _this;\n    }\n    Program_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.device.gl.deleteProgram(this.gl_program);\n        this.device.gl.deleteShader(this.gl_shader_vert);\n        this.device.gl.deleteShader(this.gl_shader_frag);\n    };\n    Program_GL.prototype.tryCompileProgram = function () {\n        assert(this.compileState === ProgramCompileState_GL.NeedsCompile);\n        var _a = this.descriptor, vertex = _a.vertex, fragment = _a.fragment;\n        var gl = this.device.gl;\n        // if (this.gl_shader_vert !== null) gl.deleteShader(this.gl_shader_vert);\n        // if (this.gl_shader_frag !== null) gl.deleteShader(this.gl_shader_frag);\n        if ((vertex === null || vertex === void 0 ? void 0 : vertex.glsl) && (fragment === null || fragment === void 0 ? void 0 : fragment.glsl)) {\n            this.gl_shader_vert = this.compileShader(vertex.postprocess ? vertex.postprocess(vertex.glsl) : vertex.glsl, gl.VERTEX_SHADER);\n            this.gl_shader_frag = this.compileShader(fragment.postprocess\n                ? fragment.postprocess(fragment.glsl)\n                : fragment.glsl, gl.FRAGMENT_SHADER);\n            gl.attachShader(this.gl_program, this.gl_shader_vert);\n            gl.attachShader(this.gl_program, this.gl_shader_frag);\n            gl.linkProgram(this.gl_program);\n            this.compileState = ProgramCompileState_GL.Compiling;\n            if (!isWebGL2(gl)) {\n                // extract uniforms\n                this.readUniformLocationsFromLinkedProgram();\n                // extract attributes\n                this.readAttributesFromLinkedProgram();\n            }\n        }\n    };\n    Program_GL.prototype.readAttributesFromLinkedProgram = function () {\n        var _a;\n        var gl = this.device.gl;\n        var count = gl.getProgramParameter(this.gl_program, gl.ACTIVE_ATTRIBUTES);\n        var defines = getDefines(this.descriptor.vertex.glsl);\n        var locations = getAttributeLocations(\n        // Use raw GLSL\n        this.rawVertexGLSL, defines);\n        var _loop_1 = function (index) {\n            var _b = gl.getActiveAttrib(this_1.gl_program, index), name_1 = _b.name, type = _b.type, size = _b.size;\n            var location_1 = gl.getAttribLocation(this_1.gl_program, name_1);\n            var definedLocation = (_a = locations.find(function (l) { return l.name === name_1; })) === null || _a === void 0 ? void 0 : _a.location;\n            // Add only user provided attributes, for built-in attributes like\n            // `gl_InstanceID` locaiton will be < 0\n            if (location_1 >= 0 && !util.isNil(definedLocation)) {\n                this_1.attributes[definedLocation] = {\n                    name: name_1,\n                    location: location_1,\n                    type: type,\n                    size: size,\n                };\n            }\n        };\n        var this_1 = this;\n        for (var index = 0; index < count; index++) {\n            _loop_1(index);\n        }\n    };\n    Program_GL.prototype.readUniformLocationsFromLinkedProgram = function () {\n        var gl = this.device.gl;\n        var numUniforms = gl.getProgramParameter(this.gl_program, gl.ACTIVE_UNIFORMS);\n        for (var i = 0; i < numUniforms; i++) {\n            var info = gl.getActiveUniform(this.gl_program, i);\n            var name_2 = parseUniformName(info.name).name;\n            var location_2 = gl.getUniformLocation(this.gl_program, name_2);\n            this.uniformSetters[name_2] = getUniformSetter(gl, location_2, info);\n            if (info && info.size > 1) {\n                for (var l = 0; l < info.size; l++) {\n                    location_2 = gl.getUniformLocation(this.gl_program, \"\".concat(name_2, \"[\").concat(l, \"]\"));\n                    this.uniformSetters[\"\".concat(name_2, \"[\").concat(l, \"]\")] = getUniformSetter(gl, location_2, info);\n                }\n            }\n        }\n    };\n    Program_GL.prototype.compileShader = function (contents, type) {\n        var gl = this.device.gl;\n        var shader = this.device.ensureResourceExists(gl.createShader(type));\n        gl.shaderSource(shader, contents);\n        gl.compileShader(shader);\n        return shader;\n    };\n    // eslint-disable-next-line\n    Program_GL.prototype.setUniformsLegacy = function (uniforms) {\n        if (uniforms === void 0) { uniforms = {}; }\n        var gl = this.device.gl;\n        if (!isWebGL2(gl)) {\n            var programUsed = false;\n            for (var uniformName in uniforms) {\n                if (!programUsed) {\n                    gl.useProgram(this.gl_program);\n                    programUsed = true;\n                }\n                var uniform = uniforms[uniformName];\n                var uniformSetter = this.uniformSetters[uniformName];\n                if (uniformSetter) {\n                    var value = uniform;\n                    if (value instanceof Texture_GL) {\n                        value = value.textureIndex;\n                    }\n                    uniformSetter(value);\n                }\n            }\n        }\n        return this;\n    };\n    return Program_GL;\n}(ResourceBase_GL));\n\nvar QueryPool_GL = /** @class */ (function (_super) {\n    tslib.__extends(QueryPool_GL, _super);\n    function QueryPool_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.QueryPool;\n        var gl = _this.device.gl;\n        if (isWebGL2(gl)) {\n            var elemCount = descriptor.elemCount, type = descriptor.type;\n            _this.gl_query = nArray(elemCount, function () {\n                return _this.device.ensureResourceExists(gl.createQuery());\n            });\n            _this.gl_query_type = translateQueryPoolType$1(type);\n        }\n        return _this;\n    }\n    QueryPool_GL.prototype.queryResultOcclusion = function (dstOffs) {\n        var gl = this.device.gl;\n        if (isWebGL2(gl)) {\n            var gl_query = this.gl_query[dstOffs];\n            if (!gl.getQueryParameter(gl_query, gl.QUERY_RESULT_AVAILABLE)) {\n                return null;\n            }\n            return !!gl.getQueryParameter(gl_query, gl.QUERY_RESULT);\n        }\n        return null;\n    };\n    QueryPool_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        var gl = this.device.gl;\n        if (isWebGL2(gl)) {\n            for (var i = 0; i < this.gl_query.length; i++) {\n                gl.deleteQuery(this.gl_query[i]);\n            }\n        }\n    };\n    return QueryPool_GL;\n}(ResourceBase_GL));\n\nvar Readback_GL = /** @class */ (function (_super) {\n    tslib.__extends(Readback_GL, _super);\n    function Readback_GL(_a) {\n        var id = _a.id, device = _a.device;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Readback;\n        _this.gl_pbo = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLSync\n        _this.gl_sync = null;\n        return _this;\n    }\n    Readback_GL.prototype.clientWaitAsync = function (sync, flags, interval_ms) {\n        if (flags === void 0) { flags = 0; }\n        if (interval_ms === void 0) { interval_ms = 10; }\n        var gl = this.device.gl;\n        return new Promise(function (resolve, reject) {\n            function test() {\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/clientWaitSync\n                var res = gl.clientWaitSync(sync, flags, 0);\n                if (res == gl.WAIT_FAILED) {\n                    reject();\n                    return;\n                }\n                if (res == gl.TIMEOUT_EXPIRED) {\n                    setTimeout(test, util.clamp(interval_ms, 0, gl.MAX_CLIENT_WAIT_TIMEOUT_WEBGL));\n                    return;\n                }\n                resolve();\n            }\n            test();\n        });\n    };\n    Readback_GL.prototype.getBufferSubDataAsync = function (target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var gl;\n            return tslib.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        gl = this.device.gl;\n                        if (!isWebGL2(gl)) return [3 /*break*/, 2];\n                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/fenceSync\n                        this.gl_sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n                        gl.flush();\n                        return [4 /*yield*/, this.clientWaitAsync(this.gl_sync, 0, 10)];\n                    case 1:\n                        _a.sent();\n                        gl.bindBuffer(target, buffer);\n                        gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);\n                        gl.bindBuffer(target, null);\n                        return [2 /*return*/, dstBuffer];\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_non-blocking_async_data_readback\n     */\n    Readback_GL.prototype.readTexture = function (t, x, y, width, height, dstBuffer, dstOffset, length) {\n        if (dstOffset === void 0) { dstOffset = 0; }\n        if (length === void 0) { length = dstBuffer.byteLength || 0; }\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var gl, texture, gl_format, gl_type, formatByteSize;\n            return tslib.__generator(this, function (_a) {\n                gl = this.device.gl;\n                texture = t;\n                gl_format = this.device.translateTextureFormat(texture.format);\n                gl_type = this.device.translateTextureType(texture.format);\n                formatByteSize = getFormatByteSize(texture.format);\n                if (isWebGL2(gl)) {\n                    this.gl_pbo = this.device.ensureResourceExists(gl.createBuffer());\n                    // PIXEL_PACK_BUFFER: Buffer used for pixel transfer operations\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer\n                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.gl_pbo);\n                    // STREAM_READ: The contents are intended to be specified once by reading data from WebGL, and queried at most a few times by the application\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData\n                    gl.bufferData(gl.PIXEL_PACK_BUFFER, length, gl.STREAM_READ);\n                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n                    gl.bindFramebuffer(exports.GL.READ_FRAMEBUFFER, this.device['readbackFramebuffer']);\n                    gl.framebufferTexture2D(exports.GL.READ_FRAMEBUFFER, exports.GL.COLOR_ATTACHMENT0, exports.GL.TEXTURE_2D, texture.gl_texture, 0);\n                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.gl_pbo);\n                    gl.readPixels(x, y, width, height, gl_format, gl_type, dstOffset * formatByteSize);\n                    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n                    return [2 /*return*/, this.getBufferSubDataAsync(gl.PIXEL_PACK_BUFFER, this.gl_pbo, 0, dstBuffer, dstOffset, 0)];\n                }\n                else {\n                    return [2 /*return*/, this.readTextureSync(t, x, y, width, height, dstBuffer, dstOffset, length)];\n                }\n            });\n        });\n    };\n    Readback_GL.prototype.readTextureSync = function (t, x, y, width, height, dstBuffer, dstOffset, length) {\n        if (length === void 0) { length = dstBuffer.byteLength || 0; }\n        var gl = this.device.gl;\n        var texture = t;\n        var gl_type = this.device.translateTextureType(texture.format);\n        gl.bindFramebuffer(exports.GL.FRAMEBUFFER, this.device['readbackFramebuffer']);\n        gl.framebufferTexture2D(exports.GL.FRAMEBUFFER, exports.GL.COLOR_ATTACHMENT0, exports.GL.TEXTURE_2D, texture.gl_texture, 0);\n        // slow requires roundtrip to GPU\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei\n        gl.pixelStorei(gl.PACK_ALIGNMENT, 4);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl_type, dstBuffer);\n        return dstBuffer;\n    };\n    Readback_GL.prototype.readBuffer = function (b, srcByteOffset, dstBuffer, dstOffset, length) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var gl;\n            return tslib.__generator(this, function (_a) {\n                gl = this.device.gl;\n                if (isWebGL2(gl)) {\n                    return [2 /*return*/, this.getBufferSubDataAsync(gl.ARRAY_BUFFER, getPlatformBuffer$1(b, srcByteOffset), srcByteOffset, dstBuffer, dstOffset, length)];\n                }\n                // TODO: WebGL1\n                return [2 /*return*/, Promise.reject()];\n            });\n        });\n    };\n    Readback_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (isWebGL2(this.device.gl)) {\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/deleteSync\n            if (this.gl_sync !== null) {\n                this.device.gl.deleteSync(this.gl_sync);\n            }\n            if (this.gl_pbo !== null) {\n                this.device.gl.deleteBuffer(this.gl_pbo);\n            }\n        }\n    };\n    return Readback_GL;\n}(ResourceBase_GL));\n\nvar RenderPipeline_GL = /** @class */ (function (_super) {\n    tslib.__extends(RenderPipeline_GL, _super);\n    function RenderPipeline_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _b, _c;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.RenderPipeline;\n        _this.drawMode = translatePrimitiveTopology((_b = descriptor.topology) !== null && _b !== void 0 ? _b : exports.PrimitiveTopology.TRIANGLES);\n        _this.program = descriptor.program;\n        _this.inputLayout = descriptor.inputLayout;\n        _this.megaState = tslib.__assign(tslib.__assign({}, copyMegaState(defaultMegaState)), descriptor.megaStateDescriptor);\n        _this.colorAttachmentFormats = descriptor.colorAttachmentFormats.slice();\n        _this.depthStencilAttachmentFormat = descriptor.depthStencilAttachmentFormat;\n        _this.sampleCount = (_c = descriptor.sampleCount) !== null && _c !== void 0 ? _c : 1;\n        return _this;\n    }\n    return RenderPipeline_GL;\n}(ResourceBase_GL));\n\nvar ComputePipeline_GL = /** @class */ (function (_super) {\n    tslib.__extends(ComputePipeline_GL, _super);\n    function ComputePipeline_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.ComputePipeline;\n        _this.descriptor = descriptor;\n        return _this;\n        // const program = descriptor.program as Program_GL;\n    }\n    return ComputePipeline_GL;\n}(ResourceBase_GL));\n\nvar ResourceCreationTracker = /** @class */ (function () {\n    function ResourceCreationTracker() {\n        this.liveObjects = new Set();\n        this.creationStacks = new Map();\n        this.deletionStacks = new Map();\n    }\n    ResourceCreationTracker.prototype.trackResourceCreated = function (o) {\n        this.creationStacks.set(o, new Error().stack);\n        this.liveObjects.add(o);\n    };\n    ResourceCreationTracker.prototype.trackResourceDestroyed = function (o) {\n        if (this.deletionStacks.has(o))\n            console.warn(\"Object double freed:\", o, \"\\n\\nCreation stack: \", this.creationStacks.get(o), \"\\n\\nDeletion stack: \", this.deletionStacks.get(o), \"\\n\\nThis stack: \", new Error().stack);\n        this.deletionStacks.set(o, new Error().stack);\n        this.liveObjects.delete(o);\n    };\n    ResourceCreationTracker.prototype.checkForLeaks = function () {\n        var e_1, _a;\n        try {\n            for (var _b = tslib.__values(this.liveObjects.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var o = _c.value;\n                console.warn('Object leaked:', o, 'Creation stack:', this.creationStacks.get(o));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    ResourceCreationTracker.prototype.setResourceLeakCheck = function (o, v) {\n        if (v) {\n            this.liveObjects.add(o);\n        }\n        else {\n            this.liveObjects.delete(o);\n        }\n    };\n    return ResourceCreationTracker;\n}());\n\n/**\n * In WebGL 1 texture image data and sampling information are both stored in texture objects\n * @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-2.md#sampler-objects\n */\nvar Sampler_GL = /** @class */ (function (_super) {\n    tslib.__extends(Sampler_GL, _super);\n    function Sampler_GL(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _b, _c;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Sampler;\n        var gl = _this.device.gl;\n        if (isWebGL2(gl)) {\n            var gl_sampler = _this.device.ensureResourceExists(gl.createSampler());\n            gl.samplerParameteri(gl_sampler, exports.GL.TEXTURE_WRAP_S, translateAddressMode$1(descriptor.addressModeU));\n            gl.samplerParameteri(gl_sampler, exports.GL.TEXTURE_WRAP_T, translateAddressMode$1(descriptor.addressModeV));\n            gl.samplerParameteri(gl_sampler, exports.GL.TEXTURE_WRAP_R, translateAddressMode$1((_b = descriptor.addressModeW) !== null && _b !== void 0 ? _b : descriptor.addressModeU));\n            gl.samplerParameteri(gl_sampler, exports.GL.TEXTURE_MIN_FILTER, translateFilterMode(descriptor.minFilter, descriptor.mipmapFilter));\n            gl.samplerParameteri(gl_sampler, exports.GL.TEXTURE_MAG_FILTER, translateFilterMode(descriptor.magFilter, exports.MipmapFilterMode.NO_MIP));\n            if (descriptor.lodMinClamp !== undefined) {\n                gl.samplerParameterf(gl_sampler, exports.GL.TEXTURE_MIN_LOD, descriptor.lodMinClamp);\n            }\n            if (descriptor.lodMaxClamp !== undefined) {\n                gl.samplerParameterf(gl_sampler, exports.GL.TEXTURE_MAX_LOD, descriptor.lodMaxClamp);\n            }\n            if (descriptor.compareFunction !== undefined) {\n                gl.samplerParameteri(gl_sampler, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n                gl.samplerParameteri(gl_sampler, gl.TEXTURE_COMPARE_FUNC, descriptor.compareFunction);\n            }\n            var maxAnisotropy = (_c = descriptor.maxAnisotropy) !== null && _c !== void 0 ? _c : 1;\n            if (maxAnisotropy > 1 &&\n                _this.device.EXT_texture_filter_anisotropic !== null) {\n                assert(descriptor.minFilter === exports.FilterMode.BILINEAR &&\n                    descriptor.magFilter === exports.FilterMode.BILINEAR &&\n                    descriptor.mipmapFilter === exports.MipmapFilterMode.LINEAR);\n                gl.samplerParameterf(gl_sampler, _this.device.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);\n            }\n            _this.gl_sampler = gl_sampler;\n        }\n        else {\n            // use later in WebGL1\n            _this.descriptor = descriptor;\n        }\n        return _this;\n    }\n    Sampler_GL.prototype.setTextureParameters = function (gl_target, width, height) {\n        var _a;\n        var gl = this.device.gl;\n        var descriptor = this.descriptor;\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL#%E9%9D%9E2%E7%9A%84%E5%B9%82%E7%BA%B9%E7%90%86\n        if (this.isNPOT(width, height)) {\n            gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_MIN_FILTER, exports.GL.LINEAR);\n        }\n        else {\n            gl.texParameteri(gl_target, exports.GL.TEXTURE_MIN_FILTER, translateFilterMode(descriptor.minFilter, descriptor.mipmapFilter));\n        }\n        gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_WRAP_S, translateAddressMode$1(descriptor.addressModeU));\n        gl.texParameteri(exports.GL.TEXTURE_2D, exports.GL.TEXTURE_WRAP_T, translateAddressMode$1(descriptor.addressModeV));\n        gl.texParameteri(gl_target, exports.GL.TEXTURE_MAG_FILTER, translateFilterMode(descriptor.magFilter, exports.MipmapFilterMode.NO_MIP));\n        // if (descriptor.lodMinClamp !== undefined) {\n        //   gl.texParameterf(gl_target, GL.TEXTURE_MIN_LOD, descriptor.lodMinClamp);\n        // }\n        // if (descriptor.lodMaxClamp !== undefined) {\n        //   gl.texParameterf(gl_target, GL.TEXTURE_MAX_LOD, descriptor.lodMaxClamp);\n        // }\n        var maxAnisotropy = (_a = descriptor.maxAnisotropy) !== null && _a !== void 0 ? _a : 1;\n        if (maxAnisotropy > 1 &&\n            this.device.EXT_texture_filter_anisotropic !== null) {\n            assert(descriptor.minFilter === exports.FilterMode.BILINEAR &&\n                descriptor.magFilter === exports.FilterMode.BILINEAR &&\n                descriptor.mipmapFilter === exports.MipmapFilterMode.LINEAR);\n            gl.texParameteri(gl_target, this.device.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);\n        }\n    };\n    Sampler_GL.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        if (isWebGL2(this.device.gl)) {\n            this.device.gl.deleteSampler(getPlatformSampler$1(this));\n        }\n    };\n    Sampler_GL.prototype.isNPOT = function (width, height) {\n        return !isPowerOfTwo(width) || !isPowerOfTwo(height);\n    };\n    return Sampler_GL;\n}(ResourceBase_GL));\n\n// import { assert, assertExists } from '../api';\n// import type { ComputePipeline_GL } from './ComputePipeline';\nvar ComputePass_GL = /** @class */ (function () {\n    function ComputePass_GL() {\n    }\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpucomputepassencoder-dispatch\n     */\n    ComputePass_GL.prototype.dispatchWorkgroups = function (workgroupCountX, workgroupCountY, workgroupCountZ) { };\n    ComputePass_GL.prototype.dispatchWorkgroupsIndirect = function (indirectBuffer, indirectOffset) { };\n    ComputePass_GL.prototype.setPipeline = function (pipeline_) {\n        // const pipeline = pipeline_ as ComputePipeline_WebGPU;\n        // const gpuComputePipeline = assertExists(pipeline.gpuComputePipeline);\n        // this.gpuComputePassEncoder.setPipeline(gpuComputePipeline);\n    };\n    ComputePass_GL.prototype.setBindings = function (bindings_) {\n        // const bindings = bindings_ as Bindings_WebGPU;\n        // this.gpuComputePassEncoder.setBindGroup(bindingLayoutIndex, bindings.gpuBindGroup[0]);\n    };\n    ComputePass_GL.prototype.pushDebugGroup = function (name) { };\n    ComputePass_GL.prototype.popDebugGroup = function () { };\n    ComputePass_GL.prototype.insertDebugMarker = function (markerLabel) { };\n    return ComputePass_GL;\n}());\n\nvar RenderBundle_GL = /** @class */ (function (_super) {\n    tslib.__extends(RenderBundle_GL, _super);\n    function RenderBundle_GL() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = exports.ResourceType.RenderBundle;\n        _this.commands = [];\n        return _this;\n    }\n    RenderBundle_GL.prototype.push = function (f) {\n        this.commands.push(f);\n    };\n    RenderBundle_GL.prototype.replay = function () {\n        this.commands.forEach(function (f) { return f(); });\n    };\n    return RenderBundle_GL;\n}(ResourceBase_GL));\n\n// This is a workaround for ANGLE not supporting UBOs greater than 64kb (the limit of D3D).\n// https://bugs.chromium.org/p/angleproject/issues/detail?id=3388\nvar UBO_PAGE_MAX_BYTE_SIZE = 0x10000;\n/**\n * Extract uniform blocks from shader source.\n *\n * @example\n * ```glsl\n * layout(std140) uniform CommonUniforms {\n    float u_blur;\n  };\n * ```\n */\nvar UNIFROM_BLOCK_REGEXP = /uniform(?:\\s+)(\\w+)(?:\\s?){([^]*?)}/g;\nvar Device_GL = /** @class */ (function () {\n    function Device_GL(gl, configuration) {\n        if (configuration === void 0) { configuration = {}; }\n        // Configuration\n        this.shaderDebug = false;\n        // GL extensions\n        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/OES_vertex_array_object\n        this.OES_vertex_array_object = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/ANGLE_instanced_arrays\n        this.ANGLE_instanced_arrays = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float\n        this.OES_texture_float = null;\n        // @see https://www.khronos.org/registry/webgl/extensions/OES_draw_buffers_indexed/\n        this.OES_draw_buffers_indexed = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_draw_buffers\n        this.WEBGL_draw_buffers = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture\n        this.WEBGL_depth_texture = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_color_buffer_float\n        this.WEBGL_color_buffer_float = null;\n        this.EXT_color_buffer_half_float = null;\n        this.WEBGL_compressed_texture_s3tc = null;\n        this.WEBGL_compressed_texture_s3tc_srgb = null;\n        this.EXT_texture_compression_rgtc = null;\n        this.EXT_texture_filter_anisotropic = null;\n        this.KHR_parallel_shader_compile = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/EXT_texture_norm16\n        this.EXT_texture_norm16 = null;\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/EXT_color_buffer_float\n        this.EXT_color_buffer_float = null;\n        this.OES_texture_float_linear = null;\n        this.OES_texture_half_float_linear = null;\n        // Swap Chain\n        this.scTexture = null;\n        this.scPlatformFramebuffer = null;\n        // Device\n        this.currentActiveTexture = null;\n        this.currentBoundVAO = null;\n        this.currentProgram = null;\n        this.resourceCreationTracker = null;\n        this.resourceUniqueId = 0;\n        // Cached GL driver state\n        this.currentColorAttachments = [];\n        this.currentColorAttachmentLevels = [];\n        this.currentColorResolveTos = [];\n        this.currentColorResolveToLevels = [];\n        this.currentSampleCount = -1;\n        this.currentIndexBufferByteOffset = null;\n        this.currentMegaState = copyMegaState(defaultMegaState);\n        this.currentSamplers = [];\n        this.currentTextures = [];\n        this.currentUniformBuffers = [];\n        this.currentUniformBufferByteOffsets = [];\n        this.currentUniformBufferByteSizes = [];\n        this.currentScissorEnabled = false;\n        this.currentStencilRef = null;\n        // Pass Execution\n        this.currentRenderPassDescriptor = null;\n        this.currentRenderPassDescriptorStack = [];\n        this.debugGroupStack = [];\n        this.resolveColorAttachmentsChanged = false;\n        this.resolveDepthStencilAttachmentsChanged = false;\n        this.explicitBindingLocations = false;\n        this.separateSamplerTextures = false;\n        this.viewportOrigin = exports.ViewportOrigin.LOWER_LEFT;\n        this.clipSpaceNearZ = exports.ClipSpaceNearZ.NEGATIVE_ONE;\n        this.supportMRT = false;\n        this.inBlitRenderPass = false;\n        this.supportedSampleCounts = [];\n        this.occlusionQueriesRecommended = false;\n        this.computeShadersSupported = false;\n        this.gl = gl;\n        this.contextAttributes = assertExists(gl.getContextAttributes());\n        if (!isWebGL2(gl)) {\n            this.OES_vertex_array_object = gl.getExtension('OES_vertex_array_object');\n            // TODO: when ANGLE_instanced_arrays unavailable...\n            this.ANGLE_instanced_arrays = gl.getExtension('ANGLE_instanced_arrays');\n            this.OES_texture_float = gl.getExtension('OES_texture_float');\n            this.WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture\n            this.WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');\n            this.WEBGL_color_buffer_float = gl.getExtension('WEBGL_color_buffer_float');\n            this.EXT_color_buffer_half_float = gl.getExtension('EXT_color_buffer_half_float');\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/EXT_frag_depth\n            gl.getExtension('EXT_frag_depth');\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/OES_element_index_uint\n            gl.getExtension('OES_element_index_uint');\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/OES_standard_derivatives\n            gl.getExtension('OES_standard_derivatives');\n        }\n        else {\n            this.EXT_texture_norm16 = gl.getExtension('EXT_texture_norm16');\n            this.EXT_color_buffer_float = gl.getExtension('EXT_color_buffer_float');\n        }\n        this.WEBGL_compressed_texture_s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc');\n        this.WEBGL_compressed_texture_s3tc_srgb = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');\n        this.EXT_texture_compression_rgtc = gl.getExtension('EXT_texture_compression_rgtc');\n        this.EXT_texture_filter_anisotropic = gl.getExtension('EXT_texture_filter_anisotropic');\n        this.EXT_texture_norm16 = gl.getExtension('EXT_texture_norm16');\n        this.OES_texture_float_linear = gl.getExtension('OES_texture_float_linear');\n        this.OES_texture_half_float_linear = gl.getExtension('OES_texture_half_float_linear');\n        this.KHR_parallel_shader_compile = gl.getExtension('KHR_parallel_shader_compile');\n        // this.OES_draw_buffers_indexed = gl.getExtension('OES_draw_buffers_indexed');\n        if (isWebGL2(gl)) {\n            this.platformString = 'WebGL2';\n            this.glslVersion = '#version 300 es';\n        }\n        else {\n            this.platformString = 'WebGL1';\n            this.glslVersion = '#version 100'; // 100 es not supported\n        }\n        // Create our fake swap-chain texture.\n        this.scTexture = new Texture_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: {\n                width: 0,\n                height: 0,\n                depthOrArrayLayers: 1,\n                dimension: exports.TextureDimension.TEXTURE_2D,\n                mipLevelCount: 1,\n                usage: exports.TextureUsage.RENDER_TARGET,\n                format: this.contextAttributes.alpha === false\n                    ? exports.Format.U8_RGB_RT\n                    : exports.Format.U8_RGBA_RT,\n            },\n            fake: true,\n        });\n        this.scTexture.formatKind = exports.SamplerFormatKind.Float;\n        this.scTexture.gl_target = null;\n        this.scTexture.gl_texture = null;\n        this.resolveColorReadFramebuffer = this.ensureResourceExists(gl.createFramebuffer());\n        this.resolveColorDrawFramebuffer = this.ensureResourceExists(gl.createFramebuffer());\n        this.resolveDepthStencilReadFramebuffer = this.ensureResourceExists(gl.createFramebuffer());\n        this.resolveDepthStencilDrawFramebuffer = this.ensureResourceExists(gl.createFramebuffer());\n        this.renderPassDrawFramebuffer = this.ensureResourceExists(gl.createFramebuffer());\n        this.readbackFramebuffer = this.ensureResourceExists(gl.createFramebuffer());\n        this.fallbackTexture2D = this.createFallbackTexture(exports.TextureDimension.TEXTURE_2D, exports.SamplerFormatKind.Float);\n        this.fallbackTexture2DDepth = this.createFallbackTexture(exports.TextureDimension.TEXTURE_2D, exports.SamplerFormatKind.Depth);\n        this.fallbackVertexBuffer = this.createBuffer({\n            viewOrSize: 1,\n            usage: exports.BufferUsage.VERTEX,\n            hint: exports.BufferFrequencyHint.STATIC,\n        });\n        if (isWebGL2(gl)) {\n            this.fallbackTexture2DArray = this.createFallbackTexture(exports.TextureDimension.TEXTURE_2D_ARRAY, exports.SamplerFormatKind.Float);\n            this.fallbackTexture3D = this.createFallbackTexture(exports.TextureDimension.TEXTURE_3D, exports.SamplerFormatKind.Float);\n            this.fallbackTextureCube = this.createFallbackTexture(exports.TextureDimension.TEXTURE_CUBE_MAP, exports.SamplerFormatKind.Float);\n        }\n        // Adjust for GL defaults.\n        this.currentMegaState.depthCompare = exports.CompareFunction.LESS;\n        this.currentMegaState.depthWrite = false;\n        this.currentMegaState.attachmentsState[0].channelWriteMask =\n            exports.ChannelWriteMask.ALL;\n        // always have depth test enabled.\n        gl.enable(gl.DEPTH_TEST);\n        gl.enable(gl.STENCIL_TEST);\n        this.checkLimits();\n        if (configuration.shaderDebug) {\n            this.shaderDebug = true;\n        }\n        if (configuration.trackResources) {\n            this.resourceCreationTracker = new ResourceCreationTracker();\n        }\n    }\n    Device_GL.prototype.destroy = function () {\n        if (this.blitBindings) {\n            this.blitBindings.destroy();\n        }\n        if (this.blitInputLayout) {\n            this.blitInputLayout.destroy();\n        }\n        if (this.blitRenderPipeline) {\n            this.blitRenderPipeline.destroy();\n        }\n        if (this.blitVertexBuffer) {\n            this.blitVertexBuffer.destroy();\n        }\n        if (this.blitProgram) {\n            this.blitProgram.destroy();\n        }\n    };\n    Device_GL.prototype.createFallbackTexture = function (dimension, formatKind) {\n        var depthOrArrayLayers = dimension === exports.TextureDimension.TEXTURE_CUBE_MAP ? 6 : 1;\n        // const supportDepthTexture =\n        //   isWebGL2(this.gl) || (!isWebGL2(this.gl) && !!this.WEBGL_depth_texture);\n        var format = formatKind === exports.SamplerFormatKind.Depth\n            ? exports.Format.D32F\n            : exports.Format.U8_RGBA_NORM;\n        var texture = this.createTexture({\n            dimension: dimension,\n            format: format,\n            usage: exports.TextureUsage.SAMPLED,\n            width: 1,\n            height: 1,\n            depthOrArrayLayers: depthOrArrayLayers,\n            mipLevelCount: 1,\n        });\n        if (formatKind === exports.SamplerFormatKind.Float) {\n            texture.setImageData([new Uint8Array(4 * depthOrArrayLayers)]);\n        }\n        return getPlatformTexture(texture);\n    };\n    Device_GL.prototype.getNextUniqueId = function () {\n        return ++this.resourceUniqueId;\n    };\n    Device_GL.prototype.checkLimits = function () {\n        var gl = this.gl;\n        this.maxVertexAttribs = gl.getParameter(exports.GL.MAX_VERTEX_ATTRIBS);\n        if (isWebGL2(gl)) {\n            this.uniformBufferMaxPageByteSize = Math.min(gl.getParameter(exports.GL.MAX_UNIFORM_BLOCK_SIZE), UBO_PAGE_MAX_BYTE_SIZE);\n            this.uniformBufferWordAlignment =\n                gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT) / 4;\n            var supportedSampleCounts = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.DEPTH32F_STENCIL8, gl.SAMPLES);\n            this.supportedSampleCounts = supportedSampleCounts\n                ? tslib.__spreadArray([], tslib.__read(supportedSampleCounts), false) : [];\n            this.occlusionQueriesRecommended = true;\n        }\n        else {\n            // mock ubo in WebGL1\n            this.uniformBufferWordAlignment = 64;\n            this.uniformBufferMaxPageByteSize = UBO_PAGE_MAX_BYTE_SIZE;\n        }\n        this.uniformBufferMaxPageWordSize = this.uniformBufferMaxPageByteSize / 4;\n        if (!this.supportedSampleCounts.includes(1)) {\n            this.supportedSampleCounts.push(1);\n        }\n        this.supportedSampleCounts.sort(function (a, b) { return a - b; });\n    };\n    //#region SwapChain\n    Device_GL.prototype.configureSwapChain = function (width, height, platformFramebuffer) {\n        var texture = this.scTexture;\n        texture.width = width;\n        texture.height = height;\n        this.scPlatformFramebuffer = nullify(platformFramebuffer);\n    };\n    Device_GL.prototype.getDevice = function () {\n        return this;\n    };\n    Device_GL.prototype.getCanvas = function () {\n        return this.gl.canvas;\n    };\n    Device_GL.prototype.getOnscreenTexture = function () {\n        return this.scTexture;\n    };\n    Device_GL.prototype.beginFrame = function () { };\n    Device_GL.prototype.endFrame = function () { };\n    //#endregion\n    //#region Device\n    // @see https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html\n    Device_GL.prototype.translateTextureInternalFormat = function (fmt, isRenderbufferStorage) {\n        if (isRenderbufferStorage === void 0) { isRenderbufferStorage = false; }\n        switch (fmt) {\n            case exports.Format.ALPHA:\n                return exports.GL.ALPHA;\n            case exports.Format.U8_LUMINANCE:\n            case exports.Format.F16_LUMINANCE:\n            case exports.Format.F32_LUMINANCE:\n                return exports.GL.LUMINANCE;\n            // case Format.LUMINANCE_ALPHA:\n            //   return GL.LUMINANCE_ALPHA;\n            case exports.Format.F16_R:\n                return exports.GL.R16F;\n            case exports.Format.F16_RG:\n                return exports.GL.RG16F;\n            case exports.Format.F16_RGB:\n                return exports.GL.RGB16F;\n            case exports.Format.F16_RGBA:\n                return exports.GL.RGBA16F;\n            case exports.Format.F32_R:\n                return exports.GL.R32F;\n            case exports.Format.F32_RG:\n                return exports.GL.RG32F;\n            case exports.Format.F32_RGB:\n                return exports.GL.RGB32F;\n            case exports.Format.F32_RGBA:\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_color_buffer_float\n                return isWebGL2(this.gl)\n                    ? exports.GL.RGBA32F\n                    : isRenderbufferStorage\n                        ? this.WEBGL_color_buffer_float.RGBA32F_EXT\n                        : exports.GL.RGBA;\n            case exports.Format.U8_R_NORM:\n                return exports.GL.R8;\n            case exports.Format.U8_RG_NORM:\n                return exports.GL.RG8;\n            case exports.Format.U8_RGB_NORM:\n            case exports.Format.U8_RGB_RT:\n                return exports.GL.RGB8;\n            case exports.Format.U8_RGB_SRGB:\n                return exports.GL.SRGB8;\n            case exports.Format.U8_RGBA_NORM:\n            case exports.Format.U8_RGBA_RT:\n                // WebGL1 renderbuffer only support RGBA4 RGB565 RGB5_A1\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/renderbufferStorage#parameters\n                // But texImage2D allows RGBA\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n                return isWebGL2(this.gl)\n                    ? exports.GL.RGBA8\n                    : isRenderbufferStorage\n                        ? exports.GL.RGBA4\n                        : exports.GL.RGBA;\n            case exports.Format.U8_RGBA:\n                return exports.GL.RGBA;\n            case exports.Format.U8_RGBA_SRGB:\n            case exports.Format.U8_RGBA_RT_SRGB:\n                return exports.GL.SRGB8_ALPHA8;\n            case exports.Format.U16_R:\n                return exports.GL.R16UI;\n            case exports.Format.U16_R_NORM:\n                return this.EXT_texture_norm16.R16_EXT;\n            case exports.Format.U16_RG_NORM:\n                return this.EXT_texture_norm16.RG16_EXT;\n            case exports.Format.U16_RGBA_NORM:\n                return this.EXT_texture_norm16.RGBA16_EXT;\n            case exports.Format.U16_RGBA_5551:\n                return exports.GL.RGB5_A1;\n            case exports.Format.U16_RGB_565:\n                return exports.GL.RGB565;\n            case exports.Format.U32_R:\n                return exports.GL.R32UI;\n            case exports.Format.S8_RGBA_NORM:\n                return exports.GL.RGBA8_SNORM;\n            case exports.Format.S8_RG_NORM:\n                return exports.GL.RG8_SNORM;\n            case exports.Format.BC1:\n                return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n            case exports.Format.BC1_SRGB:\n                return this.WEBGL_compressed_texture_s3tc_srgb\n                    .COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n            case exports.Format.BC2:\n                return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n            case exports.Format.BC2_SRGB:\n                return this.WEBGL_compressed_texture_s3tc_srgb\n                    .COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n            case exports.Format.BC3:\n                return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n            case exports.Format.BC3_SRGB:\n                return this.WEBGL_compressed_texture_s3tc_srgb\n                    .COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n            case exports.Format.BC4_UNORM:\n                return this.EXT_texture_compression_rgtc.COMPRESSED_RED_RGTC1_EXT;\n            case exports.Format.BC4_SNORM:\n                return this.EXT_texture_compression_rgtc\n                    .COMPRESSED_SIGNED_RED_RGTC1_EXT;\n            case exports.Format.BC5_UNORM:\n                return this.EXT_texture_compression_rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT;\n            case exports.Format.BC5_SNORM:\n                return this.EXT_texture_compression_rgtc\n                    .COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n            case exports.Format.D32F_S8:\n                return isWebGL2(this.gl)\n                    ? exports.GL.DEPTH32F_STENCIL8\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.DEPTH_STENCIL\n                        : exports.GL.DEPTH_COMPONENT16;\n            case exports.Format.D24_S8:\n                return isWebGL2(this.gl)\n                    ? exports.GL.DEPTH24_STENCIL8\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.DEPTH_STENCIL\n                        : exports.GL.DEPTH_COMPONENT16;\n            case exports.Format.D32F:\n                return isWebGL2(this.gl)\n                    ? exports.GL.DEPTH_COMPONENT32F\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.DEPTH_COMPONENT\n                        : exports.GL.DEPTH_COMPONENT16;\n            case exports.Format.D24:\n                return isWebGL2(this.gl)\n                    ? exports.GL.DEPTH_COMPONENT24\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.DEPTH_COMPONENT\n                        : exports.GL.DEPTH_COMPONENT16;\n            default:\n                throw new Error('whoops');\n        }\n    };\n    Device_GL.prototype.translateTextureType = function (fmt) {\n        var typeFlags = getFormatTypeFlags(fmt);\n        switch (typeFlags) {\n            case exports.FormatTypeFlags.U8:\n                return exports.GL.UNSIGNED_BYTE;\n            case exports.FormatTypeFlags.U16:\n                return exports.GL.UNSIGNED_SHORT;\n            case exports.FormatTypeFlags.U32:\n                return exports.GL.UNSIGNED_INT;\n            case exports.FormatTypeFlags.S8:\n                return exports.GL.BYTE;\n            case exports.FormatTypeFlags.F16:\n                return exports.GL.HALF_FLOAT;\n            case exports.FormatTypeFlags.F32:\n                return exports.GL.FLOAT;\n            case exports.FormatTypeFlags.U16_PACKED_5551:\n                return exports.GL.UNSIGNED_SHORT_5_5_5_1;\n            case exports.FormatTypeFlags.D32F:\n                return isWebGL2(this.gl)\n                    ? exports.GL.FLOAT\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.UNSIGNED_INT\n                        : exports.GL.UNSIGNED_BYTE;\n            case exports.FormatTypeFlags.D24:\n                return isWebGL2(this.gl)\n                    ? exports.GL.UNSIGNED_INT_24_8\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.UNSIGNED_SHORT\n                        : exports.GL.UNSIGNED_BYTE;\n            case exports.FormatTypeFlags.D24S8:\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture\n                return isWebGL2(this.gl)\n                    ? exports.GL.UNSIGNED_INT_24_8\n                    : this.WEBGL_depth_texture\n                        ? exports.GL.UNSIGNED_INT_24_8_WEBGL\n                        : exports.GL.UNSIGNED_BYTE;\n            case exports.FormatTypeFlags.D32FS8:\n                return exports.GL.FLOAT_32_UNSIGNED_INT_24_8_REV;\n            default:\n                throw new Error('whoops');\n        }\n    };\n    /**\n     * Only works in WebGL2\n     * @see https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html\n     */\n    Device_GL.prototype.translateInternalTextureFormat = function (fmt) {\n        switch (fmt) {\n            case exports.Format.F32_R:\n                return exports.GL.R32F;\n            case exports.Format.F32_RG:\n                return exports.GL.RG32F;\n            case exports.Format.F32_RGB:\n                return exports.GL.RGB32F;\n            case exports.Format.F32_RGBA:\n                return exports.GL.RGBA32F;\n            case exports.Format.F16_R:\n                return exports.GL.R16F;\n            case exports.Format.F16_RG:\n                return exports.GL.RG16F;\n            case exports.Format.F16_RGB:\n                return exports.GL.RGB16F;\n            case exports.Format.F16_RGBA:\n                return exports.GL.RGBA16F;\n        }\n        return this.translateTextureFormat(fmt);\n    };\n    Device_GL.prototype.translateTextureFormat = function (fmt) {\n        if (isTextureFormatCompressed(fmt) ||\n            fmt === exports.Format.F32_LUMINANCE ||\n            fmt === exports.Format.U8_LUMINANCE) {\n            return this.translateTextureInternalFormat(fmt);\n        }\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture\n        var supportDepthTexture = isWebGL2(this.gl) || (!isWebGL2(this.gl) && !!this.WEBGL_depth_texture);\n        switch (fmt) {\n            case exports.Format.D24_S8:\n            case exports.Format.D32F_S8:\n                return supportDepthTexture ? exports.GL.DEPTH_STENCIL : exports.GL.RGBA;\n            case exports.Format.D24:\n            case exports.Format.D32F:\n                return supportDepthTexture ? exports.GL.DEPTH_COMPONENT : exports.GL.RGBA;\n        }\n        var isInteger = isFormatSizedInteger(fmt);\n        var compFlags = getFormatCompFlags(fmt);\n        switch (compFlags) {\n            case exports.FormatCompFlags.A:\n                return exports.GL.ALPHA;\n            case exports.FormatCompFlags.R:\n                return isInteger ? exports.GL.RED_INTEGER : exports.GL.RED;\n            case exports.FormatCompFlags.RG:\n                return isInteger ? exports.GL.RG_INTEGER : exports.GL.RG;\n            case exports.FormatCompFlags.RGB:\n                return isInteger ? exports.GL.RGB_INTEGER : exports.GL.RGB;\n            case exports.FormatCompFlags.RGBA:\n                // TODO: Chrome throw error when readPixels RGBA_INTEGER and UNSIGNED_BYTE\n                // @see https://github.com/KhronosGroup/WebGL/issues/2747\n                // return isInteger ? GL.RGBA_INTEGER : GL.RGBA;\n                return exports.GL.RGBA;\n        }\n    };\n    Device_GL.prototype.setActiveTexture = function (texture) {\n        if (this.currentActiveTexture !== texture) {\n            this.gl.activeTexture(texture);\n            this.currentActiveTexture = texture;\n        }\n    };\n    Device_GL.prototype.bindVAO = function (vao) {\n        if (this.currentBoundVAO !== vao) {\n            if (isWebGL2(this.gl)) {\n                this.gl.bindVertexArray(vao);\n            }\n            else {\n                this.OES_vertex_array_object.bindVertexArrayOES(vao);\n            }\n            this.currentBoundVAO = vao;\n        }\n    };\n    Device_GL.prototype.programCompiled = function (program) {\n        assert(program.compileState !== ProgramCompileState_GL.NeedsCompile);\n        if (program.compileState === ProgramCompileState_GL.Compiling) {\n            program.compileState = ProgramCompileState_GL.NeedsBind;\n            if (this.shaderDebug) {\n                this.checkProgramCompilationForErrors(program);\n            }\n        }\n    };\n    Device_GL.prototype.useProgram = function (program) {\n        if (this.currentProgram === program)\n            return;\n        this.programCompiled(program);\n        this.gl.useProgram(program.gl_program);\n        this.currentProgram = program;\n    };\n    Device_GL.prototype.ensureResourceExists = function (resource) {\n        if (resource === null) {\n            var error = this.gl.getError();\n            throw new Error(\"Created resource is null; GL error encountered: \".concat(error));\n        }\n        else {\n            return resource;\n        }\n    };\n    Device_GL.prototype.createBuffer = function (descriptor) {\n        return new Buffer_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createTexture = function (descriptor) {\n        return new Texture_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createSampler = function (descriptor) {\n        return new Sampler_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createRenderTarget = function (descriptor) {\n        return new RenderTarget_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createRenderTargetFromTexture = function (texture) {\n        var _a = texture, format = _a.format, width = _a.width, height = _a.height, mipLevelCount = _a.mipLevelCount;\n        // Render targets cannot have a mip chain currently.\n        assert(mipLevelCount === 1);\n        return this.createRenderTarget({\n            format: format,\n            width: width,\n            height: height,\n            sampleCount: 1,\n            texture: texture,\n        });\n    };\n    Device_GL.prototype.createProgram = function (descriptor) {\n        var _a, _b, _c;\n        var rawVertexGLSL = (_a = descriptor.vertex) === null || _a === void 0 ? void 0 : _a.glsl;\n        // preprocess GLSL first\n        if ((_b = descriptor.vertex) === null || _b === void 0 ? void 0 : _b.glsl) {\n            descriptor.vertex.glsl = preprocessShader_GLSL(this.queryVendorInfo(), 'vert', descriptor.vertex.glsl);\n        }\n        if ((_c = descriptor.fragment) === null || _c === void 0 ? void 0 : _c.glsl) {\n            descriptor.fragment.glsl = preprocessShader_GLSL(this.queryVendorInfo(), 'frag', descriptor.fragment.glsl);\n        }\n        return this.createProgramSimple(descriptor, rawVertexGLSL);\n    };\n    Device_GL.prototype.createProgramSimple = function (descriptor, rawVertexGLSL) {\n        var program = new Program_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        }, rawVertexGLSL);\n        return program;\n    };\n    Device_GL.prototype.createBindings = function (descriptor) {\n        return new Bindings_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createInputLayout = function (descriptor) {\n        return new InputLayout_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createRenderPipeline = function (descriptor) {\n        return new RenderPipeline_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createComputePass = function () {\n        return new ComputePass_GL();\n    };\n    Device_GL.prototype.createComputePipeline = function (descriptor) {\n        return new ComputePipeline_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_GL.prototype.createReadback = function () {\n        return new Readback_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n        });\n    };\n    Device_GL.prototype.createQueryPool = function (type, elemCount) {\n        return new QueryPool_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: {\n                type: type,\n                elemCount: elemCount,\n            },\n        });\n    };\n    Device_GL.prototype.formatRenderPassDescriptor = function (descriptor) {\n        var _a, _b, _c, _d, _e, _f;\n        var colorAttachment = descriptor.colorAttachment;\n        descriptor.depthClearValue = (_a = descriptor.depthClearValue) !== null && _a !== void 0 ? _a : 'load';\n        descriptor.stencilClearValue = (_b = descriptor.stencilClearValue) !== null && _b !== void 0 ? _b : 'load';\n        for (var i = 0; i < colorAttachment.length; i++) {\n            if (!descriptor.colorAttachmentLevel) {\n                descriptor.colorAttachmentLevel = [];\n            }\n            descriptor.colorAttachmentLevel[i] =\n                (_c = descriptor.colorAttachmentLevel[i]) !== null && _c !== void 0 ? _c : 0;\n            if (!descriptor.colorResolveToLevel) {\n                descriptor.colorResolveToLevel = [];\n            }\n            descriptor.colorResolveToLevel[i] =\n                (_d = descriptor.colorResolveToLevel[i]) !== null && _d !== void 0 ? _d : 0;\n            if (!descriptor.colorClearColor) {\n                descriptor.colorClearColor = [];\n            }\n            descriptor.colorClearColor[i] = (_e = descriptor.colorClearColor[i]) !== null && _e !== void 0 ? _e : 'load';\n            if (!descriptor.colorStore) {\n                descriptor.colorStore = [];\n            }\n            descriptor.colorStore[i] = (_f = descriptor.colorStore[i]) !== null && _f !== void 0 ? _f : false;\n        }\n    };\n    Device_GL.prototype.createRenderBundle = function () {\n        return new RenderBundle_GL({\n            id: this.getNextUniqueId(),\n            device: this,\n        });\n    };\n    Device_GL.prototype.beginBundle = function (bundle) {\n        this.renderBundle = bundle;\n    };\n    Device_GL.prototype.endBundle = function () {\n        this.renderBundle = undefined;\n    };\n    Device_GL.prototype.executeBundles = function (renderBundles) {\n        renderBundles.forEach(function (renderBundle) {\n            renderBundle.replay();\n        });\n    };\n    Device_GL.prototype.createRenderPass = function (descriptor) {\n        if (this.currentRenderPassDescriptor !== null) {\n            // Save current renderpass descriptor.\n            this.currentRenderPassDescriptorStack.push(this.currentRenderPassDescriptor);\n        }\n        this.currentRenderPassDescriptor = descriptor;\n        // Format renderpass descriptor\n        this.formatRenderPassDescriptor(descriptor);\n        var colorAttachment = descriptor.colorAttachment, colorAttachmentLevel = descriptor.colorAttachmentLevel, colorClearColor = descriptor.colorClearColor, colorResolveTo = descriptor.colorResolveTo, colorResolveToLevel = descriptor.colorResolveToLevel, depthStencilAttachment = descriptor.depthStencilAttachment, depthClearValue = descriptor.depthClearValue, stencilClearValue = descriptor.stencilClearValue, depthStencilResolveTo = descriptor.depthStencilResolveTo;\n        var skipBlit = colorResolveTo &&\n            colorResolveTo.length === 1 &&\n            colorResolveTo[0] === this.scTexture;\n        this.setRenderPassParametersBegin(colorAttachment.length, skipBlit);\n        for (var i = 0; i < colorAttachment.length; i++) {\n            this.setRenderPassParametersColor(i, colorAttachment[i], colorAttachmentLevel[i], colorResolveTo[i], colorResolveToLevel[i], skipBlit);\n        }\n        this.setRenderPassParametersDepthStencil(depthStencilAttachment, depthStencilResolveTo, skipBlit);\n        this.validateCurrentAttachments();\n        for (var i = 0; i < colorAttachment.length; i++) {\n            var clearColor = colorClearColor[i];\n            if (clearColor === 'load')\n                continue;\n            this.setRenderPassParametersClearColor(i, clearColor.r, clearColor.g, clearColor.b, clearColor.a);\n        }\n        this.setRenderPassParametersClearDepthStencil(depthClearValue, stencilClearValue);\n        return this;\n    };\n    Device_GL.prototype.submitPass = function (pass) {\n        assert(this.currentRenderPassDescriptor !== null);\n        this.endPass();\n        if (this.currentRenderPassDescriptorStack.length) {\n            // Restore previous renderpass descriptor.\n            this.currentRenderPassDescriptor =\n                this.currentRenderPassDescriptorStack.pop();\n        }\n        else {\n            this.currentRenderPassDescriptor = null;\n        }\n    };\n    Device_GL.prototype.copySubTexture2D = function (dst_, dstX, dstY, src_, srcX, srcY) {\n        var gl = this.gl;\n        var dst = dst_;\n        var src = src_;\n        assert(src.mipLevelCount === 1);\n        assert(dst.mipLevelCount === 1);\n        if (isWebGL2(gl)) {\n            if (dst === this.scTexture) {\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.scPlatformFramebuffer);\n            }\n            else {\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.resolveColorDrawFramebuffer);\n                this.bindFramebufferAttachment(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, dst, 0);\n            }\n            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.resolveColorReadFramebuffer);\n            this.bindFramebufferAttachment(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, src, 0);\n            gl.blitFramebuffer(srcX, srcY, srcX + src.width, srcY + src.height, dstX, dstY, dstX + src.width, dstY + src.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);\n            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n        }\n        else {\n            if (dst === this.scTexture) {\n                var rt = this.createRenderTargetFromTexture(src_);\n                this.submitBlitRenderPass(rt, dst);\n            }\n        }\n    };\n    Device_GL.prototype.queryLimits = function () {\n        return this;\n    };\n    Device_GL.prototype.queryTextureFormatSupported = function (format, width, height) {\n        switch (format) {\n            case exports.Format.BC1_SRGB:\n            case exports.Format.BC2_SRGB:\n            case exports.Format.BC3_SRGB:\n                if (this.WEBGL_compressed_texture_s3tc_srgb !== null)\n                    return isBlockCompressSized(width, height, 4, 4);\n                return false;\n            case exports.Format.BC1:\n            case exports.Format.BC2:\n            case exports.Format.BC3:\n                if (this.WEBGL_compressed_texture_s3tc !== null)\n                    return isBlockCompressSized(width, height, 4, 4);\n                return false;\n            case exports.Format.BC4_UNORM:\n            case exports.Format.BC4_SNORM:\n            case exports.Format.BC5_UNORM:\n            case exports.Format.BC5_SNORM:\n                if (this.EXT_texture_compression_rgtc !== null)\n                    return isBlockCompressSized(width, height, 4, 4);\n                return false;\n            case exports.Format.U16_R_NORM:\n            case exports.Format.U16_RG_NORM:\n            case exports.Format.U16_RGBA_NORM:\n                return this.EXT_texture_norm16 !== null;\n            case exports.Format.F32_R:\n            case exports.Format.F32_RG:\n            case exports.Format.F32_RGB:\n            case exports.Format.F32_RGBA:\n                return this.OES_texture_float_linear !== null;\n            case exports.Format.F16_R:\n            case exports.Format.F16_RG:\n            case exports.Format.F16_RGB:\n            case exports.Format.F16_RGBA:\n                return this.OES_texture_half_float_linear !== null;\n            default:\n                return true;\n        }\n    };\n    Device_GL.prototype.queryProgramReady = function (program) {\n        var gl = this.gl;\n        if (program.compileState === ProgramCompileState_GL.NeedsCompile) {\n            // This should not happen.\n            throw new Error('whoops');\n        }\n        if (program.compileState === ProgramCompileState_GL.Compiling) {\n            var complete = void 0;\n            if (this.KHR_parallel_shader_compile !== null) {\n                complete = gl.getProgramParameter(program.gl_program, this.KHR_parallel_shader_compile.COMPLETION_STATUS_KHR);\n            }\n            else {\n                // If we don't have async shader compilation, assume all compilation is done immediately :/\n                complete = true;\n            }\n            if (complete) {\n                this.programCompiled(program);\n            }\n            return complete;\n        }\n        return (program.compileState === ProgramCompileState_GL.NeedsBind ||\n            program.compileState === ProgramCompileState_GL.ReadyToUse);\n    };\n    Device_GL.prototype.queryPlatformAvailable = function () {\n        return this.gl.isContextLost();\n    };\n    Device_GL.prototype.queryVendorInfo = function () {\n        return this;\n    };\n    Device_GL.prototype.queryRenderPass = function (o) {\n        return this.currentRenderPassDescriptor;\n    };\n    Device_GL.prototype.queryRenderTarget = function (o) {\n        var renderTarget = o;\n        return renderTarget;\n    };\n    //#endregion\n    //#region Debugging\n    Device_GL.prototype.setResourceName = function (o, name) {\n        o.name = name;\n        if (o.type === exports.ResourceType.Buffer) {\n            var gl_buffer_pages = o.gl_buffer_pages;\n            for (var i = 0; i < gl_buffer_pages.length; i++)\n                assignPlatformName(gl_buffer_pages[i], \"\".concat(name, \" Page \").concat(i));\n        }\n        else if (o.type === exports.ResourceType.Texture) {\n            assignPlatformName(getPlatformTexture(o), name);\n        }\n        else if (o.type === exports.ResourceType.Sampler) {\n            assignPlatformName(getPlatformSampler$1(o), name);\n        }\n        else if (o.type === exports.ResourceType.RenderTarget) {\n            var gl_renderbuffer = o.gl_renderbuffer;\n            if (gl_renderbuffer !== null)\n                assignPlatformName(gl_renderbuffer, name);\n        }\n        else if (o.type === exports.ResourceType.InputLayout) {\n            assignPlatformName(o.vao, name);\n        }\n    };\n    Device_GL.prototype.setResourceLeakCheck = function (o, v) {\n        if (this.resourceCreationTracker !== null)\n            this.resourceCreationTracker.setResourceLeakCheck(o, v);\n    };\n    Device_GL.prototype.checkForLeaks = function () {\n        if (this.resourceCreationTracker !== null)\n            this.resourceCreationTracker.checkForLeaks();\n    };\n    Device_GL.prototype.pushDebugGroup = function (name) { };\n    Device_GL.prototype.popDebugGroup = function () { };\n    Device_GL.prototype.insertDebugMarker = function (markerLabel) { };\n    // pushDebugGroup(debugGroup: DebugGroup): void {\n    //   this.debugGroupStack.push(debugGroup);\n    // }\n    // popDebugGroup(): void {\n    //   this.debugGroupStack.pop();\n    // }\n    Device_GL.prototype.programPatched = function (o, descriptor) {\n        assert(this.shaderDebug);\n        // const program = o as Program_GL;\n        // const gl = this.gl;\n        // gl.deleteProgram(program.gl_program);\n        // program.descriptor = descriptor;\n        // program.gl_program = this.ensureResourceExists(gl.createProgram());\n        // program.compileState = ProgramCompileState_GL.NeedsCompile;\n        // this.tryCompileProgram(program);\n        // this.checkProgramCompilationForErrors(program);\n    };\n    Device_GL.prototype.getBufferData = function (buffer, dstBuffer, wordOffset) {\n        if (wordOffset === void 0) { wordOffset = 0; }\n        var gl = this.gl;\n        if (isWebGL2(gl)) {\n            gl.bindBuffer(gl.COPY_READ_BUFFER, getPlatformBuffer$1(buffer, wordOffset * 4));\n            gl.getBufferSubData(gl.COPY_READ_BUFFER, wordOffset * 4, dstBuffer);\n        }\n    };\n    //#endregion\n    Device_GL.prototype.debugGroupStatisticsDrawCall = function (count) {\n        if (count === void 0) { count = 1; }\n        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)\n            this.debugGroupStack[i].drawCallCount += count;\n    };\n    Device_GL.prototype.debugGroupStatisticsBufferUpload = function (count) {\n        if (count === void 0) { count = 1; }\n        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)\n            this.debugGroupStack[i].bufferUploadCount += count;\n    };\n    Device_GL.prototype.debugGroupStatisticsTextureBind = function (count) {\n        if (count === void 0) { count = 1; }\n        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)\n            this.debugGroupStack[i].textureBindCount += count;\n    };\n    Device_GL.prototype.debugGroupStatisticsTriangles = function (count) {\n        for (var i = this.debugGroupStack.length - 1; i >= 0; i--)\n            this.debugGroupStack[i].triangleCount += count;\n    };\n    Device_GL.prototype.reportShaderError = function (shader, str) {\n        var gl = this.gl;\n        var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        if (!status) {\n            console.error(prependLineNo(str));\n            var debug_shaders = gl.getExtension('WEBGL_debug_shaders');\n            if (debug_shaders)\n                console.error(debug_shaders.getTranslatedShaderSource(shader));\n            console.error(gl.getShaderInfoLog(shader));\n        }\n        return status;\n    };\n    Device_GL.prototype.checkProgramCompilationForErrors = function (program) {\n        var gl = this.gl;\n        var prog = program.gl_program;\n        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n            var descriptor = program.descriptor;\n            if (!this.reportShaderError(program.gl_shader_vert, descriptor.vertex.glsl))\n                return;\n            if (!this.reportShaderError(program.gl_shader_frag, descriptor.fragment.glsl))\n                return;\n            // Neither shader had an error, report the program info log.\n            console.error(gl.getProgramInfoLog(program.gl_program));\n        }\n    };\n    Device_GL.prototype.bindFramebufferAttachment = function (framebuffer, binding, attachment, level) {\n        var gl = this.gl;\n        if (util.isNil(attachment)) {\n            gl.framebufferRenderbuffer(framebuffer, binding, gl.RENDERBUFFER, null);\n        }\n        else if (attachment.type === exports.ResourceType.RenderTarget) {\n            if (attachment.gl_renderbuffer !== null) {\n                gl.framebufferRenderbuffer(framebuffer, binding, gl.RENDERBUFFER, attachment.gl_renderbuffer);\n            }\n            else if (attachment.texture !== null) {\n                gl.framebufferTexture2D(framebuffer, binding, exports.GL.TEXTURE_2D, getPlatformTexture(attachment.texture), level);\n            }\n        }\n        else if (attachment.type === exports.ResourceType.Texture) {\n            var texture = getPlatformTexture(attachment);\n            if (attachment.dimension === exports.TextureDimension.TEXTURE_2D) {\n                gl.framebufferTexture2D(framebuffer, binding, exports.GL.TEXTURE_2D, texture, level);\n            }\n            else if (isWebGL2(gl) &&\n                attachment.dimension === exports.TextureDimension.TEXTURE_2D_ARRAY) ;\n        }\n    };\n    Device_GL.prototype.bindFramebufferDepthStencilAttachment = function (framebuffer, attachment) {\n        var gl = this.gl;\n        var flags = !util.isNil(attachment)\n            ? getFormatFlags(attachment.format)\n            : exports.FormatFlags.Depth | exports.FormatFlags.Stencil;\n        var depth = !!(flags & exports.FormatFlags.Depth);\n        var stencil = !!(flags & exports.FormatFlags.Stencil);\n        if (depth && stencil) {\n            var supportDepthTexture = isWebGL2(this.gl) || (!isWebGL2(this.gl) && !!this.WEBGL_depth_texture);\n            if (supportDepthTexture) {\n                this.bindFramebufferAttachment(framebuffer, gl.DEPTH_STENCIL_ATTACHMENT, attachment, 0);\n            }\n            else {\n                this.bindFramebufferAttachment(framebuffer, gl.DEPTH_ATTACHMENT, attachment, 0);\n            }\n        }\n        else if (depth) {\n            this.bindFramebufferAttachment(framebuffer, gl.DEPTH_ATTACHMENT, attachment, 0);\n            this.bindFramebufferAttachment(framebuffer, gl.STENCIL_ATTACHMENT, null, 0);\n        }\n        else if (stencil) {\n            this.bindFramebufferAttachment(framebuffer, gl.STENCIL_ATTACHMENT, attachment, 0);\n            this.bindFramebufferAttachment(framebuffer, gl.DEPTH_ATTACHMENT, null, 0);\n        }\n    };\n    Device_GL.prototype.validateCurrentAttachments = function () {\n        var sampleCount = -1, width = -1, height = -1;\n        for (var i = 0; i < this.currentColorAttachments.length; i++) {\n            var attachment = this.currentColorAttachments[i];\n            if (attachment === null)\n                continue;\n            if (sampleCount === -1) {\n                sampleCount = attachment.sampleCount;\n                width = attachment.width;\n                height = attachment.height;\n            }\n            else {\n                assert(sampleCount === attachment.sampleCount);\n                assert(width === attachment.width);\n                assert(height === attachment.height);\n            }\n        }\n        if (this.currentDepthStencilAttachment) {\n            if (sampleCount === -1) {\n                sampleCount = this.currentDepthStencilAttachment.sampleCount;\n            }\n            else {\n                assert(sampleCount === this.currentDepthStencilAttachment.sampleCount);\n                assert(width === this.currentDepthStencilAttachment.width);\n                assert(height === this.currentDepthStencilAttachment.height);\n            }\n        }\n        this.currentSampleCount = sampleCount;\n    };\n    Device_GL.prototype.setRenderPassParametersBegin = function (numColorAttachments, toScreen) {\n        if (toScreen === void 0) { toScreen = false; }\n        var gl = this.gl;\n        if (!toScreen) {\n            if (isWebGL2(gl)) {\n                gl.bindFramebuffer(exports.GL.DRAW_FRAMEBUFFER, this.renderPassDrawFramebuffer);\n            }\n            else {\n                if (!this.inBlitRenderPass) {\n                    gl.bindFramebuffer(exports.GL.FRAMEBUFFER, this.renderPassDrawFramebuffer);\n                }\n            }\n            if (isWebGL2(gl)) {\n                gl.drawBuffers([\n                    exports.GL.COLOR_ATTACHMENT0,\n                    exports.GL.COLOR_ATTACHMENT1,\n                    exports.GL.COLOR_ATTACHMENT2,\n                    exports.GL.COLOR_ATTACHMENT3,\n                ]);\n            }\n            else {\n                if (!this.inBlitRenderPass && this.WEBGL_draw_buffers) {\n                    // MRT @see https://github.com/shrekshao/MoveWebGL1EngineToWebGL2/blob/master/Move-a-WebGL-1-Engine-To-WebGL-2-Blog-1.md#multiple-render-targets\n                    this.WEBGL_draw_buffers.drawBuffersWEBGL([\n                        exports.GL.COLOR_ATTACHMENT0_WEBGL,\n                        exports.GL.COLOR_ATTACHMENT1_WEBGL,\n                        exports.GL.COLOR_ATTACHMENT2_WEBGL,\n                        exports.GL.COLOR_ATTACHMENT3_WEBGL, // gl_FragData[3]\n                    ]);\n                }\n            }\n            if (!this.inBlitRenderPass) {\n                for (var i = numColorAttachments; i < this.currentColorAttachments.length; i++) {\n                    var target = isWebGL2(gl) ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER;\n                    var attachment = isWebGL2(gl)\n                        ? exports.GL.COLOR_ATTACHMENT0\n                        : exports.GL.COLOR_ATTACHMENT0_WEBGL;\n                    gl.framebufferRenderbuffer(target, attachment + i, exports.GL.RENDERBUFFER, null);\n                    gl.framebufferTexture2D(target, attachment + i, exports.GL.TEXTURE_2D, null, 0);\n                }\n            }\n        }\n        else {\n            gl.bindFramebuffer(exports.GL.FRAMEBUFFER, null);\n        }\n        this.currentColorAttachments.length = numColorAttachments;\n    };\n    Device_GL.prototype.setRenderPassParametersColor = function (i, colorAttachment, attachmentLevel, colorResolveTo, resolveToLevel, skipBlit) {\n        if (skipBlit === void 0) { skipBlit = false; }\n        var gl = this.gl;\n        var gl2 = isWebGL2(gl);\n        if (this.currentColorAttachments[i] !== colorAttachment ||\n            this.currentColorAttachmentLevels[i] !== attachmentLevel) {\n            this.currentColorAttachments[i] = colorAttachment;\n            this.currentColorAttachmentLevels[i] = attachmentLevel;\n            if (!skipBlit && (gl2 || (!gl2 && this.WEBGL_draw_buffers))) {\n                this.bindFramebufferAttachment(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, (gl2 ? exports.GL.COLOR_ATTACHMENT0 : exports.GL.COLOR_ATTACHMENT0_WEBGL) + i, colorAttachment, attachmentLevel);\n            }\n            this.resolveColorAttachmentsChanged = true;\n        }\n        if (this.currentColorResolveTos[i] !== colorResolveTo ||\n            this.currentColorResolveToLevels[i] !== resolveToLevel) {\n            this.currentColorResolveTos[i] = colorResolveTo;\n            this.currentColorResolveToLevels[i] = resolveToLevel;\n            if (colorResolveTo !== null) {\n                this.resolveColorAttachmentsChanged = true;\n            }\n        }\n    };\n    Device_GL.prototype.setRenderPassParametersDepthStencil = function (depthStencilAttachment, depthStencilResolveTo, skipBlit) {\n        if (skipBlit === void 0) { skipBlit = false; }\n        var gl = this.gl;\n        if (this.currentDepthStencilAttachment !== depthStencilAttachment) {\n            this.currentDepthStencilAttachment =\n                depthStencilAttachment;\n            if (!skipBlit && !this.inBlitRenderPass) {\n                this.bindFramebufferDepthStencilAttachment(isWebGL2(gl) ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.currentDepthStencilAttachment);\n            }\n            this.resolveDepthStencilAttachmentsChanged = true;\n        }\n        if (this.currentDepthStencilResolveTo !== depthStencilResolveTo) {\n            this.currentDepthStencilResolveTo = depthStencilResolveTo;\n            if (depthStencilResolveTo) {\n                this.resolveDepthStencilAttachmentsChanged = true;\n            }\n        }\n    };\n    Device_GL.prototype.setRenderPassParametersClearColor = function (slot, r, g, b, a) {\n        var gl = this.gl;\n        if (this.OES_draw_buffers_indexed !== null) {\n            var attachment = this.currentMegaState.attachmentsState[slot];\n            if (attachment && attachment.channelWriteMask !== exports.ChannelWriteMask.ALL) {\n                this.OES_draw_buffers_indexed.colorMaskiOES(slot, true, true, true, true);\n                attachment.channelWriteMask = exports.ChannelWriteMask.ALL;\n            }\n        }\n        else {\n            var attachment = this.currentMegaState.attachmentsState[0];\n            if (attachment && attachment.channelWriteMask !== exports.ChannelWriteMask.ALL) {\n                gl.colorMask(true, true, true, true);\n                attachment.channelWriteMask = exports.ChannelWriteMask.ALL;\n            }\n        }\n        this.setScissorRectEnabled(false);\n        if (isWebGL2(gl)) {\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/clearBuffer\n            gl.clearBufferfv(gl.COLOR, slot, [r, g, b, a]);\n        }\n        else {\n            gl.clearColor(r, g, b, a);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n    };\n    Device_GL.prototype.setRenderPassParametersClearDepthStencil = function (depthClearValue, stencilClearValue) {\n        if (depthClearValue === void 0) { depthClearValue = 'load'; }\n        if (stencilClearValue === void 0) { stencilClearValue = 'load'; }\n        var gl = this.gl;\n        if (depthClearValue !== 'load') {\n            assert(!!this.currentDepthStencilAttachment);\n            // GL clears obey the masks... bad API or worst API?\n            if (!this.currentMegaState.depthWrite) {\n                gl.depthMask(true);\n                this.currentMegaState.depthWrite = true;\n            }\n            if (isWebGL2(gl)) {\n                gl.clearBufferfv(gl.DEPTH, 0, [depthClearValue]);\n            }\n            else {\n                gl.clearDepth(depthClearValue);\n                gl.clear(gl.DEPTH_BUFFER_BIT);\n            }\n        }\n        if (stencilClearValue !== 'load') {\n            assert(!!this.currentDepthStencilAttachment);\n            if (!this.currentMegaState.stencilWrite) {\n                gl.enable(gl.STENCIL_TEST);\n                gl.stencilMask(0xff);\n                this.currentMegaState.stencilWrite = true;\n            }\n            if (isWebGL2(gl)) {\n                gl.clearBufferiv(gl.STENCIL, 0, [stencilClearValue]);\n            }\n            else {\n                gl.clearStencil(stencilClearValue);\n                gl.clear(gl.STENCIL_BUFFER_BIT);\n            }\n        }\n    };\n    Device_GL.prototype.setBindings = function (bindings_) {\n        var _this = this;\n        var _a;\n        if (this.renderBundle) {\n            this.renderBundle.push(function () { return _this.setBindings(bindings_); });\n            return;\n        }\n        var gl = this.gl;\n        var _b = bindings_, uniformBufferBindings = _b.uniformBufferBindings, samplerBindings = _b.samplerBindings, bindingLayouts = _b.bindingLayouts;\n        assert(0 < bindingLayouts.bindingLayoutTables.length);\n        var bindingLayoutTable = bindingLayouts.bindingLayoutTables[0];\n        // Ignore extra bindings.\n        assert(uniformBufferBindings.length >= bindingLayoutTable.numUniformBuffers);\n        assert(samplerBindings.length >= bindingLayoutTable.numSamplers);\n        for (var i = 0; i < uniformBufferBindings.length; i++) {\n            var binding = uniformBufferBindings[i];\n            if (binding.size === 0)\n                continue;\n            var index = bindingLayoutTable.firstUniformBuffer + i;\n            var buffer = binding.buffer;\n            var byteOffset = binding.offset || 0;\n            var byteSize = binding.size || buffer.byteSize;\n            if (buffer !== this.currentUniformBuffers[index] ||\n                byteOffset !== this.currentUniformBufferByteOffsets[index] ||\n                byteSize !== this.currentUniformBufferByteSizes[index]) {\n                var platformBufferByteOffset = byteOffset % buffer.pageByteSize;\n                var platformBuffer = buffer.gl_buffer_pages[(byteOffset / buffer.pageByteSize) | 0];\n                assert(platformBufferByteOffset + byteSize <= buffer.pageByteSize);\n                if (isWebGL2(gl)) {\n                    gl.bindBufferRange(gl.UNIFORM_BUFFER, index, platformBuffer, platformBufferByteOffset, byteSize);\n                }\n                this.currentUniformBuffers[index] = buffer;\n                this.currentUniformBufferByteOffsets[index] = byteOffset;\n                this.currentUniformBufferByteSizes[index] = byteSize;\n            }\n        }\n        for (var i = 0; i < bindingLayoutTable.numSamplers; i++) {\n            var binding = samplerBindings[i];\n            var samplerIndex = bindingLayoutTable.firstSampler + i;\n            var gl_sampler = binding !== null && binding.sampler !== null\n                ? getPlatformSampler$1(binding.sampler)\n                : null;\n            var gl_texture = binding !== null && binding.texture !== null\n                ? getPlatformTexture(binding.texture)\n                : null;\n            if (this.currentSamplers[samplerIndex] !== gl_sampler) {\n                if (isWebGL2(gl)) {\n                    gl.bindSampler(samplerIndex, gl_sampler);\n                }\n                this.currentSamplers[samplerIndex] = gl_sampler;\n            }\n            if (this.currentTextures[samplerIndex] !== gl_texture) {\n                this.setActiveTexture(gl.TEXTURE0 + samplerIndex);\n                if (gl_texture !== null) {\n                    var _c = assertExists(binding)\n                        .texture, gl_target = _c.gl_target, width = _c.width, height = _c.height;\n                    // update index\n                    binding.texture.textureIndex = samplerIndex;\n                    gl.bindTexture(gl_target, gl_texture);\n                    // In WebGL1 set tex's parameters @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter\n                    if (!isWebGL2(gl)) {\n                        (_a = binding.sampler) === null || _a === void 0 ? void 0 : _a.setTextureParameters(gl_target, width, height);\n                    }\n                    this.debugGroupStatisticsTextureBind();\n                }\n                else {\n                    var samplerEntry = tslib.__assign(tslib.__assign({}, binding), defaultBindingLayoutSamplerDescriptor);\n                    var dimension = samplerEntry.dimension, formatKind = samplerEntry.formatKind;\n                    var gl_target = translateTextureDimension$1(dimension);\n                    gl.bindTexture(gl_target, this.getFallbackTexture(tslib.__assign({ gl_target: gl_target, formatKind: formatKind }, samplerEntry)));\n                }\n                this.currentTextures[samplerIndex] = gl_texture;\n            }\n        }\n    };\n    Device_GL.prototype.setViewport = function (x, y, w, h) {\n        var gl = this.gl;\n        gl.viewport(x, y, w, h);\n    };\n    Device_GL.prototype.setScissorRect = function (x, y, w, h) {\n        var gl = this.gl;\n        this.setScissorRectEnabled(true);\n        gl.scissor(x, y, w, h);\n    };\n    Device_GL.prototype.applyAttachmentStateIndexed = function (i, currentAttachmentState, newAttachmentState) {\n        var gl = this.gl;\n        var dbi = this.OES_draw_buffers_indexed;\n        if (currentAttachmentState.channelWriteMask !==\n            newAttachmentState.channelWriteMask) {\n            dbi.colorMaskiOES(i, !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.RED), !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.GREEN), !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.BLUE), !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.ALPHA));\n            currentAttachmentState.channelWriteMask =\n                newAttachmentState.channelWriteMask;\n        }\n        var blendModeChanged = currentAttachmentState.rgbBlendState.blendMode !==\n            newAttachmentState.rgbBlendState.blendMode ||\n            currentAttachmentState.alphaBlendState.blendMode !==\n                newAttachmentState.alphaBlendState.blendMode;\n        var blendFuncChanged = currentAttachmentState.rgbBlendState.blendSrcFactor !==\n            newAttachmentState.rgbBlendState.blendSrcFactor ||\n            currentAttachmentState.alphaBlendState.blendSrcFactor !==\n                newAttachmentState.alphaBlendState.blendSrcFactor ||\n            currentAttachmentState.rgbBlendState.blendDstFactor !==\n                newAttachmentState.rgbBlendState.blendDstFactor ||\n            currentAttachmentState.alphaBlendState.blendDstFactor !==\n                newAttachmentState.alphaBlendState.blendDstFactor;\n        if (blendFuncChanged || blendModeChanged) {\n            if (isBlendStateNone(currentAttachmentState.rgbBlendState) &&\n                isBlendStateNone(currentAttachmentState.alphaBlendState))\n                dbi.enableiOES(i, gl.BLEND);\n            else if (isBlendStateNone(newAttachmentState.rgbBlendState) &&\n                isBlendStateNone(newAttachmentState.alphaBlendState))\n                dbi.disableiOES(i, gl.BLEND);\n        }\n        if (blendModeChanged) {\n            dbi.blendEquationSeparateiOES(i, newAttachmentState.rgbBlendState.blendMode, newAttachmentState.alphaBlendState.blendMode);\n            currentAttachmentState.rgbBlendState.blendMode =\n                newAttachmentState.rgbBlendState.blendMode;\n            currentAttachmentState.alphaBlendState.blendMode =\n                newAttachmentState.alphaBlendState.blendMode;\n        }\n        if (blendFuncChanged) {\n            dbi.blendFuncSeparateiOES(i, newAttachmentState.rgbBlendState.blendSrcFactor, newAttachmentState.rgbBlendState.blendDstFactor, newAttachmentState.alphaBlendState.blendSrcFactor, newAttachmentState.alphaBlendState.blendDstFactor);\n            currentAttachmentState.rgbBlendState.blendSrcFactor =\n                newAttachmentState.rgbBlendState.blendSrcFactor;\n            currentAttachmentState.alphaBlendState.blendSrcFactor =\n                newAttachmentState.alphaBlendState.blendSrcFactor;\n            currentAttachmentState.rgbBlendState.blendDstFactor =\n                newAttachmentState.rgbBlendState.blendDstFactor;\n            currentAttachmentState.alphaBlendState.blendDstFactor =\n                newAttachmentState.alphaBlendState.blendDstFactor;\n        }\n    };\n    Device_GL.prototype.applyAttachmentState = function (currentAttachmentState, newAttachmentState) {\n        var gl = this.gl;\n        if (currentAttachmentState.channelWriteMask !==\n            newAttachmentState.channelWriteMask) {\n            gl.colorMask(!!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.RED), !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.GREEN), !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.BLUE), !!(newAttachmentState.channelWriteMask & exports.ChannelWriteMask.ALPHA));\n            currentAttachmentState.channelWriteMask =\n                newAttachmentState.channelWriteMask;\n        }\n        var blendModeChanged = currentAttachmentState.rgbBlendState.blendMode !==\n            newAttachmentState.rgbBlendState.blendMode ||\n            currentAttachmentState.alphaBlendState.blendMode !==\n                newAttachmentState.alphaBlendState.blendMode;\n        var blendFuncChanged = currentAttachmentState.rgbBlendState.blendSrcFactor !==\n            newAttachmentState.rgbBlendState.blendSrcFactor ||\n            currentAttachmentState.alphaBlendState.blendSrcFactor !==\n                newAttachmentState.alphaBlendState.blendSrcFactor ||\n            currentAttachmentState.rgbBlendState.blendDstFactor !==\n                newAttachmentState.rgbBlendState.blendDstFactor ||\n            currentAttachmentState.alphaBlendState.blendDstFactor !==\n                newAttachmentState.alphaBlendState.blendDstFactor;\n        if (blendFuncChanged || blendModeChanged) {\n            if (isBlendStateNone(currentAttachmentState.rgbBlendState) &&\n                isBlendStateNone(currentAttachmentState.alphaBlendState)) {\n                gl.enable(gl.BLEND);\n            }\n            else if (isBlendStateNone(newAttachmentState.rgbBlendState) &&\n                isBlendStateNone(newAttachmentState.alphaBlendState)) {\n                gl.disable(gl.BLEND);\n            }\n        }\n        if (blendModeChanged) {\n            gl.blendEquationSeparate(newAttachmentState.rgbBlendState.blendMode, newAttachmentState.alphaBlendState.blendMode);\n            currentAttachmentState.rgbBlendState.blendMode =\n                newAttachmentState.rgbBlendState.blendMode;\n            currentAttachmentState.alphaBlendState.blendMode =\n                newAttachmentState.alphaBlendState.blendMode;\n        }\n        if (blendFuncChanged) {\n            gl.blendFuncSeparate(newAttachmentState.rgbBlendState.blendSrcFactor, newAttachmentState.rgbBlendState.blendDstFactor, newAttachmentState.alphaBlendState.blendSrcFactor, newAttachmentState.alphaBlendState.blendDstFactor);\n            currentAttachmentState.rgbBlendState.blendSrcFactor =\n                newAttachmentState.rgbBlendState.blendSrcFactor;\n            currentAttachmentState.alphaBlendState.blendSrcFactor =\n                newAttachmentState.alphaBlendState.blendSrcFactor;\n            currentAttachmentState.rgbBlendState.blendDstFactor =\n                newAttachmentState.rgbBlendState.blendDstFactor;\n            currentAttachmentState.alphaBlendState.blendDstFactor =\n                newAttachmentState.alphaBlendState.blendDstFactor;\n        }\n    };\n    Device_GL.prototype.setMegaState = function (newMegaState) {\n        var gl = this.gl;\n        var currentMegaState = this.currentMegaState;\n        if (this.OES_draw_buffers_indexed !== null) {\n            for (var i = 0; i < newMegaState.attachmentsState.length; i++)\n                this.applyAttachmentStateIndexed(i, currentMegaState.attachmentsState[0], newMegaState.attachmentsState[0]);\n        }\n        else {\n            assert(newMegaState.attachmentsState.length === 1);\n            this.applyAttachmentState(currentMegaState.attachmentsState[0], newMegaState.attachmentsState[0]);\n        }\n        if (!colorEqual(currentMegaState.blendConstant, newMegaState.blendConstant)) {\n            gl.blendColor(newMegaState.blendConstant.r, newMegaState.blendConstant.g, newMegaState.blendConstant.b, newMegaState.blendConstant.a);\n            colorCopy(currentMegaState.blendConstant, newMegaState.blendConstant);\n        }\n        if (currentMegaState.depthCompare !== newMegaState.depthCompare) {\n            gl.depthFunc(newMegaState.depthCompare);\n            currentMegaState.depthCompare = newMegaState.depthCompare;\n        }\n        if (!!currentMegaState.depthWrite !== !!newMegaState.depthWrite) {\n            gl.depthMask(newMegaState.depthWrite);\n            currentMegaState.depthWrite = newMegaState.depthWrite;\n        }\n        if (!!currentMegaState.stencilWrite !== !!newMegaState.stencilWrite) {\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/stencilMask\n            gl.stencilMask(newMegaState.stencilWrite ? 0xff : 0x00);\n            currentMegaState.stencilWrite = newMegaState.stencilWrite;\n        }\n        var shouldApplyStencil = false;\n        if (!stencilFaceStateEquals(currentMegaState.stencilFront, newMegaState.stencilFront)) {\n            shouldApplyStencil = true;\n            var _a = newMegaState.stencilFront, passOp = _a.passOp, failOp = _a.failOp, depthFailOp = _a.depthFailOp, compare = _a.compare;\n            if (currentMegaState.stencilFront.passOp !== passOp ||\n                currentMegaState.stencilFront.failOp !== failOp ||\n                currentMegaState.stencilFront.depthFailOp !== depthFailOp) {\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/stencilOpSeparate\n                gl.stencilOpSeparate(gl.FRONT, failOp, depthFailOp, passOp);\n                currentMegaState.stencilFront.passOp = passOp;\n                currentMegaState.stencilFront.failOp = failOp;\n                currentMegaState.stencilFront.depthFailOp = depthFailOp;\n            }\n            if (currentMegaState.stencilFront.compare !== compare) {\n                this.setStencilReference(0);\n                currentMegaState.stencilFront.compare = compare;\n            }\n        }\n        if (!stencilFaceStateEquals(currentMegaState.stencilBack, newMegaState.stencilBack)) {\n            shouldApplyStencil = true;\n            var _b = newMegaState.stencilBack, passOp = _b.passOp, failOp = _b.failOp, depthFailOp = _b.depthFailOp, compare = _b.compare;\n            if (currentMegaState.stencilBack.passOp !== passOp ||\n                currentMegaState.stencilBack.failOp !== failOp ||\n                currentMegaState.stencilBack.depthFailOp !== depthFailOp) {\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/stencilOpSeparate\n                gl.stencilOpSeparate(gl.BACK, failOp, depthFailOp, passOp);\n                currentMegaState.stencilBack.passOp = passOp;\n                currentMegaState.stencilBack.failOp = failOp;\n                currentMegaState.stencilBack.depthFailOp = depthFailOp;\n            }\n            if (currentMegaState.stencilBack.compare !== compare) {\n                this.setStencilReference(0);\n                currentMegaState.stencilBack.compare = compare;\n            }\n        }\n        if (currentMegaState.stencilFront.mask !== newMegaState.stencilFront.mask ||\n            currentMegaState.stencilBack.mask !== newMegaState.stencilBack.mask) {\n            shouldApplyStencil = true;\n            currentMegaState.stencilFront.mask = newMegaState.stencilFront.mask;\n            currentMegaState.stencilBack.mask = newMegaState.stencilBack.mask;\n        }\n        if (shouldApplyStencil) {\n            this.applyStencil();\n        }\n        if (currentMegaState.cullMode !== newMegaState.cullMode) {\n            if (currentMegaState.cullMode === exports.CullMode.NONE) {\n                gl.enable(gl.CULL_FACE);\n            }\n            else if (newMegaState.cullMode === exports.CullMode.NONE) {\n                gl.disable(gl.CULL_FACE);\n            }\n            if (newMegaState.cullMode === exports.CullMode.BACK) {\n                gl.cullFace(gl.BACK);\n            }\n            else if (newMegaState.cullMode === exports.CullMode.FRONT) {\n                gl.cullFace(gl.FRONT);\n            }\n            else if (newMegaState.cullMode === exports.CullMode.FRONT_AND_BACK) {\n                gl.cullFace(gl.FRONT_AND_BACK);\n            }\n            currentMegaState.cullMode = newMegaState.cullMode;\n        }\n        if (currentMegaState.frontFace !== newMegaState.frontFace) {\n            gl.frontFace(newMegaState.frontFace);\n            currentMegaState.frontFace = newMegaState.frontFace;\n        }\n        if (currentMegaState.polygonOffset !== newMegaState.polygonOffset) {\n            if (newMegaState.polygonOffset) {\n                gl.enable(gl.POLYGON_OFFSET_FILL);\n            }\n            else {\n                gl.disable(gl.POLYGON_OFFSET_FILL);\n            }\n            currentMegaState.polygonOffset = newMegaState.polygonOffset;\n        }\n        if (currentMegaState.polygonOffsetFactor !==\n            newMegaState.polygonOffsetFactor ||\n            currentMegaState.polygonOffsetUnits !== newMegaState.polygonOffsetUnits) {\n            gl.polygonOffset(newMegaState.polygonOffsetFactor, newMegaState.polygonOffsetUnits);\n            currentMegaState.polygonOffsetFactor = newMegaState.polygonOffsetFactor;\n            currentMegaState.polygonOffsetUnits = newMegaState.polygonOffsetUnits;\n        }\n    };\n    Device_GL.prototype.validatePipelineFormats = function (pipeline) {\n        for (var i = 0; i < this.currentColorAttachments.length; i++) {\n            var attachment = this.currentColorAttachments[i];\n            if (attachment === null)\n                continue;\n            // assert(attachment.format === pipeline.colorAttachmentFormats[i]);\n        }\n        if (this.currentDepthStencilAttachment) {\n            assert(this.currentDepthStencilAttachment.format ===\n                pipeline.depthStencilAttachmentFormat);\n        }\n        if (this.currentSampleCount !== -1) {\n            assert(this.currentSampleCount === pipeline.sampleCount);\n        }\n    };\n    Device_GL.prototype.setPipeline = function (o) {\n        var _this = this;\n        if (this.renderBundle) {\n            this.renderBundle.push(function () { return _this.setPipeline(o); });\n            return;\n        }\n        this.currentPipeline = o;\n        this.validatePipelineFormats(this.currentPipeline);\n        // We allow users to use \"non-ready\" pipelines for emergencies. In this case, there can be a bit of stuttering.\n        // assert(this.queryPipelineReady(this.currentPipeline));\n        this.setMegaState(this.currentPipeline.megaState);\n        var program = this.currentPipeline.program;\n        this.useProgram(program);\n        if (program.compileState === ProgramCompileState_GL.NeedsBind) {\n            var gl = this.gl;\n            var prog = program.gl_program;\n            var deviceProgram = program.descriptor;\n            var uniformBlocks = findall(deviceProgram.vertex.glsl, UNIFROM_BLOCK_REGEXP);\n            if (isWebGL2(gl)) {\n                for (var i = 0; i < uniformBlocks.length; i++) {\n                    var _a = tslib.__read(uniformBlocks[i], 2), blockName = _a[1];\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getUniformBlockIndex\n                    var blockIdx = gl.getUniformBlockIndex(prog, blockName);\n                    if (blockIdx !== -1 && blockIdx !== 0xffffffff) {\n                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/uniformBlockBinding\n                        gl.uniformBlockBinding(prog, blockIdx, i);\n                    }\n                }\n            }\n            var samplers = findall(deviceProgram.fragment.glsl, /^uniform .*sampler\\S+ (\\w+);\\s* \\/\\/ BINDING=(\\d+)$/gm);\n            for (var i = 0; i < samplers.length; i++) {\n                var _b = tslib.__read(samplers[i], 3), name_1 = _b[1], location_1 = _b[2];\n                var samplerUniformLocation = gl.getUniformLocation(prog, name_1);\n                gl.uniform1i(samplerUniformLocation, parseInt(location_1));\n            }\n            program.compileState = ProgramCompileState_GL.ReadyToUse;\n        }\n    };\n    Device_GL.prototype.setVertexInput = function (inputLayout_, vertexBuffers, indexBuffer) {\n        var e_1, _a;\n        var _this = this;\n        var _b;\n        if (this.renderBundle) {\n            this.renderBundle.push(function () {\n                return _this.setVertexInput(inputLayout_, vertexBuffers, indexBuffer);\n            });\n            return;\n        }\n        if (inputLayout_ !== null) {\n            assert(this.currentPipeline.inputLayout === inputLayout_);\n            var inputLayout = inputLayout_;\n            this.bindVAO(inputLayout.vao);\n            var gl = this.gl;\n            for (var i = 0; i < inputLayout.vertexBufferDescriptors.length; i++) {\n                var vertexBufferDescriptor = inputLayout.vertexBufferDescriptors[i];\n                var arrayStride = vertexBufferDescriptor.arrayStride, attributes = vertexBufferDescriptor.attributes;\n                try {\n                    for (var attributes_1 = (e_1 = void 0, tslib.__values(attributes)), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\n                        var attribute = attributes_1_1.value;\n                        var shaderLocation = attribute.shaderLocation, offset = attribute.offset;\n                        // find location by name in WebGL1\n                        var location_2 = isWebGL2(gl)\n                            ? shaderLocation\n                            : (_b = inputLayout.program.attributes[shaderLocation]) === null || _b === void 0 ? void 0 : _b.location;\n                        if (!util.isNil(location_2)) {\n                            var vertexBuffer = vertexBuffers[i];\n                            if (vertexBuffer === null)\n                                continue;\n                            // @ts-ignore\n                            var format = attribute.vertexFormat;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, getPlatformBuffer$1(vertexBuffer.buffer));\n                            var bufferOffset = (vertexBuffer.offset || 0) + offset;\n                            gl.vertexAttribPointer(location_2, format.size, format.type, format.normalized, arrayStride, bufferOffset);\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n            assert((indexBuffer !== null) === (inputLayout.indexBufferFormat !== null));\n            if (indexBuffer !== null) {\n                var buffer = indexBuffer.buffer;\n                assert(buffer.usage === exports.BufferUsage.INDEX);\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, getPlatformBuffer$1(buffer));\n                this.currentIndexBufferByteOffset = indexBuffer.offset || 0;\n            }\n            else {\n                this.currentIndexBufferByteOffset = null;\n            }\n        }\n        else {\n            assert(this.currentPipeline.inputLayout === null);\n            assert(indexBuffer === null);\n            this.bindVAO(null);\n            this.currentIndexBufferByteOffset = 0;\n        }\n    };\n    Device_GL.prototype.setStencilReference = function (value) {\n        if (this.currentStencilRef === value) {\n            return;\n        }\n        this.currentStencilRef = value;\n        this.applyStencil();\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpurendercommandsmixin-draw\n     */\n    Device_GL.prototype.draw = function (vertexCount, instanceCount, firstVertex, firstInstance) {\n        var _a;\n        var _this = this;\n        if (this.renderBundle) {\n            this.renderBundle.push(function () {\n                return _this.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n            });\n            return;\n        }\n        var gl = this.gl;\n        var pipeline = this.currentPipeline;\n        if (instanceCount) {\n            var params = [\n                pipeline.drawMode,\n                firstVertex || 0,\n                vertexCount,\n                instanceCount,\n            ];\n            if (isWebGL2(gl)) {\n                gl.drawArraysInstanced.apply(gl, tslib.__spreadArray([], tslib.__read(params), false));\n            }\n            else {\n                (_a = this.ANGLE_instanced_arrays).drawArraysInstancedANGLE.apply(_a, tslib.__spreadArray([], tslib.__read(params), false));\n            }\n        }\n        else {\n            gl.drawArrays(pipeline.drawMode, firstVertex, vertexCount);\n        }\n        this.debugGroupStatisticsDrawCall();\n        this.debugGroupStatisticsTriangles((vertexCount / 3) * Math.max(instanceCount, 1));\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpurendercommandsmixin-drawindexed\n     */\n    Device_GL.prototype.drawIndexed = function (indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {\n        var _a;\n        var _this = this;\n        if (this.renderBundle) {\n            this.renderBundle.push(function () {\n                return _this.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n            });\n            return;\n        }\n        var gl = this.gl;\n        var pipeline = this.currentPipeline, inputLayout = assertExists(pipeline.inputLayout);\n        var byteOffset = assertExists(this.currentIndexBufferByteOffset) +\n            firstIndex * inputLayout.indexBufferCompByteSize;\n        if (instanceCount) {\n            var params = [\n                pipeline.drawMode,\n                indexCount,\n                inputLayout.indexBufferType,\n                byteOffset,\n                instanceCount,\n            ];\n            if (isWebGL2(gl)) {\n                gl.drawElementsInstanced.apply(gl, tslib.__spreadArray([], tslib.__read(params), false));\n            }\n            else {\n                (_a = this.ANGLE_instanced_arrays).drawElementsInstancedANGLE.apply(_a, tslib.__spreadArray([], tslib.__read(params), false));\n            }\n        }\n        else {\n            gl.drawElements(pipeline.drawMode, indexCount, inputLayout.indexBufferType, byteOffset);\n        }\n        this.debugGroupStatisticsDrawCall();\n        this.debugGroupStatisticsTriangles((indexCount / 3) * Math.max(instanceCount, 1));\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpurendercommandsmixin-drawindirect\n     */\n    Device_GL.prototype.drawIndirect = function (indirectBuffer, indirectOffset) { };\n    Device_GL.prototype.drawIndexedIndirect = function (indirectBuffer, indirectOffset) { };\n    Device_GL.prototype.beginOcclusionQuery = function (queryIndex) {\n        var gl = this.gl;\n        if (isWebGL2(gl)) {\n            var queryPool = this.currentRenderPassDescriptor\n                .occlusionQueryPool;\n            gl.beginQuery(queryPool.gl_query_type, queryPool.gl_query[queryIndex]);\n        }\n    };\n    Device_GL.prototype.endOcclusionQuery = function () {\n        var gl = this.gl;\n        if (isWebGL2(gl)) {\n            var queryPool = this.currentRenderPassDescriptor\n                .occlusionQueryPool;\n            gl.endQuery(queryPool.gl_query_type);\n        }\n    };\n    Device_GL.prototype.pipelineQueryReady = function (o) {\n        var pipeline = o;\n        return this.queryProgramReady(pipeline.program);\n    };\n    Device_GL.prototype.pipelineForceReady = function (o) {\n        // No need to do anything; it will be forced to compile when used naturally.\n    };\n    Device_GL.prototype.endPass = function () {\n        var gl = this.gl;\n        var gl2 = isWebGL2(gl);\n        var skipBlit = this.currentColorResolveTos.length === 1 &&\n            this.currentColorResolveTos[0] === this.scTexture;\n        var didUnbindDraw = false;\n        for (var i = 0; i < this.currentColorAttachments.length; i++) {\n            var colorResolveFrom = this.currentColorAttachments[i];\n            if (colorResolveFrom !== null) {\n                var colorResolveTo = this.currentColorResolveTos[i];\n                var didBindRead = false;\n                if (colorResolveTo !== null) {\n                    assert(colorResolveFrom.width === colorResolveTo.width &&\n                        colorResolveFrom.height === colorResolveTo.height);\n                    // assert(colorResolveFrom.format === colorResolveTo.format);\n                    this.setScissorRectEnabled(false);\n                    if (!skipBlit) {\n                        if (gl2) {\n                            gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.resolveColorReadFramebuffer);\n                        }\n                        if (this.resolveColorAttachmentsChanged) {\n                            if (gl2) {\n                                this.bindFramebufferAttachment(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorResolveFrom, this.currentColorAttachmentLevels[i]);\n                            }\n                        }\n                    }\n                    didBindRead = true;\n                    if (!skipBlit) {\n                        // Special case: Blitting to the on-screen.\n                        if (colorResolveTo === this.scTexture) {\n                            gl.bindFramebuffer(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.scPlatformFramebuffer);\n                        }\n                        else {\n                            gl.bindFramebuffer(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.resolveColorDrawFramebuffer);\n                            if (this.resolveColorAttachmentsChanged)\n                                gl.framebufferTexture2D(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorResolveTo.gl_texture, this.currentColorResolveToLevels[i]);\n                        }\n                    }\n                    if (!skipBlit) {\n                        if (gl2) {\n                            gl.blitFramebuffer(0, 0, colorResolveFrom.width, colorResolveFrom.height, 0, 0, colorResolveTo.width, colorResolveTo.height, gl.COLOR_BUFFER_BIT, gl.LINEAR);\n                            gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n                        }\n                        else {\n                            // need an extra render pass in WebGL1\n                            this.submitBlitRenderPass(colorResolveFrom, colorResolveTo);\n                        }\n                    }\n                    didUnbindDraw = true;\n                }\n                if (!this.currentRenderPassDescriptor.colorStore[i]) {\n                    if (!skipBlit && !didBindRead) {\n                        gl.bindFramebuffer(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.resolveColorReadFramebuffer);\n                        if (this.resolveColorAttachmentsChanged)\n                            this.bindFramebufferAttachment(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorResolveFrom, this.currentColorAttachmentLevels[i]);\n                    }\n                    // if (gl2) {\n                    //   gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [\n                    //     gl.COLOR_ATTACHMENT0,\n                    //   ]);\n                    // }\n                }\n                if (!skipBlit) {\n                    gl.bindFramebuffer(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, null);\n                }\n            }\n        }\n        this.resolveColorAttachmentsChanged = false;\n        var depthStencilResolveFrom = this.currentDepthStencilAttachment;\n        if (depthStencilResolveFrom) {\n            var depthStencilResolveTo = this.currentDepthStencilResolveTo;\n            var didBindRead = false;\n            if (depthStencilResolveTo) {\n                assert(depthStencilResolveFrom.width === depthStencilResolveTo.width &&\n                    depthStencilResolveFrom.height === depthStencilResolveTo.height);\n                this.setScissorRectEnabled(false);\n                if (!skipBlit) {\n                    gl.bindFramebuffer(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.resolveDepthStencilReadFramebuffer);\n                    gl.bindFramebuffer(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.resolveDepthStencilDrawFramebuffer);\n                    if (this.resolveDepthStencilAttachmentsChanged) {\n                        this.bindFramebufferDepthStencilAttachment(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, depthStencilResolveFrom);\n                        this.bindFramebufferDepthStencilAttachment(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, depthStencilResolveTo);\n                    }\n                }\n                didBindRead = true;\n                if (!skipBlit) {\n                    if (gl2) {\n                        gl.blitFramebuffer(0, 0, depthStencilResolveFrom.width, depthStencilResolveFrom.height, 0, 0, depthStencilResolveTo.width, depthStencilResolveTo.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);\n                    }\n                    gl.bindFramebuffer(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, null);\n                }\n                didUnbindDraw = true;\n            }\n            if (!skipBlit && !this.currentRenderPassDescriptor.depthStencilStore) {\n                if (!didBindRead) {\n                    gl.bindFramebuffer(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, this.resolveDepthStencilReadFramebuffer);\n                    if (this.resolveDepthStencilAttachmentsChanged)\n                        this.bindFramebufferDepthStencilAttachment(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, depthStencilResolveFrom);\n                    didBindRead = true;\n                }\n                if (gl2) {\n                    gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, [\n                        gl.DEPTH_STENCIL_ATTACHMENT,\n                    ]);\n                }\n            }\n            if (!skipBlit && didBindRead)\n                gl.bindFramebuffer(gl2 ? exports.GL.READ_FRAMEBUFFER : exports.GL.FRAMEBUFFER, null);\n            this.resolveDepthStencilAttachmentsChanged = false;\n        }\n        if (!skipBlit && !didUnbindDraw) {\n            // If we did not unbind from a resolve, then we need to unbind our render pass draw FBO here.\n            gl.bindFramebuffer(gl2 ? exports.GL.DRAW_FRAMEBUFFER : exports.GL.FRAMEBUFFER, null);\n        }\n    };\n    Device_GL.prototype.setScissorRectEnabled = function (v) {\n        if (this.currentScissorEnabled === v) {\n            return;\n        }\n        var gl = this.gl;\n        if (v) {\n            gl.enable(gl.SCISSOR_TEST);\n        }\n        else {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n        this.currentScissorEnabled = v;\n    };\n    Device_GL.prototype.applyStencil = function () {\n        if (util.isNil(this.currentStencilRef)) {\n            return;\n        }\n        this.gl.stencilFuncSeparate(exports.GL.FRONT, this.currentMegaState.stencilFront.compare, this.currentStencilRef, this.currentMegaState.stencilFront.mask || 0xff);\n        this.gl.stencilFuncSeparate(exports.GL.BACK, this.currentMegaState.stencilBack.compare, this.currentStencilRef, this.currentMegaState.stencilBack.mask || 0xff);\n    };\n    Device_GL.prototype.getFallbackTexture = function (samplerEntry) {\n        var gl_target = samplerEntry.gl_target, formatKind = samplerEntry.formatKind;\n        if (gl_target === exports.GL.TEXTURE_2D)\n            return formatKind === exports.SamplerFormatKind.Depth\n                ? this.fallbackTexture2DDepth\n                : this.fallbackTexture2D;\n        else if (gl_target === exports.GL.TEXTURE_2D_ARRAY)\n            return this.fallbackTexture2DArray;\n        else if (gl_target === exports.GL.TEXTURE_3D)\n            return this.fallbackTexture3D;\n        else if (gl_target === exports.GL.TEXTURE_CUBE_MAP)\n            return this.fallbackTextureCube;\n        else\n            throw new Error('whoops');\n    };\n    Device_GL.prototype.submitBlitRenderPass = function (resolveFrom, resolveTo) {\n        if (!this.blitRenderPipeline) {\n            this.blitProgram = this.createProgram({\n                vertex: {\n                    glsl: \"layout(location = 0) in vec2 a_Position;\\nout vec2 v_TexCoord;\\nvoid main() {\\n  v_TexCoord = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n\\n  #ifdef VIEWPORT_ORIGIN_TL\\n    v_TexCoord.y = 1.0 - v_TexCoord.y;\\n  #endif\\n}\",\n                },\n                fragment: {\n                    glsl: \"uniform sampler2D u_Texture;\\nin vec2 v_TexCoord;\\nout vec4 outputColor;\\nvoid main() {\\n  outputColor = texture(SAMPLER_2D(u_Texture), v_TexCoord);\\n}\",\n                },\n            });\n            this.blitVertexBuffer = this.createBuffer({\n                usage: exports.BufferUsage.VERTEX | exports.BufferUsage.COPY_DST,\n                viewOrSize: new Float32Array([-4, -4, 4, -4, 0, 4]),\n            });\n            this.blitInputLayout = this.createInputLayout({\n                vertexBufferDescriptors: [\n                    {\n                        arrayStride: 4 * 2,\n                        stepMode: exports.VertexStepMode.VERTEX,\n                        attributes: [\n                            {\n                                format: exports.Format.F32_RG,\n                                offset: 4 * 0,\n                                shaderLocation: 0,\n                            },\n                        ],\n                    },\n                ],\n                indexBufferFormat: null,\n                program: this.blitProgram,\n            });\n            this.blitRenderPipeline = this.createRenderPipeline({\n                topology: exports.PrimitiveTopology.TRIANGLES,\n                sampleCount: 1,\n                program: this.blitProgram,\n                colorAttachmentFormats: [exports.Format.U8_RGBA_RT],\n                depthStencilAttachmentFormat: null,\n                inputLayout: this.blitInputLayout,\n                megaStateDescriptor: copyMegaState(defaultMegaState),\n            });\n            this.blitBindings = this.createBindings({\n                samplerBindings: [\n                    {\n                        sampler: null,\n                        texture: resolveFrom.texture,\n                    },\n                ],\n                uniformBufferBindings: [],\n            });\n            this.blitProgram.setUniformsLegacy({\n                u_Texture: resolveFrom,\n            });\n        }\n        // save currentRenderPassDescriptor since we're already in a render pass\n        var currentRenderPassDescriptor = this.currentRenderPassDescriptor;\n        this.currentRenderPassDescriptor = null;\n        this.inBlitRenderPass = true;\n        var blitRenderPass = this.createRenderPass({\n            colorAttachment: [resolveFrom],\n            colorResolveTo: [resolveTo],\n            colorClearColor: [TransparentWhite],\n        });\n        var _a = this.getCanvas(), width = _a.width, height = _a.height;\n        blitRenderPass.setPipeline(this.blitRenderPipeline);\n        blitRenderPass.setBindings(this.blitBindings);\n        blitRenderPass.setVertexInput(this.blitInputLayout, [{ buffer: this.blitVertexBuffer }], null);\n        blitRenderPass.setViewport(0, 0, width, height);\n        // disable blending for blit\n        this.gl.disable(this.gl.BLEND);\n        blitRenderPass.draw(3, 0);\n        this.gl.enable(this.gl.BLEND);\n        // restore\n        this.currentRenderPassDescriptor = currentRenderPassDescriptor;\n        this.inBlitRenderPass = false;\n    };\n    return Device_GL;\n}());\n\nvar WebGLDeviceContribution = /** @class */ (function () {\n    function WebGLDeviceContribution(pluginOptions) {\n        this.pluginOptions = pluginOptions;\n    }\n    WebGLDeviceContribution.prototype.createSwapChain = function ($canvas) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var _a, targets, xrCompatible, _b, antialias, _c, preserveDrawingBuffer, _d, premultipliedAlpha, shaderDebug, trackResources, options, gl;\n            return tslib.__generator(this, function (_e) {\n                _a = this.pluginOptions, targets = _a.targets, xrCompatible = _a.xrCompatible, _b = _a.antialias, antialias = _b === void 0 ? false : _b, _c = _a.preserveDrawingBuffer, preserveDrawingBuffer = _c === void 0 ? false : _c, _d = _a.premultipliedAlpha, premultipliedAlpha = _d === void 0 ? true : _d, shaderDebug = _a.shaderDebug, trackResources = _a.trackResources;\n                options = {\n                    // alpha: true,\n                    antialias: antialias,\n                    // @see https://stackoverflow.com/questions/27746091/preservedrawingbuffer-false-is-it-worth-the-effort\n                    preserveDrawingBuffer: preserveDrawingBuffer,\n                    // @see https://webglfundamentals.org/webgl/lessons/webgl-qna-how-to-use-the-stencil-buffer.html\n                    stencil: true,\n                    // @see https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html\n                    premultipliedAlpha: premultipliedAlpha,\n                    xrCompatible: xrCompatible,\n                };\n                this.handleContextEvents($canvas);\n                if (targets.includes('webgl2')) {\n                    gl =\n                        $canvas.getContext('webgl2', options) ||\n                            $canvas.getContext('experimental-webgl2', options);\n                }\n                if (!gl && targets.includes('webgl1')) {\n                    gl =\n                        $canvas.getContext('webgl', options) ||\n                            $canvas.getContext('experimental-webgl', options);\n                }\n                return [2 /*return*/, new Device_GL(gl, {\n                        shaderDebug: shaderDebug,\n                        trackResources: trackResources,\n                    })];\n            });\n        });\n    };\n    WebGLDeviceContribution.prototype.handleContextEvents = function ($canvas) {\n        var _a = this.pluginOptions, onContextLost = _a.onContextLost, onContextRestored = _a.onContextRestored, onContextCreationError = _a.onContextCreationError;\n        // bind context event listeners\n        if (onContextCreationError) {\n            // @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/webglcontextcreationerror_event\n            $canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);\n        }\n        if (onContextLost) {\n            $canvas.addEventListener('webglcontextlost', onContextLost, false);\n        }\n        if (onContextRestored) {\n            $canvas.addEventListener('webglcontextrestored', onContextRestored, false);\n        }\n    };\n    return WebGLDeviceContribution;\n}());\n\nlet wasm;\n\nconst cachedTextDecoder =\n  typeof TextDecoder !== 'undefined'\n    ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true })\n    : {\n        decode: () => {\n          throw Error('TextDecoder not available');\n        },\n      };\n\nif (typeof TextDecoder !== 'undefined') {\n  cachedTextDecoder.decode();\n}\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length) heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n\n  heap[idx] = obj;\n  return idx;\n}\n\nfunction getObject(idx) {\n  return heap[idx];\n}\n\nfunction dropObject(idx) {\n  if (idx < 132) return;\n  heap[idx] = heap_next;\n  heap_next = idx;\n}\n\nfunction takeObject(idx) {\n  const ret = getObject(idx);\n  dropObject(idx);\n  return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder =\n  typeof TextEncoder !== 'undefined'\n    ? new TextEncoder('utf-8')\n    : {\n        encode: () => {\n          throw Error('TextEncoder not available');\n        },\n      };\n\nconst encodeString =\n  typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n        return cachedTextEncoder.encodeInto(arg, view);\n      }\n    : function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n          read: arg.length,\n          written: buf.length,\n        };\n      };\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length, 1) >>> 0;\n    getUint8Memory0()\n      .subarray(ptr, ptr + buf.length)\n      .set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n\n  let len = arg.length;\n  let ptr = malloc(len, 1) >>> 0;\n\n  const mem = getUint8Memory0();\n\n  let offset = 0;\n\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7f) break;\n    mem[ptr + offset] = code;\n  }\n\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, (len = offset + arg.length * 3), 1) >>> 0;\n    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n\n    offset += ret.written;\n  }\n\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\n/**\n * @param {string} source\n * @param {string} stage\n * @param {boolean} validation_enabled\n * @returns {string}\n */\nfunction glsl_compile(source, stage, validation_enabled) {\n  let deferred3_0;\n  let deferred3_1;\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    const ptr0 = passStringToWasm0(\n      source,\n      wasm.__wbindgen_malloc,\n      wasm.__wbindgen_realloc,\n    );\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passStringToWasm0(\n      stage,\n      wasm.__wbindgen_malloc,\n      wasm.__wbindgen_realloc,\n    );\n    const len1 = WASM_VECTOR_LEN;\n    wasm.glsl_compile(retptr, ptr0, len0, ptr1, len1, validation_enabled);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    deferred3_0 = r0;\n    deferred3_1 = r1;\n    return getStringFromWasm0(r0, r1);\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n    wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n  }\n}\n\n/**\n */\nclass WGSLComposer {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(WGSLComposer.prototype);\n    obj.__wbg_ptr = ptr;\n\n    return obj;\n  }\n\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n\n    return ptr;\n  }\n\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_wgslcomposer_free(ptr);\n  }\n  /**\n   */\n  constructor() {\n    const ret = wasm.wgslcomposer_new();\n    return WGSLComposer.__wrap(ret);\n  }\n  /**\n   * @param {string} source\n   */\n  load_composable(source) {\n    const ptr0 = passStringToWasm0(\n      source,\n      wasm.__wbindgen_malloc,\n      wasm.__wbindgen_realloc,\n    );\n    const len0 = WASM_VECTOR_LEN;\n    wasm.wgslcomposer_load_composable(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * @param {string} source\n   * @returns {string}\n   */\n  wgsl_compile(source) {\n    let deferred2_0;\n    let deferred2_1;\n    try {\n      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n      const ptr0 = passStringToWasm0(\n        source,\n        wasm.__wbindgen_malloc,\n        wasm.__wbindgen_realloc,\n      );\n      const len0 = WASM_VECTOR_LEN;\n      wasm.wgslcomposer_wgsl_compile(retptr, this.__wbg_ptr, ptr0, len0);\n      var r0 = getInt32Memory0()[retptr / 4 + 0];\n      var r1 = getInt32Memory0()[retptr / 4 + 1];\n      deferred2_0 = r0;\n      deferred2_1 = r1;\n      return getStringFromWasm0(r0, r1);\n    } finally {\n      wasm.__wbindgen_add_to_stack_pointer(16);\n      wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n    }\n  }\n}\n\nasync function __wbg_load(module, imports) {\n  if (typeof Response === 'function' && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === 'function') {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get('Content-Type') != 'application/wasm') {\n          console.warn(\n            '`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n',\n            e,\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\n\nfunction __wbg_get_imports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n  };\n  imports.wbg.__wbindgen_object_drop_ref = function (arg0) {\n    takeObject(arg0);\n  };\n  imports.wbg.__wbg_log_1d3ae0273d8f4f8a = function (arg0) {\n    console.log(getObject(arg0));\n  };\n  imports.wbg.__wbg_log_576ca876af0d4a77 = function (arg0, arg1) {\n    console.log(getObject(arg0), getObject(arg1));\n  };\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n\n  return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  __wbg_init.__wbindgen_wasm_module = module;\n  cachedInt32Memory0 = null;\n  cachedUint8Memory0 = null;\n\n  return wasm;\n}\n\nasync function __wbg_init(input) {\n  if (wasm !== undefined) return wasm;\n  const imports = __wbg_get_imports();\n\n  if (\n    typeof input === 'string' ||\n    (typeof Request === 'function' && input instanceof Request) ||\n    (typeof URL === 'function' && input instanceof URL)\n  ) {\n    input = fetch(input);\n  }\n\n  const { instance, module } = await __wbg_load(await input, imports);\n\n  return __wbg_finalize_init(instance, module);\n}\n\n/**\n * @see https://github.com/gpuweb/cts/blob/main/src/webgpu/constants.ts\n */\nvar GPUTextureUsage$1;\n(function (GPUTextureUsage) {\n    GPUTextureUsage[GPUTextureUsage[\"COPY_SRC\"] = 1] = \"COPY_SRC\";\n    GPUTextureUsage[GPUTextureUsage[\"COPY_DST\"] = 2] = \"COPY_DST\";\n    GPUTextureUsage[GPUTextureUsage[\"TEXTURE_BINDING\"] = 4] = \"TEXTURE_BINDING\";\n    // SAMPLED= 0x04,\n    GPUTextureUsage[GPUTextureUsage[\"STORAGE_BINDING\"] = 8] = \"STORAGE_BINDING\";\n    GPUTextureUsage[GPUTextureUsage[\"STORAGE\"] = 8] = \"STORAGE\";\n    GPUTextureUsage[GPUTextureUsage[\"RENDER_ATTACHMENT\"] = 16] = \"RENDER_ATTACHMENT\";\n})(GPUTextureUsage$1 || (GPUTextureUsage$1 = {}));\n// @see https://www.w3.org/TR/webgpu/#typedefdef-gpumapmodeflags\nvar GPUMapMode;\n(function (GPUMapMode) {\n    GPUMapMode[GPUMapMode[\"READ\"] = 1] = \"READ\";\n    GPUMapMode[GPUMapMode[\"WRITE\"] = 2] = \"WRITE\";\n})(GPUMapMode || (GPUMapMode = {}));\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/GPUTexture/usage#value\n */\nfunction translateTextureUsage(usage) {\n    var gpuUsage = 0;\n    if (usage & exports.TextureUsage.SAMPLED)\n        gpuUsage |=\n            GPUTextureUsage$1.TEXTURE_BINDING |\n                GPUTextureUsage$1.COPY_DST |\n                GPUTextureUsage$1.COPY_SRC;\n    if (usage & exports.TextureUsage.STORAGE)\n        gpuUsage |=\n            GPUTextureUsage$1.TEXTURE_BINDING |\n                GPUTextureUsage$1.STORAGE_BINDING |\n                GPUTextureUsage$1.COPY_SRC |\n                GPUTextureUsage$1.COPY_DST;\n    if (usage & exports.TextureUsage.RENDER_TARGET)\n        gpuUsage |=\n            GPUTextureUsage$1.RENDER_ATTACHMENT |\n                GPUTextureUsage$1.TEXTURE_BINDING |\n                GPUTextureUsage$1.COPY_SRC |\n                GPUTextureUsage$1.COPY_DST;\n    return gpuUsage;\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gputextureformat\n */\nfunction translateTextureFormat(format) {\n    // 8-bit formats\n    if (format === exports.Format.U8_R_NORM)\n        return 'r8unorm';\n    else if (format === exports.Format.S8_R_NORM)\n        return 'r8snorm';\n    // 16-bit formats\n    else if (format === exports.Format.U8_RG_NORM)\n        return 'rg8unorm';\n    else if (format === exports.Format.S8_RG_NORM)\n        return 'rg8snorm';\n    // 32-bit formats\n    else if (format === exports.Format.U32_R)\n        return 'r32uint';\n    else if (format === exports.Format.S32_R)\n        return 'r32sint';\n    else if (format === exports.Format.F32_R)\n        return 'r32float';\n    else if (format === exports.Format.U16_RG)\n        return 'rg16uint';\n    else if (format === exports.Format.S16_RG)\n        return 'rg16sint';\n    else if (format === exports.Format.F16_RG)\n        return 'rg16float';\n    else if (format === exports.Format.U8_RGBA_RT)\n        return 'bgra8unorm';\n    else if (format === exports.Format.U8_RGBA_RT_SRGB)\n        return 'bgra8unorm-srgb';\n    else if (format === exports.Format.U8_RGBA_NORM)\n        return 'rgba8unorm';\n    else if (format === exports.Format.U8_RGBA_SRGB)\n        return 'rgba8unorm-srgb';\n    else if (format === exports.Format.S8_RGBA_NORM)\n        return 'rgba8snorm';\n    // 64-bit formats\n    else if (format === exports.Format.U32_RG)\n        return 'rg32uint';\n    else if (format === exports.Format.S32_RG)\n        return 'rg32sint';\n    else if (format === exports.Format.F32_RG)\n        return 'rg32float';\n    else if (format === exports.Format.U16_RGBA)\n        return 'rgba16uint';\n    else if (format === exports.Format.S16_RGBA)\n        return 'rgba16sint';\n    else if (format === exports.Format.F16_RGBA)\n        return 'rgba16float';\n    // 128-bit formats\n    else if (format === exports.Format.F32_RGBA)\n        return 'rgba32float';\n    else if (format === exports.Format.U32_RGBA)\n        return 'rgba32uint';\n    else if (format === exports.Format.S32_RGBA)\n        return 'rgba32sint';\n    // depth stencil formats\n    else if (format === exports.Format.D24)\n        return 'depth24plus';\n    else if (format === exports.Format.D24_S8)\n        return 'depth24plus-stencil8';\n    else if (format === exports.Format.D32F)\n        return 'depth32float';\n    else if (format === exports.Format.D32F_S8)\n        return 'depth32float-stencil8';\n    // bc\n    else if (format === exports.Format.BC1)\n        return 'bc1-rgba-unorm';\n    else if (format === exports.Format.BC1_SRGB)\n        return 'bc1-rgba-unorm-srgb';\n    else if (format === exports.Format.BC2)\n        return 'bc2-rgba-unorm';\n    else if (format === exports.Format.BC2_SRGB)\n        return 'bc2-rgba-unorm-srgb';\n    else if (format === exports.Format.BC3)\n        return 'bc3-rgba-unorm';\n    else if (format === exports.Format.BC3_SRGB)\n        return 'bc3-rgba-unorm-srgb';\n    else if (format === exports.Format.BC4_SNORM)\n        return 'bc4-r-snorm';\n    else if (format === exports.Format.BC4_UNORM)\n        return 'bc4-r-unorm';\n    else if (format === exports.Format.BC5_SNORM)\n        return 'bc5-rg-snorm';\n    else if (format === exports.Format.BC5_UNORM)\n        return 'bc5-rg-unorm';\n    else\n        throw 'whoops';\n}\nfunction translateTextureDimension(dimension) {\n    if (dimension === exports.TextureDimension.TEXTURE_2D)\n        return '2d';\n    else if (dimension === exports.TextureDimension.TEXTURE_CUBE_MAP)\n        return '2d';\n    else if (dimension === exports.TextureDimension.TEXTURE_2D_ARRAY)\n        return '2d';\n    else if (dimension === exports.TextureDimension.TEXTURE_3D)\n        return '3d';\n    else\n        throw new Error('whoops');\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gputextureviewdimension\n */\nfunction translateTextureViewDimension(dimension) {\n    if (dimension === exports.TextureDimension.TEXTURE_2D)\n        return '2d';\n    else if (dimension === exports.TextureDimension.TEXTURE_CUBE_MAP)\n        return 'cube';\n    else if (dimension === exports.TextureDimension.TEXTURE_2D_ARRAY)\n        return '2d-array';\n    else if (dimension === exports.TextureDimension.TEXTURE_3D)\n        return '3d';\n    else\n        throw new Error('whoops');\n}\nfunction translateBufferUsage(usage_) {\n    var usage = 0;\n    if (usage_ & exports.BufferUsage.INDEX)\n        usage |= GPUBufferUsage.INDEX;\n    if (usage_ & exports.BufferUsage.VERTEX)\n        usage |= GPUBufferUsage.VERTEX;\n    if (usage_ & exports.BufferUsage.UNIFORM)\n        usage |= GPUBufferUsage.UNIFORM;\n    if (usage_ & exports.BufferUsage.STORAGE)\n        usage |= GPUBufferUsage.STORAGE;\n    if (usage_ & exports.BufferUsage.COPY_SRC)\n        usage |= GPUBufferUsage.COPY_SRC;\n    if (usage_ & exports.BufferUsage.INDIRECT)\n        usage |= GPUBufferUsage.INDIRECT;\n    usage |= GPUBufferUsage.COPY_DST;\n    return usage;\n}\nfunction translateAddressMode(wrapMode) {\n    if (wrapMode === exports.AddressMode.CLAMP_TO_EDGE)\n        return 'clamp-to-edge';\n    else if (wrapMode === exports.AddressMode.REPEAT)\n        return 'repeat';\n    else if (wrapMode === exports.AddressMode.MIRRORED_REPEAT)\n        return 'mirror-repeat';\n    else\n        throw new Error('whoops');\n}\nfunction translateMinMagFilter(texFilter) {\n    if (texFilter === exports.FilterMode.BILINEAR)\n        return 'linear';\n    else if (texFilter === exports.FilterMode.POINT)\n        return 'nearest';\n    else\n        throw new Error('whoops');\n}\n// @see https://www.w3.org/TR/webgpu/#enumdef-gpumipmapfiltermode\nfunction translateMipFilter(mipmapFilter) {\n    if (mipmapFilter === exports.MipmapFilterMode.LINEAR)\n        return 'linear';\n    else if (mipmapFilter === exports.MipmapFilterMode.NEAREST)\n        return 'nearest';\n    else if (mipmapFilter === exports.MipmapFilterMode.NO_MIP)\n        return 'nearest';\n    else\n        throw new Error('whoops');\n}\nfunction getPlatformBuffer(buffer_) {\n    var buffer = buffer_;\n    return buffer.gpuBuffer;\n}\nfunction getPlatformSampler(sampler_) {\n    var sampler = sampler_;\n    return sampler.gpuSampler;\n}\nfunction getPlatformQuerySet(queryPool_) {\n    var queryPool = queryPool_;\n    return queryPool.querySet;\n}\nfunction translateQueryPoolType(type) {\n    if (type === exports.QueryPoolType.OcclusionConservative)\n        return 'occlusion';\n    else\n        throw new Error('whoops');\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#primitive-state\n */\nfunction translateTopology(topology) {\n    switch (topology) {\n        case exports.PrimitiveTopology.TRIANGLES:\n            return 'triangle-list';\n        case exports.PrimitiveTopology.POINTS:\n            return 'point-list';\n        case exports.PrimitiveTopology.TRIANGLE_STRIP:\n            return 'triangle-strip';\n        case exports.PrimitiveTopology.LINES:\n            return 'line-list';\n        case exports.PrimitiveTopology.LINE_STRIP:\n            return 'line-strip';\n        default:\n            throw new Error('Unknown primitive topology mode');\n    }\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpucullmode\n */\nfunction translateCullMode(cullMode) {\n    if (cullMode === exports.CullMode.NONE)\n        return 'none';\n    else if (cullMode === exports.CullMode.FRONT)\n        return 'front';\n    else if (cullMode === exports.CullMode.BACK)\n        return 'back';\n    else\n        throw new Error('whoops');\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpufrontface\n */\nfunction translateFrontFace(frontFaceMode) {\n    if (frontFaceMode === exports.FrontFace.CCW)\n        return 'ccw';\n    else if (frontFaceMode === exports.FrontFace.CW)\n        return 'cw';\n    else\n        throw new Error('whoops');\n}\nfunction translatePrimitiveState(topology, megaStateDescriptor) {\n    return {\n        topology: translateTopology(topology),\n        cullMode: translateCullMode(megaStateDescriptor.cullMode),\n        frontFace: translateFrontFace(megaStateDescriptor.frontFace),\n    };\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpublendfactor\n */\nfunction translateBlendFactor(factor) {\n    if (factor === exports.BlendFactor.ZERO)\n        return 'zero';\n    else if (factor === exports.BlendFactor.ONE)\n        return 'one';\n    else if (factor === exports.BlendFactor.SRC)\n        return 'src';\n    else if (factor === exports.BlendFactor.ONE_MINUS_SRC)\n        return 'one-minus-src';\n    else if (factor === exports.BlendFactor.DST)\n        return 'dst';\n    else if (factor === exports.BlendFactor.ONE_MINUS_DST)\n        return 'one-minus-dst';\n    else if (factor === exports.BlendFactor.SRC_ALPHA)\n        return 'src-alpha';\n    else if (factor === exports.BlendFactor.ONE_MINUS_SRC_ALPHA)\n        return 'one-minus-src-alpha';\n    else if (factor === exports.BlendFactor.DST_ALPHA)\n        return 'dst-alpha';\n    else if (factor === exports.BlendFactor.ONE_MINUS_DST_ALPHA)\n        return 'one-minus-dst-alpha';\n    else if (factor === exports.BlendFactor.CONST)\n        return 'constant';\n    else if (factor === exports.BlendFactor.ONE_MINUS_CONSTANT)\n        return 'one-minus-constant';\n    else if (factor === exports.BlendFactor.SRC_ALPHA_SATURATE)\n        return 'src-alpha-saturated';\n    else\n        throw new Error('whoops');\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#enumdef-gpublendoperation\n */\nfunction translateBlendMode(mode) {\n    if (mode === exports.BlendMode.ADD)\n        return 'add';\n    else if (mode === exports.BlendMode.SUBSTRACT)\n        return 'subtract';\n    else if (mode === exports.BlendMode.REVERSE_SUBSTRACT)\n        return 'reverse-subtract';\n    else if (mode === exports.BlendMode.MIN)\n        return 'min';\n    else if (mode === exports.BlendMode.MAX)\n        return 'max';\n    else\n        throw new Error('whoops');\n}\nfunction translateBlendComponent(ch) {\n    return {\n        operation: translateBlendMode(ch.blendMode),\n        srcFactor: translateBlendFactor(ch.blendSrcFactor),\n        dstFactor: translateBlendFactor(ch.blendDstFactor),\n    };\n}\nfunction blendComponentIsNil(ch) {\n    return (ch.blendMode === exports.BlendMode.ADD &&\n        ch.blendSrcFactor === exports.BlendFactor.ONE &&\n        ch.blendDstFactor === exports.BlendFactor.ZERO);\n}\nfunction translateBlendState(attachmentState) {\n    if (blendComponentIsNil(attachmentState.rgbBlendState) &&\n        blendComponentIsNil(attachmentState.alphaBlendState)) {\n        return undefined;\n    }\n    else {\n        return {\n            color: translateBlendComponent(attachmentState.rgbBlendState),\n            alpha: translateBlendComponent(attachmentState.alphaBlendState),\n        };\n    }\n}\nfunction translateColorState(attachmentState, format) {\n    return {\n        format: translateTextureFormat(format),\n        blend: translateBlendState(attachmentState),\n        writeMask: attachmentState.channelWriteMask,\n    };\n}\nfunction translateTargets(colorAttachmentFormats, megaStateDescriptor) {\n    return megaStateDescriptor.attachmentsState.map(function (attachmentState, i) {\n        return translateColorState(attachmentState, colorAttachmentFormats[i]);\n    });\n}\n// @see https://www.w3.org/TR/webgpu/#enumdef-gpucomparefunction\nfunction translateCompareFunction(compareFunction) {\n    if (compareFunction === exports.CompareFunction.NEVER)\n        return 'never';\n    else if (compareFunction === exports.CompareFunction.LESS)\n        return 'less';\n    else if (compareFunction === exports.CompareFunction.EQUAL)\n        return 'equal';\n    else if (compareFunction === exports.CompareFunction.LEQUAL)\n        return 'less-equal';\n    else if (compareFunction === exports.CompareFunction.GREATER)\n        return 'greater';\n    else if (compareFunction === exports.CompareFunction.NOTEQUAL)\n        return 'not-equal';\n    else if (compareFunction === exports.CompareFunction.GEQUAL)\n        return 'greater-equal';\n    else if (compareFunction === exports.CompareFunction.ALWAYS)\n        return 'always';\n    else\n        throw new Error('whoops');\n}\nfunction translateStencilOperation(stencilOp) {\n    if (stencilOp === exports.StencilOp.KEEP)\n        return 'keep';\n    else if (stencilOp === exports.StencilOp.REPLACE)\n        return 'replace';\n    else if (stencilOp === exports.StencilOp.ZERO)\n        return 'zero';\n    else if (stencilOp === exports.StencilOp.DECREMENT_CLAMP)\n        return 'decrement-clamp';\n    else if (stencilOp === exports.StencilOp.DECREMENT_WRAP)\n        return 'decrement-wrap';\n    else if (stencilOp === exports.StencilOp.INCREMENT_CLAMP)\n        return 'increment-clamp';\n    else if (stencilOp === exports.StencilOp.INCREMENT_WRAP)\n        return 'increment-wrap';\n    else if (stencilOp === exports.StencilOp.INVERT)\n        return 'invert';\n    else\n        throw new Error('whoops');\n}\n/**\n * @see https://www.w3.org/TR/webgpu/#dictdef-gpudepthstencilstate\n */\nfunction translateDepthStencilState(format, megaStateDescriptor) {\n    if (util.isNil(format))\n        return undefined;\n    return {\n        /**\n         * @see https://www.w3.org/TR/webgpu/#dom-gpudepthstencilstate-format\n         */\n        format: translateTextureFormat(format),\n        depthWriteEnabled: !!megaStateDescriptor.depthWrite,\n        depthCompare: translateCompareFunction(megaStateDescriptor.depthCompare),\n        depthBias: megaStateDescriptor.polygonOffset\n            ? megaStateDescriptor.polygonOffsetUnits\n            : 0,\n        depthBiasSlopeScale: megaStateDescriptor.polygonOffset\n            ? megaStateDescriptor.polygonOffsetFactor\n            : 0,\n        stencilFront: {\n            compare: translateCompareFunction(megaStateDescriptor.stencilFront.compare),\n            passOp: translateStencilOperation(megaStateDescriptor.stencilFront.passOp),\n            failOp: translateStencilOperation(megaStateDescriptor.stencilFront.failOp),\n            depthFailOp: translateStencilOperation(megaStateDescriptor.stencilFront.depthFailOp),\n        },\n        stencilBack: {\n            compare: translateCompareFunction(megaStateDescriptor.stencilBack.compare),\n            passOp: translateStencilOperation(megaStateDescriptor.stencilBack.passOp),\n            failOp: translateStencilOperation(megaStateDescriptor.stencilBack.failOp),\n            depthFailOp: translateStencilOperation(megaStateDescriptor.stencilBack.depthFailOp),\n        },\n        stencilReadMask: 0xffffffff,\n        stencilWriteMask: 0xffffffff,\n        // stencilReadMask: 0xffffffff,\n        // stencilWriteMask: megaStateDescriptor.stencilWrite ? 0xff : 0x00,\n    };\n}\nfunction translateIndexFormat(format) {\n    if (format === null)\n        return undefined;\n    else if (format === exports.Format.U16_R)\n        return 'uint16';\n    else if (format === exports.Format.U32_R)\n        return 'uint32';\n    else\n        throw new Error('whoops');\n}\nfunction translateVertexStepMode(stepMode) {\n    if (stepMode === exports.VertexStepMode.VERTEX)\n        return 'vertex';\n    else if (stepMode === exports.VertexStepMode.INSTANCE)\n        return 'instance';\n    else\n        throw new Error('whoops');\n}\nfunction translateVertexFormat(format) {\n    if (format === exports.Format.U8_R)\n        return 'uint8x2';\n    else if (format === exports.Format.U8_RG)\n        return 'uint8x2';\n    else if (format === exports.Format.U8_RGB)\n        return 'uint8x4';\n    else if (format === exports.Format.U8_RGBA)\n        return 'uint8x4';\n    else if (format === exports.Format.U8_RG_NORM)\n        return 'unorm8x2';\n    else if (format === exports.Format.U8_RGBA_NORM)\n        return 'unorm8x4';\n    else if (format === exports.Format.S8_RGB_NORM)\n        return 'snorm8x4';\n    else if (format === exports.Format.S8_RGBA_NORM)\n        return 'snorm8x4';\n    else if (format === exports.Format.U16_RG_NORM)\n        return 'unorm16x2';\n    else if (format === exports.Format.U16_RGBA_NORM)\n        return 'unorm16x4';\n    else if (format === exports.Format.S16_RG_NORM)\n        return 'snorm16x2';\n    else if (format === exports.Format.S16_RGBA_NORM)\n        return 'snorm16x4';\n    else if (format === exports.Format.S16_RG)\n        return 'uint16x2';\n    else if (format === exports.Format.F16_RG)\n        return 'float16x2';\n    else if (format === exports.Format.F16_RGBA)\n        return 'float16x4';\n    else if (format === exports.Format.F32_R)\n        return 'float32';\n    else if (format === exports.Format.F32_RG)\n        return 'float32x2';\n    else if (format === exports.Format.F32_RGB)\n        return 'float32x3';\n    else if (format === exports.Format.F32_RGBA)\n        return 'float32x4';\n    else\n        throw 'whoops';\n}\nfunction isFormatTextureCompressionBC(format) {\n    var formatTypeFlags = getFormatTypeFlags(format);\n    switch (formatTypeFlags) {\n        case exports.FormatTypeFlags.BC1:\n        case exports.FormatTypeFlags.BC2:\n        case exports.FormatTypeFlags.BC3:\n        case exports.FormatTypeFlags.BC4_SNORM:\n        case exports.FormatTypeFlags.BC4_UNORM:\n        case exports.FormatTypeFlags.BC5_SNORM:\n        case exports.FormatTypeFlags.BC5_UNORM:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getFormatBlockSize(format) {\n    var formatTypeFlags = getFormatTypeFlags(format);\n    switch (formatTypeFlags) {\n        case exports.FormatTypeFlags.BC1:\n        case exports.FormatTypeFlags.BC2:\n        case exports.FormatTypeFlags.BC3:\n        case exports.FormatTypeFlags.BC4_SNORM:\n        case exports.FormatTypeFlags.BC4_UNORM:\n        case exports.FormatTypeFlags.BC5_SNORM:\n        case exports.FormatTypeFlags.BC5_UNORM:\n            return 4;\n        default:\n            return 1;\n    }\n}\nfunction allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes, copyBuffer) {\n    if (sizeInBytes === void 0) { sizeInBytes = false; }\n    switch (type) {\n        case exports.Format.S8_R:\n        case exports.Format.S8_R_NORM:\n        case exports.Format.S8_RG_NORM:\n        case exports.Format.S8_RGB_NORM:\n        case exports.Format.S8_RGBA_NORM: {\n            var buffer_1 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Int8Array(sizeOrDstBuffer)\n                : new Int8Array(sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_1.set(new Int8Array(copyBuffer));\n            }\n            return buffer_1;\n        }\n        case exports.Format.U8_R:\n        case exports.Format.U8_R_NORM:\n        case exports.Format.U8_RG:\n        case exports.Format.U8_RG_NORM:\n        case exports.Format.U8_RGB:\n        case exports.Format.U8_RGB_NORM:\n        case exports.Format.U8_RGB_SRGB:\n        case exports.Format.U8_RGBA:\n        case exports.Format.U8_RGBA_NORM:\n        case exports.Format.U8_RGBA_SRGB: {\n            var buffer_2 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Uint8Array(sizeOrDstBuffer)\n                : new Uint8Array(sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_2.set(new Uint8Array(copyBuffer));\n            }\n            return buffer_2;\n        }\n        case exports.Format.S16_R:\n        case exports.Format.S16_RG:\n        case exports.Format.S16_RG_NORM:\n        case exports.Format.S16_RGB_NORM:\n        case exports.Format.S16_RGBA:\n        case exports.Format.S16_RGBA_NORM: {\n            var buffer_3 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Int16Array(sizeOrDstBuffer)\n                : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_3.set(new Int16Array(copyBuffer));\n            }\n            return buffer_3;\n        }\n        case exports.Format.U16_R:\n        case exports.Format.U16_RGB:\n        case exports.Format.U16_RGBA_5551:\n        case exports.Format.U16_RGBA_NORM:\n        case exports.Format.U16_RG_NORM:\n        case exports.Format.U16_R_NORM: {\n            var buffer_4 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Uint16Array(sizeOrDstBuffer)\n                : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_4.set(new Uint16Array(copyBuffer));\n            }\n            return buffer_4;\n        }\n        case exports.Format.S32_R: {\n            var buffer_5 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Int32Array(sizeOrDstBuffer)\n                : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_5.set(new Int32Array(copyBuffer));\n            }\n            return buffer_5;\n        }\n        case exports.Format.U32_R:\n        case exports.Format.U32_RG: {\n            var buffer_6 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Uint32Array(sizeOrDstBuffer)\n                : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_6.set(new Uint32Array(copyBuffer));\n            }\n            return buffer_6;\n        }\n        case exports.Format.F32_R:\n        case exports.Format.F32_RG:\n        case exports.Format.F32_RGB:\n        case exports.Format.F32_RGBA: {\n            var buffer_7 = sizeOrDstBuffer instanceof ArrayBuffer\n                ? new Float32Array(sizeOrDstBuffer)\n                : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n            if (copyBuffer) {\n                buffer_7.set(new Float32Array(copyBuffer));\n            }\n            return buffer_7;\n        }\n    }\n    var buffer = sizeOrDstBuffer instanceof ArrayBuffer\n        ? new Uint8Array(sizeOrDstBuffer)\n        : new Uint8Array(sizeOrDstBuffer);\n    if (copyBuffer) {\n        buffer.set(new Uint8Array(copyBuffer));\n    }\n    return buffer;\n}\n/**\n * Converts a half float to a number\n * @param value half float to convert\n * @returns converted half float\n */\nfunction halfFloat2Number(value) {\n    var s = (value & 0x8000) >> 15;\n    var e = (value & 0x7c00) >> 10;\n    var f = value & 0x03ff;\n    if (e === 0) {\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    }\n    else if (e == 0x1f) {\n        return f ? NaN : (s ? -1 : 1) * Infinity;\n    }\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\nfunction getBlockInformationFromFormat(format) {\n    switch (format) {\n        // 8 bits formats\n        case 'r8unorm':\n        case 'r8snorm':\n        case 'r8uint':\n        case 'r8sint':\n            return { width: 1, height: 1, length: 1 };\n        // 16 bits formats\n        case 'r16uint':\n        case 'r16sint':\n        case 'r16float':\n        case 'rg8unorm':\n        case 'rg8snorm':\n        case 'rg8uint':\n        case 'rg8sint':\n            return { width: 1, height: 1, length: 2 };\n        // 32 bits formats\n        case 'r32uint':\n        case 'r32sint':\n        case 'r32float':\n        case 'rg16uint':\n        case 'rg16sint':\n        case 'rg16float':\n        case 'rgba8unorm':\n        case 'rgba8unorm-srgb':\n        case 'rgba8snorm':\n        case 'rgba8uint':\n        case 'rgba8sint':\n        case 'bgra8unorm':\n        case 'bgra8unorm-srgb':\n        case 'rgb9e5ufloat':\n        case 'rgb10a2unorm':\n        case 'rg11b10ufloat':\n            return { width: 1, height: 1, length: 4 };\n        // 64 bits formats\n        case 'rg32uint':\n        case 'rg32sint':\n        case 'rg32float':\n        case 'rgba16uint':\n        case 'rgba16sint':\n        case 'rgba16float':\n            return { width: 1, height: 1, length: 8 };\n        // 128 bits formats\n        case 'rgba32uint':\n        case 'rgba32sint':\n        case 'rgba32float':\n            return { width: 1, height: 1, length: 16 };\n        // Depth and stencil formats\n        case 'stencil8':\n            throw new Error('No fixed size for Stencil8 format!');\n        case 'depth16unorm':\n            return { width: 1, height: 1, length: 2 };\n        case 'depth24plus':\n            throw new Error('No fixed size for Depth24Plus format!');\n        case 'depth24plus-stencil8':\n            throw new Error('No fixed size for Depth24PlusStencil8 format!');\n        case 'depth32float':\n            return { width: 1, height: 1, length: 4 };\n        // case 'depth24unorm-stencil8':\n        //   return { width: 1, height: 1, length: 4 };\n        case 'depth32float-stencil8':\n            return { width: 1, height: 1, length: 5 };\n        // BC compressed formats usable if \"texture-compression-bc\" is both\n        // supported by the device/user agent and enabled in requestDevice.\n        case 'bc7-rgba-unorm':\n        case 'bc7-rgba-unorm-srgb':\n        case 'bc6h-rgb-ufloat':\n        case 'bc6h-rgb-float':\n        case 'bc2-rgba-unorm':\n        case 'bc2-rgba-unorm-srgb':\n        case 'bc3-rgba-unorm':\n        case 'bc3-rgba-unorm-srgb':\n        case 'bc5-rg-unorm':\n        case 'bc5-rg-snorm':\n            return { width: 4, height: 4, length: 16 };\n        case 'bc4-r-unorm':\n        case 'bc4-r-snorm':\n        case 'bc1-rgba-unorm':\n        case 'bc1-rgba-unorm-srgb':\n            return { width: 4, height: 4, length: 8 };\n        default:\n            return { width: 1, height: 1, length: 4 };\n    }\n}\n\nvar ResourceBase_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(ResourceBase_WebGPU, _super);\n    function ResourceBase_WebGPU(_a) {\n        var id = _a.id, device = _a.device;\n        var _this = _super.call(this) || this;\n        _this.id = id;\n        _this.device = device;\n        return _this;\n    }\n    ResourceBase_WebGPU.prototype.destroy = function () { };\n    return ResourceBase_WebGPU;\n}(EventEmitter));\n\nvar Bindings_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(Bindings_WebGPU, _super);\n    function Bindings_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _b, _c;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Bindings;\n        var pipeline = descriptor.pipeline;\n        assert(!!pipeline);\n        var uniformBufferBindings = descriptor.uniformBufferBindings, storageBufferBindings = descriptor.storageBufferBindings, samplerBindings = descriptor.samplerBindings, storageTextureBindings = descriptor.storageTextureBindings;\n        _this.numUniformBuffers = (uniformBufferBindings === null || uniformBufferBindings === void 0 ? void 0 : uniformBufferBindings.length) || 0;\n        // entries orders: Uniform Sampler StorageBuffer StorageTexture\n        var gpuBindGroupEntries = [[], [], [], []];\n        var numBindings = 0;\n        if (uniformBufferBindings && uniformBufferBindings.length) {\n            for (var i = 0; i < uniformBufferBindings.length; i++) {\n                var _d = descriptor.uniformBufferBindings[i], binding = _d.binding, size = _d.size, offset = _d.offset, buffer = _d.buffer;\n                var gpuBufferBinding = {\n                    buffer: getPlatformBuffer(buffer),\n                    offset: offset !== null && offset !== void 0 ? offset : 0,\n                    size: size,\n                };\n                gpuBindGroupEntries[0].push({\n                    binding: binding !== null && binding !== void 0 ? binding : numBindings++,\n                    resource: gpuBufferBinding,\n                });\n            }\n        }\n        if (samplerBindings && samplerBindings.length) {\n            numBindings = 0;\n            for (var i = 0; i < samplerBindings.length; i++) {\n                var samplerEntry = tslib.__assign(tslib.__assign({}, samplerBindings[i]), defaultBindingLayoutSamplerDescriptor);\n                var binding = descriptor.samplerBindings[i];\n                var texture = binding.texture !== null\n                    ? binding.texture\n                    : _this.device['getFallbackTexture'](samplerEntry);\n                samplerEntry.dimension = texture.dimension;\n                samplerEntry.formatKind = getFormatSamplerKind(texture.format);\n                var gpuTextureView = texture.gpuTextureView;\n                gpuBindGroupEntries[1].push({\n                    binding: (_b = binding.textureBinding) !== null && _b !== void 0 ? _b : numBindings++,\n                    resource: gpuTextureView,\n                });\n                if (binding.samplerBinding !== -1) {\n                    var sampler = binding.sampler !== null\n                        ? binding.sampler\n                        : _this.device['getFallbackSampler'](samplerEntry);\n                    var gpuSampler = getPlatformSampler(sampler);\n                    gpuBindGroupEntries[1].push({\n                        binding: (_c = binding.samplerBinding) !== null && _c !== void 0 ? _c : numBindings++,\n                        resource: gpuSampler,\n                    });\n                }\n            }\n        }\n        if (storageBufferBindings && storageBufferBindings.length) {\n            numBindings = 0;\n            for (var i = 0; i < storageBufferBindings.length; i++) {\n                var _e = descriptor.storageBufferBindings[i], binding = _e.binding, size = _e.size, offset = _e.offset, buffer = _e.buffer;\n                var gpuBufferBinding = {\n                    buffer: getPlatformBuffer(buffer),\n                    offset: offset !== null && offset !== void 0 ? offset : 0,\n                    size: size,\n                };\n                gpuBindGroupEntries[2].push({\n                    binding: binding !== null && binding !== void 0 ? binding : numBindings++,\n                    resource: gpuBufferBinding,\n                });\n            }\n        }\n        if (storageTextureBindings && storageTextureBindings.length) {\n            numBindings = 0;\n            for (var i = 0; i < storageTextureBindings.length; i++) {\n                var _f = descriptor.storageTextureBindings[i], binding = _f.binding, texture = _f.texture;\n                var gpuTextureView = texture.gpuTextureView;\n                gpuBindGroupEntries[3].push({\n                    binding: binding !== null && binding !== void 0 ? binding : numBindings++,\n                    resource: gpuTextureView,\n                });\n            }\n        }\n        var lastGroupIndex = gpuBindGroupEntries.findLastIndex(function (group) { return !!group.length; });\n        _this.gpuBindGroup = gpuBindGroupEntries.map(function (gpuBindGroupEntries, i) {\n            return (i <= lastGroupIndex &&\n                _this.device.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(i),\n                    entries: gpuBindGroupEntries,\n                }));\n        });\n        return _this;\n    }\n    return Bindings_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar Buffer_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(Buffer_WebGPU, _super);\n    function Buffer_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Buffer;\n        var usage = descriptor.usage, viewOrSize = descriptor.viewOrSize;\n        var useMapRead = !!(usage & exports.BufferUsage.MAP_READ);\n        _this.usage = translateBufferUsage(usage);\n        // Buffer usages (BufferUsage::(MapRead|CopyDst|Storage)) is invalid. If a buffer usage contains BufferUsage::MapRead the only other allowed usage is BufferUsage::CopyDst.\n        // @see https://www.w3.org/TR/webgpu/#dom-gpubufferusage-copy_dst\n        if (useMapRead) {\n            _this.usage = exports.BufferUsage.MAP_READ | exports.BufferUsage.COPY_DST;\n        }\n        var mapBuffer = !util.isNumber(viewOrSize);\n        // this.size = isView(viewOrSize) ? viewOrSize.byteLength : viewOrSize * 4;\n        _this.view = !util.isNumber(viewOrSize) ? viewOrSize : null;\n        // 4 bytes alignments (because of the upload which requires this)\n        _this.size = util.isNumber(viewOrSize)\n            ? align(viewOrSize, 4)\n            : align(viewOrSize.byteLength, 4);\n        if (!util.isNumber(viewOrSize)) {\n            _this.gpuBuffer = _this.device.device.createBuffer({\n                usage: _this.usage,\n                size: _this.size,\n                mappedAtCreation: true,\n            });\n            var ctor = (viewOrSize && viewOrSize.constructor) || Float32Array;\n            // @ts-ignore\n            new ctor(_this.gpuBuffer.getMappedRange()).set(viewOrSize);\n            _this.gpuBuffer.unmap();\n        }\n        else {\n            _this.gpuBuffer = _this.device.device.createBuffer({\n                usage: _this.usage,\n                size: _this.size,\n                mappedAtCreation: useMapRead ? mapBuffer : false,\n            });\n        }\n        return _this;\n    }\n    Buffer_WebGPU.prototype.setSubData = function (dstByteOffset, src, srcByteOffset, byteLength) {\n        if (srcByteOffset === void 0) { srcByteOffset = 0; }\n        if (byteLength === void 0) { byteLength = 0; }\n        var buffer = this.gpuBuffer;\n        byteLength = byteLength || src.byteLength;\n        byteLength = Math.min(byteLength, this.size - dstByteOffset);\n        // After Migration to Canary\n        var chunkStart = src.byteOffset + srcByteOffset;\n        var chunkEnd = chunkStart + byteLength;\n        // 4 bytes alignments for upload\n        var alignedLength = (byteLength + 3) & ~3;\n        if (alignedLength !== byteLength) {\n            var tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\n            src = new Uint8Array(alignedLength);\n            src.set(tempView);\n            srcByteOffset = 0;\n            chunkStart = 0;\n            chunkEnd = alignedLength;\n            byteLength = alignedLength;\n        }\n        // Chunk\n        var maxChunk = 1024 * 1024 * 15;\n        var offset = 0;\n        while (chunkEnd - (chunkStart + offset) > maxChunk) {\n            this.device.device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\n            offset += maxChunk;\n        }\n        this.device.device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\n    };\n    Buffer_WebGPU.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        // @see https://www.w3.org/TR/webgpu/#dom-gpubuffer-destroy\n        this.gpuBuffer.destroy();\n    };\n    return Buffer_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar ComputePass_WebGPU = /** @class */ (function () {\n    function ComputePass_WebGPU() {\n        this.gpuComputePassEncoder = null;\n    }\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpucomputepassencoder-dispatchworkgroups\n     */\n    ComputePass_WebGPU.prototype.dispatchWorkgroups = function (workgroupCountX, workgroupCountY, workgroupCountZ) {\n        this.gpuComputePassEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpucomputepassencoder-dispatchworkgroupsindirect\n     */\n    ComputePass_WebGPU.prototype.dispatchWorkgroupsIndirect = function (indirectBuffer, indirectOffset) {\n        this.gpuComputePassEncoder.dispatchWorkgroupsIndirect(indirectBuffer.gpuBuffer, indirectOffset);\n    };\n    ComputePass_WebGPU.prototype.finish = function () {\n        this.gpuComputePassEncoder.end();\n        this.gpuComputePassEncoder = null;\n        this.frameCommandEncoder = null;\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpucommandencoder-begincomputepass\n     */\n    ComputePass_WebGPU.prototype.beginComputePass = function (commandEncoder) {\n        assert(this.gpuComputePassEncoder === null);\n        this.frameCommandEncoder = commandEncoder;\n        this.gpuComputePassEncoder = this.frameCommandEncoder.beginComputePass(this.gpuComputePassDescriptor);\n    };\n    ComputePass_WebGPU.prototype.setPipeline = function (pipeline_) {\n        var pipeline = pipeline_;\n        var gpuComputePipeline = assertExists(pipeline.gpuComputePipeline);\n        this.gpuComputePassEncoder.setPipeline(gpuComputePipeline);\n    };\n    ComputePass_WebGPU.prototype.setBindings = function (bindings_) {\n        var _this = this;\n        var bindings = bindings_;\n        bindings.gpuBindGroup.forEach(function (gpuBindGroup, i) {\n            if (gpuBindGroup) {\n                _this.gpuComputePassEncoder.setBindGroup(i, bindings.gpuBindGroup[i]);\n            }\n        });\n    };\n    ComputePass_WebGPU.prototype.pushDebugGroup = function (name) {\n        this.gpuComputePassEncoder.pushDebugGroup(name);\n    };\n    ComputePass_WebGPU.prototype.popDebugGroup = function () {\n        this.gpuComputePassEncoder.popDebugGroup();\n    };\n    ComputePass_WebGPU.prototype.insertDebugMarker = function (markerLabel) {\n        this.gpuComputePassEncoder.insertDebugMarker(markerLabel);\n    };\n    return ComputePass_WebGPU;\n}());\n\nvar ComputePipeline_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(ComputePipeline_WebGPU, _super);\n    function ComputePipeline_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.ComputePipeline;\n        _this.gpuComputePipeline = null;\n        _this.descriptor = descriptor;\n        var program = descriptor.program;\n        var computeStage = program.computeStage;\n        if (computeStage === null)\n            return _this;\n        var gpuComputePipeline = {\n            layout: 'auto',\n            compute: tslib.__assign({}, computeStage),\n        };\n        // @see https://www.w3.org/TR/webgpu/#dom-gpudevice-createrenderpipeline\n        _this.gpuComputePipeline =\n            _this.device.device.createComputePipeline(gpuComputePipeline);\n        if (_this.name !== undefined) {\n            _this.gpuComputePipeline.label = _this.name;\n        }\n        return _this;\n    }\n    ComputePipeline_WebGPU.prototype.getBindGroupLayout = function (index) {\n        return this.gpuComputePipeline.getBindGroupLayout(index);\n    };\n    return ComputePipeline_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar InputLayout_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(InputLayout_WebGPU, _super);\n    function InputLayout_WebGPU(_a) {\n        var e_1, _b, e_2, _c;\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.InputLayout;\n        var buffers = [];\n        try {\n            for (var _d = tslib.__values(descriptor.vertexBufferDescriptors), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var vertexBufferDescriptor = _e.value;\n                var arrayStride = vertexBufferDescriptor.arrayStride, stepMode = vertexBufferDescriptor.stepMode, attributes = vertexBufferDescriptor.attributes;\n                buffers.push({\n                    arrayStride: arrayStride,\n                    stepMode: translateVertexStepMode(stepMode),\n                    attributes: [],\n                });\n                try {\n                    for (var attributes_1 = (e_2 = void 0, tslib.__values(attributes)), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\n                        var attribute = attributes_1_1.value;\n                        // TODO: divisor\n                        var shaderLocation = attribute.shaderLocation, format = attribute.format, offset = attribute.offset;\n                        buffers[buffers.length - 1].attributes.push({\n                            shaderLocation: shaderLocation,\n                            format: translateVertexFormat(format),\n                            offset: offset,\n                        });\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (attributes_1_1 && !attributes_1_1.done && (_c = attributes_1.return)) _c.call(attributes_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        _this.indexFormat = translateIndexFormat(descriptor.indexBufferFormat);\n        _this.buffers = buffers;\n        return _this;\n    }\n    return InputLayout_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar Program_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(Program_WebGPU, _super);\n    function Program_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Program;\n        _this.vertexStage = null;\n        _this.fragmentStage = null;\n        _this.computeStage = null;\n        _this.descriptor = descriptor;\n        if (descriptor.vertex) {\n            _this.vertexStage = _this.createShaderStage(descriptor.vertex, 'vertex');\n        }\n        if (descriptor.fragment) {\n            _this.fragmentStage = _this.createShaderStage(descriptor.fragment, 'fragment');\n        }\n        if (descriptor.compute) {\n            // Only support WGSL now\n            _this.computeStage = _this.createShaderStage(descriptor.compute, 'compute');\n        }\n        return _this;\n    }\n    // eslint-disable-next-line\n    Program_WebGPU.prototype.setUniformsLegacy = function (uniforms) {\n    };\n    Program_WebGPU.prototype.createShaderStage = function (_a, shaderStage) {\n        var e_1, _b;\n        var glsl = _a.glsl, wgsl = _a.wgsl, entryPoint = _a.entryPoint, postprocess = _a.postprocess;\n        var validationEnabled = false;\n        // Use user-defined WGSL first.\n        var code = wgsl;\n        if (!code) {\n            try {\n                code = this.device['glsl_compile'](glsl, shaderStage, validationEnabled);\n            }\n            catch (e) {\n                console.error(e, glsl);\n                throw new Error('whoops');\n            }\n        }\n        var _loop_1 = function (depthTextureName) {\n            if (!code.includes(depthTextureName))\n                return \"continue\";\n            code = code.replace(\"var T_\".concat(depthTextureName, \": texture_2d<f32>;\"), \"var T_\".concat(depthTextureName, \": texture_depth_2d;\"));\n            code = code.replace(new RegExp(\"textureSample\\\\(T_\".concat(depthTextureName, \"(.*)\\\\);$\"), 'gm'), function (sub, cap) {\n                return \"vec4<f32>(textureSample(T_\".concat(depthTextureName).concat(cap, \"), 0.0, 0.0, 0.0);\");\n            });\n        };\n        try {\n            // Workaround for https://github.com/gfx-rs/naga/issues/1355\n            for (var _c = tslib.__values(['u_TextureFramebufferDepth']), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var depthTextureName = _d.value;\n                _loop_1(depthTextureName);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (postprocess) {\n            code = postprocess(code);\n        }\n        // @see https://www.w3.org/TR/webgpu/#dom-gpudevice-createshadermodule\n        var shaderModule = this.device.device.createShaderModule({ code: code });\n        return { module: shaderModule, entryPoint: entryPoint || 'main' };\n    };\n    return Program_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar QueryPool_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(QueryPool_WebGPU, _super);\n    function QueryPool_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.QueryPool;\n        var elemCount = descriptor.elemCount, type = descriptor.type;\n        _this.querySet = _this.device.device.createQuerySet({\n            type: translateQueryPoolType(type),\n            count: elemCount,\n        });\n        _this.resolveBuffer = _this.device.device.createBuffer({\n            size: elemCount * 8,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n        });\n        _this.cpuBuffer = _this.device.device.createBuffer({\n            size: elemCount * 8,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n        _this.results = null;\n        return _this;\n    }\n    QueryPool_WebGPU.prototype.queryResultOcclusion = function (dstOffs) {\n        if (this.results === null)\n            return null;\n        return this.results[dstOffs] !== BigInt(0);\n    };\n    QueryPool_WebGPU.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.querySet.destroy();\n        this.resolveBuffer.destroy();\n        this.cpuBuffer.destroy();\n    };\n    return QueryPool_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar Readback_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(Readback_WebGPU, _super);\n    function Readback_WebGPU(_a) {\n        var id = _a.id, device = _a.device;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Readback;\n        return _this;\n    }\n    Readback_WebGPU.prototype.readTexture = function (t, x, y, width, height, dst, dstOffset, length) {\n        if (dstOffset === void 0) { dstOffset = 0; }\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var texture, faceIndex, blockInformation, bytesPerRow, bytesPerRowAligned, size, buffer, commandEncoder;\n            return tslib.__generator(this, function (_a) {\n                texture = t;\n                faceIndex = 0;\n                blockInformation = getBlockInformationFromFormat(texture.gpuTextureformat);\n                bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\n                bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\n                size = bytesPerRowAligned * height;\n                buffer = this.device.createBuffer({\n                    usage: exports.BufferUsage.STORAGE | exports.BufferUsage.MAP_READ | exports.BufferUsage.COPY_DST,\n                    hint: exports.BufferFrequencyHint.STATIC,\n                    viewOrSize: size,\n                });\n                commandEncoder = this.device.device.createCommandEncoder();\n                // @see https://www.w3.org/TR/webgpu/#dom-gpucommandencoder-copytexturetobuffer\n                commandEncoder.copyTextureToBuffer({\n                    texture: texture.gpuTexture,\n                    mipLevel: 0,\n                    origin: {\n                        x: x,\n                        y: y,\n                        z: Math.max(faceIndex, 0),\n                    },\n                }, {\n                    buffer: buffer.gpuBuffer,\n                    offset: 0,\n                    bytesPerRow: bytesPerRowAligned,\n                }, {\n                    width: width,\n                    height: height,\n                    depthOrArrayLayers: 1,\n                });\n                this.device.device.queue.submit([commandEncoder.finish()]);\n                return [2 /*return*/, this.readBuffer(buffer, 0, dst.byteLength === size ? dst : null, dstOffset, size, texture.format, true, false, bytesPerRow, bytesPerRowAligned, height)];\n            });\n        });\n    };\n    Readback_WebGPU.prototype.readTextureSync = function (t, x, y, width, height, dst, dstOffset, length) {\n        throw new Error('ERROR_MSG_METHOD_NOT_IMPLEMENTED');\n    };\n    Readback_WebGPU.prototype.readBuffer = function (b, srcByteOffset, dstArrayBufferView, dstOffset, _size, type, noDataConversion, destroy, bytesPerRow, bytesPerRowAligned, height) {\n        var _this = this;\n        if (srcByteOffset === void 0) { srcByteOffset = 0; }\n        if (dstArrayBufferView === void 0) { dstArrayBufferView = null; }\n        if (_size === void 0) { _size = 0; }\n        if (type === void 0) { type = exports.Format.U8_RGB; }\n        if (noDataConversion === void 0) { noDataConversion = false; }\n        if (bytesPerRow === void 0) { bytesPerRow = 0; }\n        if (bytesPerRowAligned === void 0) { bytesPerRowAligned = 0; }\n        if (height === void 0) { height = 0; }\n        var buffer = b;\n        var size = _size || buffer.size;\n        var dst = dstArrayBufferView || buffer.view;\n        var floatFormat = \n        // @ts-ignore\n        (dst && dst.constructor && dst.constructor.BYTES_PER_ELEMENT) ||\n            getFormatCompByteSize(type);\n        var gpuReadBuffer = buffer;\n        // can read buffer directly?\n        if (!(buffer.usage & exports.BufferUsage.MAP_READ &&\n            buffer.usage & exports.BufferUsage.COPY_DST)) {\n            var commandEncoder = this.device.device.createCommandEncoder();\n            gpuReadBuffer = this.device.createBuffer({\n                usage: exports.BufferUsage.STORAGE | exports.BufferUsage.MAP_READ | exports.BufferUsage.COPY_DST,\n                hint: exports.BufferFrequencyHint.STATIC,\n                viewOrSize: size,\n            });\n            // Encode commands for copying buffer to buffer.\n            commandEncoder.copyBufferToBuffer(buffer.gpuBuffer /* source buffer */, srcByteOffset /* source offset */, gpuReadBuffer.gpuBuffer /* destination buffer */, 0 /* destination offset */, size /* size */);\n            this.device.device.queue.submit([commandEncoder.finish()]);\n        }\n        return new Promise(function (resolve, reject) {\n            gpuReadBuffer.gpuBuffer\n                .mapAsync(GPUMapMode.READ, srcByteOffset, size)\n                .then(function () {\n                var copyArrayBuffer = gpuReadBuffer.gpuBuffer.getMappedRange(srcByteOffset, size);\n                var data = dst;\n                if (noDataConversion) {\n                    if (data === null) {\n                        data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\n                    }\n                    else {\n                        // @ts-ignore\n                        data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\n                    }\n                }\n                else {\n                    if (data === null) {\n                        switch (floatFormat) {\n                            case 1: // byte format\n                                data = new Uint8Array(size);\n                                data.set(new Uint8Array(copyArrayBuffer));\n                                break;\n                            case 2: // half float\n                                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                                data = _this.getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\n                                break;\n                            case 4: // float\n                                data = new Float32Array(size / 4);\n                                data.set(new Float32Array(copyArrayBuffer));\n                                break;\n                        }\n                    }\n                    else {\n                        switch (floatFormat) {\n                            case 1: // byte format\n                                data = new Uint8Array(data.buffer);\n                                data.set(new Uint8Array(copyArrayBuffer));\n                                break;\n                            case 2: // half float\n                                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                                data = _this.getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, dst);\n                                break;\n                            case 4: // float\n                                var ctor = (dst && dst.constructor) || Float32Array;\n                                // @ts-ignore\n                                data = new ctor(data.buffer);\n                                // @ts-ignore\n                                data.set(new ctor(copyArrayBuffer));\n                                break;\n                        }\n                    }\n                }\n                if (bytesPerRow !== bytesPerRowAligned) {\n                    // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\n                    if (floatFormat === 1 && !noDataConversion) {\n                        // half float have been converted to float above\n                        bytesPerRow *= 2;\n                        bytesPerRowAligned *= 2;\n                    }\n                    var data2 = new Uint8Array(data.buffer);\n                    var offset = bytesPerRow, offset2 = 0;\n                    for (var y = 1; y < height; ++y) {\n                        offset2 = y * bytesPerRowAligned;\n                        for (var x = 0; x < bytesPerRow; ++x) {\n                            data2[offset++] = data2[offset2++];\n                        }\n                    }\n                    if (floatFormat !== 0 && !noDataConversion) {\n                        data = new Float32Array(data2.buffer, 0, offset / 4);\n                    }\n                    else {\n                        data = new Uint8Array(data2.buffer, 0, offset);\n                    }\n                }\n                gpuReadBuffer.gpuBuffer.unmap();\n                resolve(data);\n            }, function (reason) { return reject(reason); });\n        });\n    };\n    Readback_WebGPU.prototype.getHalfFloatAsFloatRGBAArrayBuffer = function (dataLength, arrayBuffer, destArray) {\n        if (!destArray) {\n            destArray = new Float32Array(dataLength);\n        }\n        var srcData = new Uint16Array(arrayBuffer);\n        while (dataLength--) {\n            destArray[dataLength] = halfFloat2Number(srcData[dataLength]);\n        }\n        return destArray;\n    };\n    return Readback_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar RenderPass_WebGPU = /** @class */ (function () {\n    function RenderPass_WebGPU(device) {\n        this.device = device;\n        this.gpuRenderPassEncoder = null;\n        this.gfxColorAttachment = [];\n        this.gfxColorAttachmentLevel = [];\n        this.gfxColorResolveTo = [];\n        this.gfxColorResolveToLevel = [];\n        this.gfxDepthStencilAttachment = null;\n        this.gfxDepthStencilResolveTo = null;\n        this.gpuColorAttachments = [];\n        this.gpuDepthStencilAttachment = {\n            view: null,\n            depthLoadOp: 'load',\n            depthStoreOp: 'store',\n            stencilLoadOp: 'load',\n            stencilStoreOp: 'store',\n        };\n        this.gpuRenderPassDescriptor = {\n            colorAttachments: this.gpuColorAttachments,\n            depthStencilAttachment: this.gpuDepthStencilAttachment,\n        };\n    }\n    RenderPass_WebGPU.prototype.getEncoder = function () {\n        var _a;\n        return (((_a = this.renderBundle) === null || _a === void 0 ? void 0 : _a['renderBundleEncoder']) || this.gpuRenderPassEncoder);\n    };\n    RenderPass_WebGPU.prototype.getTextureView = function (target, level) {\n        assert(level < target.mipLevelCount);\n        if (target.mipLevelCount === 1)\n            return target.gpuTextureView;\n        else\n            return target.gpuTexture.createView({\n                baseMipLevel: level,\n                mipLevelCount: 1,\n            });\n    };\n    RenderPass_WebGPU.prototype.setRenderPassDescriptor = function (descriptor) {\n        var _a, _b, _c, _d, _e, _f;\n        this.descriptor = descriptor;\n        this.gpuRenderPassDescriptor.colorAttachments = this.gpuColorAttachments;\n        var numColorAttachments = descriptor.colorAttachment.length;\n        this.gfxColorAttachment.length = numColorAttachments;\n        this.gfxColorResolveTo.length = numColorAttachments;\n        for (var i = 0; i < descriptor.colorAttachment.length; i++) {\n            var colorAttachment = descriptor\n                .colorAttachment[i];\n            var colorResolveTo = descriptor\n                .colorResolveTo[i];\n            // Do some dumb juggling...\n            if (colorAttachment === null && colorResolveTo !== null) {\n                colorAttachment = colorResolveTo;\n                colorResolveTo = null;\n            }\n            this.gfxColorAttachment[i] = colorAttachment;\n            this.gfxColorResolveTo[i] = colorResolveTo;\n            this.gfxColorAttachmentLevel[i] =\n                ((_a = descriptor.colorAttachmentLevel) === null || _a === void 0 ? void 0 : _a[i]) || 0;\n            this.gfxColorResolveToLevel[i] = ((_b = descriptor.colorResolveToLevel) === null || _b === void 0 ? void 0 : _b[i]) || 0;\n            if (colorAttachment !== null) {\n                if (this.gpuColorAttachments[i] === undefined) {\n                    this.gpuColorAttachments[i] = {};\n                }\n                var dstAttachment = this.gpuColorAttachments[i];\n                dstAttachment.view = this.getTextureView(colorAttachment, ((_c = this.gfxColorAttachmentLevel) === null || _c === void 0 ? void 0 : _c[i]) || 0);\n                var clearColor = (_e = (_d = descriptor.colorClearColor) === null || _d === void 0 ? void 0 : _d[i]) !== null && _e !== void 0 ? _e : 'load';\n                if (clearColor === 'load') {\n                    dstAttachment.loadOp = 'load';\n                }\n                else {\n                    dstAttachment.loadOp = 'clear';\n                    dstAttachment.clearValue = clearColor;\n                }\n                dstAttachment.storeOp = ((_f = descriptor.colorStore) === null || _f === void 0 ? void 0 : _f[i])\n                    ? 'store'\n                    : 'discard';\n                dstAttachment.resolveTarget = undefined;\n                if (colorResolveTo !== null) {\n                    if (colorAttachment.sampleCount > 1) {\n                        dstAttachment.resolveTarget = this.getTextureView(colorResolveTo, this.gfxColorResolveToLevel[i]);\n                    }\n                    else {\n                        dstAttachment.storeOp = 'store';\n                    }\n                }\n            }\n            else {\n                // https://github.com/gpuweb/gpuweb/issues/1250\n                this.gpuColorAttachments.length = i;\n                this.gfxColorAttachment.length = i;\n                this.gfxColorResolveTo.length = i;\n                break;\n            }\n        }\n        this.gfxDepthStencilAttachment =\n            descriptor.depthStencilAttachment;\n        this.gfxDepthStencilResolveTo =\n            descriptor.depthStencilResolveTo;\n        if (descriptor.depthStencilAttachment) {\n            var dsAttachment = descriptor.depthStencilAttachment;\n            var dstAttachment = this.gpuDepthStencilAttachment;\n            dstAttachment.view = dsAttachment.gpuTextureView;\n            var hasDepth = !!(getFormatFlags(dsAttachment.format) & exports.FormatFlags.Depth);\n            if (hasDepth) {\n                if (descriptor.depthClearValue === 'load') {\n                    dstAttachment.depthLoadOp = 'load';\n                }\n                else {\n                    dstAttachment.depthLoadOp = 'clear';\n                    dstAttachment.depthClearValue = descriptor.depthClearValue;\n                }\n                if (descriptor.depthStencilStore ||\n                    this.gfxDepthStencilResolveTo !== null)\n                    dstAttachment.depthStoreOp = 'store';\n                else\n                    dstAttachment.depthStoreOp = 'discard';\n            }\n            else {\n                dstAttachment.depthLoadOp = undefined;\n                dstAttachment.depthStoreOp = undefined;\n            }\n            var hasStencil = !!(getFormatFlags(dsAttachment.format) & exports.FormatFlags.Stencil);\n            if (hasStencil) {\n                if (descriptor.stencilClearValue === 'load') {\n                    dstAttachment.stencilLoadOp = 'load';\n                }\n                else {\n                    dstAttachment.stencilLoadOp = 'clear';\n                    dstAttachment.stencilClearValue = descriptor.stencilClearValue;\n                }\n                if (descriptor.depthStencilStore ||\n                    this.gfxDepthStencilResolveTo !== null)\n                    dstAttachment.stencilStoreOp = 'store';\n                else\n                    dstAttachment.stencilStoreOp = 'discard';\n            }\n            else {\n                dstAttachment.stencilLoadOp = undefined;\n                dstAttachment.stencilStoreOp = undefined;\n            }\n            this.gpuRenderPassDescriptor.depthStencilAttachment =\n                this.gpuDepthStencilAttachment;\n        }\n        else {\n            this.gpuRenderPassDescriptor.depthStencilAttachment = undefined;\n        }\n        this.gpuRenderPassDescriptor.occlusionQuerySet = !util.isNil(descriptor.occlusionQueryPool)\n            ? getPlatformQuerySet(descriptor.occlusionQueryPool)\n            : undefined;\n    };\n    RenderPass_WebGPU.prototype.beginRenderPass = function (commandEncoder, renderPassDescriptor) {\n        assert(this.gpuRenderPassEncoder === null);\n        this.setRenderPassDescriptor(renderPassDescriptor);\n        this.frameCommandEncoder = commandEncoder;\n        this.gpuRenderPassEncoder = this.frameCommandEncoder.beginRenderPass(this.gpuRenderPassDescriptor);\n    };\n    RenderPass_WebGPU.prototype.flipY = function (y, h) {\n        var height = this.device['swapChainHeight'];\n        return height - y - h;\n    };\n    RenderPass_WebGPU.prototype.setViewport = function (x, y, w, h, minDepth, maxDepth) {\n        if (minDepth === void 0) { minDepth = 0; }\n        if (maxDepth === void 0) { maxDepth = 1; }\n        this.gpuRenderPassEncoder.setViewport(x, this.flipY(y, h), w, h, minDepth, maxDepth);\n    };\n    RenderPass_WebGPU.prototype.setScissorRect = function (x, y, w, h) {\n        this.gpuRenderPassEncoder.setScissorRect(x, this.flipY(y, h), w, h);\n    };\n    RenderPass_WebGPU.prototype.setPipeline = function (pipeline_) {\n        var pipeline = pipeline_;\n        var gpuRenderPipeline = assertExists(pipeline.gpuRenderPipeline);\n        this.getEncoder().setPipeline(gpuRenderPipeline);\n    };\n    RenderPass_WebGPU.prototype.setVertexInput = function (inputLayout_, vertexBuffers, indexBuffer) {\n        if (inputLayout_ === null)\n            return;\n        var encoder = this.getEncoder();\n        var inputLayout = inputLayout_;\n        if (indexBuffer !== null)\n            encoder.setIndexBuffer(getPlatformBuffer(indexBuffer.buffer), assertExists(inputLayout.indexFormat), indexBuffer.offset);\n        for (var i = 0; i < vertexBuffers.length; i++) {\n            var b = vertexBuffers[i];\n            if (b === null)\n                continue;\n            encoder.setVertexBuffer(i, getPlatformBuffer(b.buffer), b.offset);\n        }\n    };\n    RenderPass_WebGPU.prototype.setBindings = function (bindings_) {\n        var bindings = bindings_;\n        var encoder = this.getEncoder();\n        bindings.gpuBindGroup.forEach(function (gpuBindGroup, i) {\n            if (gpuBindGroup) {\n                encoder.setBindGroup(i, bindings.gpuBindGroup[i]);\n            }\n        });\n    };\n    RenderPass_WebGPU.prototype.setStencilReference = function (ref) {\n        this.gpuRenderPassEncoder.setStencilReference(ref);\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpurendercommandsmixin-draw\n     */\n    RenderPass_WebGPU.prototype.draw = function (vertexCount, instanceCount, firstVertex, firstInstance) {\n        this.getEncoder().draw(vertexCount, instanceCount, firstVertex, firstInstance);\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpurendercommandsmixin-drawindexed\n     */\n    RenderPass_WebGPU.prototype.drawIndexed = function (indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {\n        this.getEncoder().drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpurendercommandsmixin-drawindirect\n     */\n    RenderPass_WebGPU.prototype.drawIndirect = function (indirectBuffer, indirectOffset) {\n        this.getEncoder().drawIndirect(getPlatformBuffer(indirectBuffer), indirectOffset);\n    };\n    RenderPass_WebGPU.prototype.drawIndexedIndirect = function (indirectBuffer, indirectOffset) {\n        this.getEncoder().drawIndexedIndirect(getPlatformBuffer(indirectBuffer), indirectOffset);\n    };\n    RenderPass_WebGPU.prototype.beginOcclusionQuery = function (queryIndex) {\n        this.gpuRenderPassEncoder.beginOcclusionQuery(queryIndex);\n    };\n    RenderPass_WebGPU.prototype.endOcclusionQuery = function () {\n        this.gpuRenderPassEncoder.endOcclusionQuery();\n    };\n    RenderPass_WebGPU.prototype.pushDebugGroup = function (name) {\n        this.gpuRenderPassEncoder.pushDebugGroup(name);\n    };\n    RenderPass_WebGPU.prototype.popDebugGroup = function () {\n        this.gpuRenderPassEncoder.popDebugGroup();\n    };\n    RenderPass_WebGPU.prototype.insertDebugMarker = function (markerLabel) {\n        this.gpuRenderPassEncoder.insertDebugMarker(markerLabel);\n    };\n    RenderPass_WebGPU.prototype.beginBundle = function (renderBundle) {\n        this.renderBundle = renderBundle;\n    };\n    RenderPass_WebGPU.prototype.endBundle = function () {\n        this.renderBundle.finish();\n    };\n    RenderPass_WebGPU.prototype.executeBundles = function (renderBundles) {\n        this.gpuRenderPassEncoder.executeBundles(renderBundles.map(function (bundle) { return bundle.renderBundle; }));\n    };\n    RenderPass_WebGPU.prototype.finish = function () {\n        var _a;\n        (_a = this.gpuRenderPassEncoder) === null || _a === void 0 ? void 0 : _a.end();\n        this.gpuRenderPassEncoder = null;\n        // Fake a resolve with a copy for non-MSAA.\n        for (var i = 0; i < this.gfxColorAttachment.length; i++) {\n            var colorAttachment = this.gfxColorAttachment[i];\n            var colorResolveTo = this.gfxColorResolveTo[i];\n            if (colorAttachment !== null &&\n                colorResolveTo !== null &&\n                colorAttachment.sampleCount === 1) {\n                this.copyAttachment(colorResolveTo, this.gfxColorAttachmentLevel[i], colorAttachment, this.gfxColorResolveToLevel[i]);\n            }\n        }\n        if (this.gfxDepthStencilAttachment && this.gfxDepthStencilResolveTo) {\n            if (this.gfxDepthStencilAttachment.sampleCount > 1) ;\n            else {\n                this.copyAttachment(this.gfxDepthStencilResolveTo, 0, this.gfxDepthStencilAttachment, 0);\n            }\n        }\n        this.frameCommandEncoder = null;\n    };\n    RenderPass_WebGPU.prototype.copyAttachment = function (dst, dstLevel, src, srcLevel) {\n        assert(src.sampleCount === 1);\n        var srcCopy = {\n            texture: src.gpuTexture,\n            mipLevel: srcLevel,\n        };\n        var dstCopy = {\n            texture: dst.gpuTexture,\n            mipLevel: dstLevel,\n        };\n        assert(src.width >>> srcLevel === dst.width >>> dstLevel);\n        assert(src.height >>> srcLevel === dst.height >>> dstLevel);\n        assert(!!(src.usage & GPUTextureUsage$1.COPY_SRC));\n        assert(!!(dst.usage & GPUTextureUsage$1.COPY_DST));\n        this.frameCommandEncoder.copyTextureToTexture(srcCopy, dstCopy, [\n            dst.width,\n            dst.height,\n            1,\n        ]);\n    };\n    return RenderPass_WebGPU;\n}());\n\nvar RenderPipeline_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(RenderPipeline_WebGPU, _super);\n    function RenderPipeline_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.RenderPipeline;\n        _this.isCreatingAsync = false;\n        _this.gpuRenderPipeline = null;\n        _this.descriptor = descriptor;\n        _this.device['createRenderPipelineInternal'](_this, false);\n        return _this;\n    }\n    RenderPipeline_WebGPU.prototype.getBindGroupLayout = function (index) {\n        return this.gpuRenderPipeline.getBindGroupLayout(index);\n    };\n    return RenderPipeline_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar Sampler_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(Sampler_WebGPU, _super);\n    function Sampler_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor;\n        var _b, _c;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Sampler;\n        var lodMinClamp = descriptor.lodMinClamp;\n        var lodMaxClamp = descriptor.mipmapFilter === exports.MipmapFilterMode.NO_MIP\n            ? descriptor.lodMinClamp\n            : descriptor.lodMaxClamp;\n        var maxAnisotropy = (_b = descriptor.maxAnisotropy) !== null && _b !== void 0 ? _b : 1;\n        if (maxAnisotropy > 1)\n            assert(descriptor.minFilter === exports.FilterMode.BILINEAR &&\n                descriptor.magFilter === exports.FilterMode.BILINEAR &&\n                descriptor.mipmapFilter === exports.MipmapFilterMode.LINEAR);\n        _this.gpuSampler = _this.device.device.createSampler({\n            addressModeU: translateAddressMode(descriptor.addressModeU),\n            addressModeV: translateAddressMode(descriptor.addressModeV),\n            addressModeW: translateAddressMode((_c = descriptor.addressModeW) !== null && _c !== void 0 ? _c : descriptor.addressModeU),\n            lodMinClamp: lodMinClamp,\n            lodMaxClamp: lodMaxClamp,\n            minFilter: translateMinMagFilter(descriptor.minFilter),\n            magFilter: translateMinMagFilter(descriptor.magFilter),\n            mipmapFilter: translateMipFilter(descriptor.mipmapFilter),\n            compare: descriptor.compareFunction !== undefined\n                ? translateCompareFunction(descriptor.compareFunction)\n                : undefined,\n            maxAnisotropy: maxAnisotropy,\n        });\n        return _this;\n    }\n    return Sampler_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar Texture_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(Texture_WebGPU, _super);\n    function Texture_WebGPU(_a) {\n        var id = _a.id, device = _a.device, descriptor = _a.descriptor, skipCreate = _a.skipCreate, sampleCount = _a.sampleCount;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.Texture;\n        _this.flipY = false;\n        var format = descriptor.format, dimension = descriptor.dimension, width = descriptor.width, height = descriptor.height, depthOrArrayLayers = descriptor.depthOrArrayLayers, mipLevelCount = descriptor.mipLevelCount, usage = descriptor.usage, pixelStore = descriptor.pixelStore;\n        _this.flipY = !!(pixelStore === null || pixelStore === void 0 ? void 0 : pixelStore.unpackFlipY);\n        _this.device.createTextureShared({\n            format: format,\n            dimension: dimension !== null && dimension !== void 0 ? dimension : exports.TextureDimension.TEXTURE_2D,\n            width: width,\n            height: height,\n            depthOrArrayLayers: depthOrArrayLayers !== null && depthOrArrayLayers !== void 0 ? depthOrArrayLayers : 1,\n            mipLevelCount: mipLevelCount !== null && mipLevelCount !== void 0 ? mipLevelCount : 1,\n            usage: usage,\n            sampleCount: sampleCount !== null && sampleCount !== void 0 ? sampleCount : 1,\n        }, _this, skipCreate);\n        return _this;\n    }\n    Texture_WebGPU.prototype.textureFromImageBitmapOrCanvas = function (device, sources, depthOrArrayLayers) {\n        var width = sources[0].width;\n        var height = sources[0].height;\n        var textureDescriptor = {\n            // Unlike in WebGL, the size of our texture must be set at texture creation time.\n            // This means we have to wait until the image is loaded to create the texture, since we won't\n            // know the size until then.\n            size: { width: width, height: height, depthOrArrayLayers: depthOrArrayLayers },\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING |\n                GPUTextureUsage.COPY_DST |\n                GPUTextureUsage.RENDER_ATTACHMENT,\n        };\n        var texture = device.createTexture(textureDescriptor);\n        for (var i = 0; i < sources.length; i++) {\n            device.queue.copyExternalImageToTexture({ source: sources[i], flipY: this.flipY }, { texture: texture, origin: [0, 0, i] }, [width, height]);\n        }\n        return [texture, width, height];\n    };\n    Texture_WebGPU.prototype.isImageBitmapOrCanvases = function (datas) {\n        var data = datas[0];\n        return (data instanceof ImageBitmap ||\n            data instanceof HTMLCanvasElement ||\n            data instanceof OffscreenCanvas);\n    };\n    Texture_WebGPU.prototype.isVideo = function (datas) {\n        var data = datas[0];\n        return data instanceof HTMLVideoElement;\n    };\n    /**\n     * @see https://toji.dev/webgpu-best-practices/img-textures\n     */\n    Texture_WebGPU.prototype.setImageData = function (datas, lod) {\n        var _a;\n        var _this = this;\n        var device = this.device.device;\n        var texture;\n        var width;\n        var height;\n        if (this.isImageBitmapOrCanvases(datas)) {\n            _a = tslib.__read(this.textureFromImageBitmapOrCanvas(device, datas, this.depthOrArrayLayers), 3), texture = _a[0], width = _a[1], height = _a[2];\n        }\n        else if (this.isVideo(datas)) {\n            // @see https://toji.dev/webgpu-best-practices/img-textures#creating-a-texture-from-an-htmlvideoelement-video-tag\n            texture = device.importExternalTexture({\n                source: datas[0],\n            });\n        }\n        else {\n            var blockInformation = getBlockInformationFromFormat(this.gpuTextureformat);\n            var bytesPerRow_1 = Math.ceil(this.width / blockInformation.width) *\n                blockInformation.length;\n            // TODO: support ArrayBufferView[]\n            datas.forEach(function (data) {\n                device.queue.writeTexture({ texture: _this.gpuTexture }, data, {\n                    bytesPerRow: bytesPerRow_1,\n                }, {\n                    width: _this.width,\n                    height: _this.height,\n                });\n            });\n        }\n        this.width = width;\n        this.height = height;\n        if (texture) {\n            this.gpuTexture = texture;\n        }\n        this.gpuTextureView = this.gpuTexture.createView({\n            dimension: translateTextureViewDimension(this.dimension),\n        });\n    };\n    Texture_WebGPU.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        // @see https://www.w3.org/TR/webgpu/#dom-gputexture-destroy\n        this.gpuTexture.destroy();\n    };\n    return Texture_WebGPU;\n}(ResourceBase_WebGPU));\n\n/**\n * It works by recording the draw calls during one frame and by replaying this recording for all subsequent frames.\n * So, the scene should be mostly static for this mode to work as expected.\n * @see https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUSnapshotRendering\n */\nvar RenderBundle_WebGPU = /** @class */ (function (_super) {\n    tslib.__extends(RenderBundle_WebGPU, _super);\n    function RenderBundle_WebGPU(_a) {\n        var id = _a.id, device = _a.device;\n        var _this = _super.call(this, { id: id, device: device }) || this;\n        _this.type = exports.ResourceType.RenderBundle;\n        _this.renderBundleEncoder = _this.device.device.createRenderBundleEncoder({\n            colorFormats: [_this.device['swapChainFormat']],\n        });\n        return _this;\n    }\n    RenderBundle_WebGPU.prototype.finish = function () {\n        this.renderBundle = this.renderBundleEncoder.finish();\n    };\n    return RenderBundle_WebGPU;\n}(ResourceBase_WebGPU));\n\nvar Device_WebGPU = /** @class */ (function () {\n    function Device_WebGPU(adapter, device, canvas, canvasContext, glsl_compile, wGSLComposer) {\n        this.swapChainWidth = 0;\n        this.swapChainHeight = 0;\n        this.swapChainTextureUsage = GPUTextureUsage$1.RENDER_ATTACHMENT | GPUTextureUsage$1.COPY_DST;\n        this._resourceUniqueId = 0;\n        this.renderPassPool = [];\n        this.computePassPool = [];\n        this.frameCommandEncoderPool = [];\n        this.featureTextureCompressionBC = false;\n        // VendorInfo\n        this.platformString = 'WebGPU';\n        this.glslVersion = \"#version 440\";\n        this.explicitBindingLocations = true;\n        this.separateSamplerTextures = true;\n        this.viewportOrigin = exports.ViewportOrigin.UPPER_LEFT;\n        this.clipSpaceNearZ = exports.ClipSpaceNearZ.ZERO;\n        this.supportsSyncPipelineCompilation = false;\n        this.supportMRT = true;\n        this.device = device;\n        this.canvas = canvas;\n        this.canvasContext = canvasContext;\n        this.glsl_compile = glsl_compile;\n        this.WGSLComposer = wGSLComposer;\n        this.fallbackTexture2D = this.createFallbackTexture(exports.TextureDimension.TEXTURE_2D, exports.SamplerFormatKind.Float);\n        this.setResourceName(this.fallbackTexture2D, 'Fallback Texture2D');\n        this.fallbackTexture2DDepth = this.createFallbackTexture(exports.TextureDimension.TEXTURE_2D, exports.SamplerFormatKind.Depth);\n        this.setResourceName(this.fallbackTexture2DDepth, 'Fallback Depth Texture2D');\n        this.fallbackTexture2DArray = this.createFallbackTexture(exports.TextureDimension.TEXTURE_2D_ARRAY, exports.SamplerFormatKind.Float);\n        this.setResourceName(this.fallbackTexture2DArray, 'Fallback Texture2DArray');\n        this.fallbackTexture3D = this.createFallbackTexture(exports.TextureDimension.TEXTURE_3D, exports.SamplerFormatKind.Float);\n        this.setResourceName(this.fallbackTexture3D, 'Fallback Texture3D');\n        this.fallbackTextureCube = this.createFallbackTexture(exports.TextureDimension.TEXTURE_CUBE_MAP, exports.SamplerFormatKind.Float);\n        this.setResourceName(this.fallbackTextureCube, 'Fallback TextureCube');\n        this.fallbackSamplerFiltering = this.createSampler({\n            addressModeU: exports.AddressMode.REPEAT,\n            addressModeV: exports.AddressMode.REPEAT,\n            minFilter: exports.FilterMode.POINT,\n            magFilter: exports.FilterMode.POINT,\n            mipmapFilter: exports.MipmapFilterMode.NEAREST,\n        });\n        this.setResourceName(this.fallbackSamplerFiltering, 'Fallback Sampler Filtering');\n        this.fallbackSamplerComparison = this.createSampler({\n            addressModeU: exports.AddressMode.REPEAT,\n            addressModeV: exports.AddressMode.REPEAT,\n            minFilter: exports.FilterMode.POINT,\n            magFilter: exports.FilterMode.POINT,\n            mipmapFilter: exports.MipmapFilterMode.NEAREST,\n            compareFunction: exports.CompareFunction.ALWAYS,\n        });\n        this.setResourceName(this.fallbackSamplerComparison, 'Fallback Sampler Comparison Filtering');\n        // Firefox doesn't support GPUDevice.features yet...\n        if (this.device.features) {\n            this.featureTextureCompressionBC = this.device.features.has('texture-compression-bc');\n        }\n        this.device.onuncapturederror = function (event) {\n            console.error(event.error);\n        };\n        this.swapChainFormat = navigator.gpu.getPreferredCanvasFormat();\n        // @see https://www.w3.org/TR/webgpu/#canvas-configuration\n        this.canvasContext.configure({\n            device: this.device,\n            format: this.swapChainFormat,\n            usage: this.swapChainTextureUsage,\n            // @see https://www.w3.org/TR/webgpu/#gpucanvasalphamode\n            // alphaMode: 'opaque',\n            alphaMode: 'premultiplied',\n        });\n    }\n    Device_WebGPU.prototype.destroy = function () { };\n    // SwapChain\n    Device_WebGPU.prototype.configureSwapChain = function (width, height) {\n        if (this.swapChainWidth === width && this.swapChainHeight === height)\n            return;\n        this.swapChainWidth = width;\n        this.swapChainHeight = height;\n    };\n    Device_WebGPU.prototype.getOnscreenTexture = function () {\n        // @see https://www.w3.org/TR/webgpu/#dom-gpucanvascontext-getcurrenttexture\n        var gpuTexture = this.canvasContext.getCurrentTexture();\n        var gpuTextureView = gpuTexture.createView();\n        var texture = new Texture_WebGPU({\n            id: 0,\n            device: this,\n            descriptor: {\n                format: exports.Format.U8_RGBA_RT,\n                width: this.swapChainWidth,\n                height: this.swapChainHeight,\n                depthOrArrayLayers: 0,\n                dimension: exports.TextureDimension.TEXTURE_2D,\n                mipLevelCount: 1,\n                usage: this.swapChainTextureUsage,\n            },\n            skipCreate: true,\n        });\n        texture.depthOrArrayLayers = 1;\n        texture.sampleCount = 1;\n        texture.gpuTexture = gpuTexture;\n        texture.gpuTextureView = gpuTextureView;\n        texture.name = 'Onscreen';\n        this.setResourceName(texture, 'Onscreen Texture');\n        return texture;\n    };\n    Device_WebGPU.prototype.getDevice = function () {\n        return this;\n    };\n    Device_WebGPU.prototype.getCanvas = function () {\n        return this.canvas;\n    };\n    Device_WebGPU.prototype.beginFrame = function () {\n        assert(this.frameCommandEncoderPool.length === 0);\n    };\n    Device_WebGPU.prototype.endFrame = function () {\n        assert(this.frameCommandEncoderPool.every(function (frameCommandEncoder) { return frameCommandEncoder !== null; }));\n        this.device.queue.submit(this.frameCommandEncoderPool.map(function (frameCommandEncoder) {\n            return frameCommandEncoder.finish();\n        }));\n        this.frameCommandEncoderPool = [];\n        // for (let i = 0; i < this.queryPoolsSubmitted.length; i++) {\n        //   const queryPool = this.queryPoolsSubmitted[i];\n        //   queryPool.cpuBuffer.mapAsync(GPUMapMode.READ).then(() => {\n        //     queryPool.results = new BigUint64Array(\n        //       queryPool.cpuBuffer.getMappedRange(),\n        //     );\n        //   });\n        // }\n        // this.queryPoolsSubmitted.length = 0;\n    };\n    Device_WebGPU.prototype.getNextUniqueId = function () {\n        return ++this._resourceUniqueId;\n    };\n    Device_WebGPU.prototype.createBuffer = function (descriptor) {\n        return new Buffer_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createTexture = function (descriptor) {\n        return new Texture_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    /**\n     * @see https://www.w3.org/TR/webgpu/#dom-gpudevice-createsampler\n     * @see https://www.w3.org/TR/webgpu/#GPUSamplerDescriptor\n     */\n    Device_WebGPU.prototype.createSampler = function (descriptor) {\n        return new Sampler_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createRenderTarget = function (descriptor) {\n        var texture = new Texture_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: tslib.__assign(tslib.__assign({}, descriptor), { dimension: exports.TextureDimension.TEXTURE_2D, mipLevelCount: 1, depthOrArrayLayers: 1, usage: exports.TextureUsage.RENDER_TARGET }),\n            sampleCount: descriptor.sampleCount,\n        });\n        texture.depthOrArrayLayers = 1;\n        // @ts-ignore\n        texture.type = exports.ResourceType.RenderTarget;\n        return texture;\n    };\n    Device_WebGPU.prototype.createRenderTargetFromTexture = function (texture) {\n        var _a = texture, format = _a.format, width = _a.width, height = _a.height, depthOrArrayLayers = _a.depthOrArrayLayers, sampleCount = _a.sampleCount, mipLevelCount = _a.mipLevelCount, gpuTexture = _a.gpuTexture, gpuTextureView = _a.gpuTextureView, usage = _a.usage;\n        assert(!!(usage & GPUTextureUsage$1.RENDER_ATTACHMENT));\n        var attachment = new Texture_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: {\n                format: format,\n                width: width,\n                height: height,\n                depthOrArrayLayers: depthOrArrayLayers,\n                dimension: exports.TextureDimension.TEXTURE_2D,\n                mipLevelCount: mipLevelCount,\n                usage: usage,\n            },\n            skipCreate: true,\n        });\n        attachment.depthOrArrayLayers = depthOrArrayLayers;\n        attachment.sampleCount = sampleCount;\n        attachment.gpuTexture = gpuTexture;\n        attachment.gpuTextureView = gpuTextureView;\n        return attachment;\n    };\n    Device_WebGPU.prototype.createProgram = function (descriptor) {\n        var _a, _b;\n        // preprocess GLSL first\n        if ((_a = descriptor.vertex) === null || _a === void 0 ? void 0 : _a.glsl) {\n            descriptor.vertex.glsl = preprocessShader_GLSL(this.queryVendorInfo(), 'vert', descriptor.vertex.glsl);\n        }\n        if ((_b = descriptor.fragment) === null || _b === void 0 ? void 0 : _b.glsl) {\n            descriptor.fragment.glsl = preprocessShader_GLSL(this.queryVendorInfo(), 'frag', descriptor.fragment.glsl);\n        }\n        return new Program_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createProgramSimple = function (descriptor) {\n        return new Program_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createTextureShared = function (descriptor, texture, skipCreate) {\n        var size = {\n            width: descriptor.width,\n            height: descriptor.height,\n            depthOrArrayLayers: descriptor.depthOrArrayLayers,\n        };\n        var mipLevelCount = descriptor.mipLevelCount;\n        var format = translateTextureFormat(descriptor.format);\n        var dimension = translateTextureDimension(descriptor.dimension);\n        var usage = translateTextureUsage(descriptor.usage);\n        texture.gpuTextureformat = format;\n        texture.dimension = descriptor.dimension;\n        texture.format = descriptor.format;\n        texture.width = descriptor.width;\n        texture.height = descriptor.height;\n        texture.depthOrArrayLayers = descriptor.depthOrArrayLayers;\n        texture.mipLevelCount = mipLevelCount;\n        texture.usage = usage;\n        texture.sampleCount = descriptor.sampleCount;\n        if (!skipCreate) {\n            var gpuTexture = this.device.createTexture({\n                size: size,\n                mipLevelCount: mipLevelCount,\n                format: format,\n                dimension: dimension,\n                sampleCount: descriptor.sampleCount,\n                usage: usage,\n            });\n            var gpuTextureView = gpuTexture.createView();\n            texture.gpuTexture = gpuTexture;\n            texture.gpuTextureView = gpuTextureView;\n        }\n    };\n    Device_WebGPU.prototype.getFallbackSampler = function (samplerEntry) {\n        var formatKind = samplerEntry.formatKind;\n        if (formatKind === exports.SamplerFormatKind.Depth && samplerEntry.comparison) {\n            return this.fallbackSamplerComparison;\n        }\n        else {\n            return this.fallbackSamplerFiltering;\n        }\n    };\n    Device_WebGPU.prototype.getFallbackTexture = function (samplerEntry) {\n        var dimension = samplerEntry.dimension, formatKind = samplerEntry.formatKind;\n        if (dimension === exports.TextureDimension.TEXTURE_2D)\n            return formatKind === exports.SamplerFormatKind.Depth\n                ? this.fallbackTexture2DDepth\n                : this.fallbackTexture2D;\n        else if (dimension === exports.TextureDimension.TEXTURE_2D_ARRAY)\n            return this.fallbackTexture2DArray;\n        else if (dimension === exports.TextureDimension.TEXTURE_3D)\n            return this.fallbackTexture3D;\n        else if (dimension === exports.TextureDimension.TEXTURE_CUBE_MAP)\n            return this.fallbackTextureCube;\n        else\n            throw new Error('whoops');\n    };\n    Device_WebGPU.prototype.createFallbackTexture = function (dimension, formatKind) {\n        var depthOrArrayLayers = dimension === exports.TextureDimension.TEXTURE_CUBE_MAP ? 6 : 1;\n        var format = formatKind === exports.SamplerFormatKind.Float ? exports.Format.U8_RGBA_NORM : exports.Format.D24;\n        return this.createTexture({\n            dimension: dimension,\n            format: format,\n            usage: exports.TextureUsage.SAMPLED,\n            width: 1,\n            height: 1,\n            depthOrArrayLayers: depthOrArrayLayers,\n            mipLevelCount: 1,\n        });\n    };\n    Device_WebGPU.prototype.createBindings = function (descriptor) {\n        return new Bindings_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createInputLayout = function (descriptor) {\n        return new InputLayout_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createComputePipeline = function (descriptor) {\n        return new ComputePipeline_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: descriptor,\n        });\n    };\n    Device_WebGPU.prototype.createRenderPipeline = function (descriptor) {\n        return new RenderPipeline_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: tslib.__assign({}, descriptor),\n        });\n    };\n    Device_WebGPU.prototype.createQueryPool = function (type, elemCount) {\n        return new QueryPool_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n            descriptor: {\n                type: type,\n                elemCount: elemCount,\n            },\n        });\n    };\n    Device_WebGPU.prototype.createRenderPipelineInternal = function (renderPipeline, async) {\n        // if (this.device.createRenderPipelineAsync === undefined) {\n        //   async = false;\n        // }\n        var _a;\n        // // If we're already in the process of creating a the pipeline async, no need to kick the process off again...\n        // if (async && renderPipeline.isCreatingAsync) {\n        //   return;\n        // }\n        if (renderPipeline.gpuRenderPipeline !== null) {\n            return;\n        }\n        var descriptor = renderPipeline.descriptor;\n        var program = descriptor.program;\n        var vertexStage = program.vertexStage, fragmentStage = program.fragmentStage;\n        if (vertexStage === null || fragmentStage === null)\n            return;\n        var _b = descriptor.megaStateDescriptor || {}, stencilBack = _b.stencilBack, stencilFront = _b.stencilFront, rest = tslib.__rest(_b, [\"stencilBack\", \"stencilFront\"]);\n        var copied = copyMegaState(defaultMegaState);\n        descriptor.megaStateDescriptor = tslib.__assign(tslib.__assign(tslib.__assign({}, copied), { stencilBack: tslib.__assign(tslib.__assign({}, copied.stencilBack), stencilBack), stencilFront: tslib.__assign(tslib.__assign({}, copied.stencilFront), stencilFront) }), rest);\n        var defaultAttachmentState = descriptor.megaStateDescriptor.attachmentsState[0];\n        descriptor.colorAttachmentFormats.forEach(function (format, i) {\n            if (!descriptor.megaStateDescriptor.attachmentsState[i]) {\n                descriptor.megaStateDescriptor.attachmentsState[i] =\n                    copyAttachmentState(undefined, defaultAttachmentState);\n            }\n        });\n        var primitive = translatePrimitiveState((_a = descriptor.topology) !== null && _a !== void 0 ? _a : exports.PrimitiveTopology.TRIANGLES, descriptor.megaStateDescriptor);\n        var targets = translateTargets(descriptor.colorAttachmentFormats, descriptor.megaStateDescriptor);\n        var depthStencil = translateDepthStencilState(descriptor.depthStencilAttachmentFormat, descriptor.megaStateDescriptor);\n        var buffers = undefined;\n        if (descriptor.inputLayout !== null)\n            buffers = descriptor.inputLayout.buffers;\n        var sampleCount = descriptor.sampleCount;\n        // renderPipeline.isCreatingAsync = true;\n        var gpuRenderPipelineDescriptor = {\n            // layout,\n            layout: 'auto',\n            vertex: tslib.__assign(tslib.__assign({}, vertexStage), { buffers: buffers }),\n            primitive: primitive,\n            depthStencil: depthStencil,\n            multisample: {\n                count: sampleCount,\n            },\n            fragment: tslib.__assign(tslib.__assign({}, fragmentStage), { targets: targets }),\n        };\n        // TODO: async creation\n        // @see https://www.w3.org/TR/webgpu/#dom-gpudevice-createrenderpipeline\n        // renderPipeline.gpuRenderPipeline =\n        //   this.device.createRenderPipeline(gpuRenderPipeline);\n        // if (renderPipeline.name !== undefined)\n        //   renderPipeline.gpuRenderPipeline.label = renderPipeline.name;\n        // if (async) {\n        //   const gpuRenderPipeline = await this.device.createRenderPipelineAsync(\n        //     gpuRenderPipelineDescriptor,\n        //   );\n        //   // We might have created a sync pipeline while we were async building; no way to cancel the async\n        //   // pipeline build at this point, so just chuck it out :/\n        //   if (renderPipeline.gpuRenderPipeline === null)\n        //     renderPipeline.gpuRenderPipeline = gpuRenderPipeline;\n        // } else {\n        renderPipeline.gpuRenderPipeline = this.device.createRenderPipeline(gpuRenderPipelineDescriptor);\n        // }\n        // // if (renderPipeline.ResourceName !== undefined)\n        // //     renderPipeline.gpuRenderPipeline.label = renderPipeline.ResourceName;\n        // renderPipeline.isCreatingAsync = false;\n    };\n    Device_WebGPU.prototype.createReadback = function () {\n        return new Readback_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n        });\n    };\n    Device_WebGPU.prototype.createRenderBundle = function () {\n        return new RenderBundle_WebGPU({\n            id: this.getNextUniqueId(),\n            device: this,\n        });\n    };\n    Device_WebGPU.prototype.createRenderPass = function (renderPassDescriptor) {\n        var pass = this.renderPassPool.pop();\n        if (pass === undefined) {\n            pass = new RenderPass_WebGPU(this);\n        }\n        var frameCommandEncoder = this.frameCommandEncoderPool.pop();\n        if (frameCommandEncoder === undefined) {\n            frameCommandEncoder = this.device.createCommandEncoder();\n        }\n        pass.beginRenderPass(frameCommandEncoder, renderPassDescriptor);\n        return pass;\n    };\n    Device_WebGPU.prototype.createComputePass = function () {\n        var pass = this.computePassPool.pop();\n        if (pass === undefined)\n            pass = new ComputePass_WebGPU();\n        var frameCommandEncoder = this.frameCommandEncoderPool.pop();\n        if (frameCommandEncoder === undefined) {\n            frameCommandEncoder = this.device.createCommandEncoder();\n        }\n        pass.beginComputePass(frameCommandEncoder);\n        return pass;\n    };\n    Device_WebGPU.prototype.submitPass = function (_pass) {\n        var pass = _pass;\n        if (pass instanceof RenderPass_WebGPU) {\n            // release encoder\n            this.frameCommandEncoderPool.push(pass.frameCommandEncoder);\n            pass.finish();\n            this.renderPassPool.push(pass);\n            // if (pass.occlusionQueryPool !== null) {\n            //   this.queryPoolsSubmitted.push(pass.occlusionQueryPool);\n            // }\n        }\n        else if (pass instanceof ComputePass_WebGPU) {\n            this.frameCommandEncoderPool.push(pass.frameCommandEncoder);\n            pass.finish();\n            this.computePassPool.push(pass);\n        }\n    };\n    Device_WebGPU.prototype.copySubTexture2D = function (dst_, dstX, dstY, src_, srcX, srcY, depthOrArrayLayers) {\n        var cmd = this.device.createCommandEncoder();\n        var dst = dst_;\n        var src = src_;\n        var srcCopy = {\n            texture: src.gpuTexture,\n            origin: [srcX, srcY, 0],\n            mipLevel: 0,\n            aspect: 'all',\n        };\n        var dstCopy = {\n            texture: dst.gpuTexture,\n            origin: [dstX, dstY, 0],\n            mipLevel: 0,\n            aspect: 'all',\n        };\n        assert(!!(src.usage & GPUTextureUsage$1.COPY_SRC));\n        assert(!!(dst.usage & GPUTextureUsage$1.COPY_DST));\n        cmd.copyTextureToTexture(srcCopy, dstCopy, [\n            src.width,\n            src.height,\n            depthOrArrayLayers || 1,\n        ]);\n        this.device.queue.submit([cmd.finish()]);\n    };\n    Device_WebGPU.prototype.queryLimits = function () {\n        // GPUAdapter.limits\n        // @see https://www.w3.org/TR/webgpu/#gpu-supportedlimits\n        return {\n            uniformBufferMaxPageWordSize: this.device.limits.maxUniformBufferBindingSize >>> 2,\n            uniformBufferWordAlignment: this.device.limits.minUniformBufferOffsetAlignment >>> 2,\n            supportedSampleCounts: [1],\n            occlusionQueriesRecommended: true,\n            computeShadersSupported: true,\n        };\n    };\n    Device_WebGPU.prototype.queryTextureFormatSupported = function (format, width, height) {\n        if (isFormatTextureCompressionBC(format)) {\n            if (!this.featureTextureCompressionBC)\n                return false;\n            var bb = getFormatBlockSize(format);\n            if (width % bb !== 0 || height % bb !== 0)\n                return false;\n            return this.featureTextureCompressionBC;\n        }\n        switch (format) {\n            case exports.Format.U16_RGBA_NORM:\n                return false;\n            case exports.Format.F32_RGBA:\n                return false; // unfilterable\n        }\n        return true;\n    };\n    Device_WebGPU.prototype.queryPlatformAvailable = function () {\n        // TODO: should listen to lost event\n        return true;\n    };\n    Device_WebGPU.prototype.queryVendorInfo = function () {\n        return this;\n    };\n    Device_WebGPU.prototype.queryRenderPass = function (o) {\n        var pass = o;\n        return pass.descriptor;\n    };\n    Device_WebGPU.prototype.queryRenderTarget = function (o) {\n        var attachment = o;\n        return attachment;\n    };\n    Device_WebGPU.prototype.setResourceName = function (o, s) {\n        o.name = s;\n        if (o.type === exports.ResourceType.Buffer) {\n            var r = o;\n            r.gpuBuffer.label = s;\n        }\n        else if (o.type === exports.ResourceType.Texture) {\n            var r = o;\n            r.gpuTexture.label = s;\n            r.gpuTextureView.label = s;\n        }\n        else if (o.type === exports.ResourceType.RenderTarget) {\n            var r = o;\n            r.gpuTexture.label = s;\n            r.gpuTextureView.label = s;\n        }\n        else if (o.type === exports.ResourceType.Sampler) {\n            var r = o;\n            r.gpuSampler.label = s;\n        }\n        else if (o.type === exports.ResourceType.RenderPipeline) {\n            var r = o;\n            if (r.gpuRenderPipeline !== null)\n                r.gpuRenderPipeline.label = s;\n        }\n    };\n    Device_WebGPU.prototype.setResourceLeakCheck = function (o, v) { };\n    Device_WebGPU.prototype.checkForLeaks = function () { };\n    Device_WebGPU.prototype.programPatched = function (o) { };\n    Device_WebGPU.prototype.pipelineQueryReady = function (o) {\n        var renderPipeline = o;\n        return renderPipeline.gpuRenderPipeline !== null;\n    };\n    Device_WebGPU.prototype.pipelineForceReady = function (o) {\n        var renderPipeline = o;\n        this.createRenderPipelineInternal(renderPipeline, false);\n    };\n    return Device_WebGPU;\n}());\n\nvar WebGPUDeviceContribution = /** @class */ (function () {\n    function WebGPUDeviceContribution(pluginOptions) {\n        this.pluginOptions = pluginOptions;\n    }\n    WebGPUDeviceContribution.prototype.createSwapChain = function ($canvas) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var adapter, xrCompatible, e_1, optionalFeatures, requiredFeatures, device, onContextLost_1, context;\n            return tslib.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // eslint-disable-next-line\n                        if (globalThis.navigator.gpu === undefined)\n                            return [2 /*return*/, null];\n                        adapter = null;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        xrCompatible = this.pluginOptions.xrCompatible;\n                        return [4 /*yield*/, globalThis.navigator.gpu.requestAdapter({\n                                xrCompatible: xrCompatible,\n                            })];\n                    case 2:\n                        // eslint-disable-next-line\n                        adapter = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _a.sent();\n                        console.log(e_1);\n                        return [3 /*break*/, 4];\n                    case 4:\n                        if (adapter === null)\n                            return [2 /*return*/, null];\n                        optionalFeatures = [\n                            // 'depth24unorm-stencil8',\n                            'depth32float-stencil8',\n                            'texture-compression-bc',\n                            'float32-filterable',\n                        ];\n                        requiredFeatures = optionalFeatures.filter(function (feature) {\n                            return adapter.features.has(feature);\n                        });\n                        return [4 /*yield*/, adapter.requestDevice({ requiredFeatures: requiredFeatures })];\n                    case 5:\n                        device = _a.sent();\n                        if (device) {\n                            onContextLost_1 = this.pluginOptions.onContextLost;\n                            device.lost.then(function () {\n                                if (onContextLost_1) {\n                                    onContextLost_1();\n                                }\n                            });\n                        }\n                        if (device === null)\n                            return [2 /*return*/, null];\n                        context = $canvas.getContext('webgpu');\n                        if (!context)\n                            return [2 /*return*/, null];\n                        _a.label = 6;\n                    case 6:\n                        _a.trys.push([6, 8, , 9]);\n                        return [4 /*yield*/, __wbg_init(this.pluginOptions.shaderCompilerPath)];\n                    case 7:\n                        _a.sent();\n                        return [3 /*break*/, 9];\n                    case 8:\n                        _a.sent();\n                        return [3 /*break*/, 9];\n                    case 9: return [2 /*return*/, new Device_WebGPU(adapter, device, $canvas, context, glsl_compile, WGSLComposer && new WGSLComposer())];\n                }\n            });\n        });\n    };\n    return WebGPUDeviceContribution;\n}());\n\nexports.IsDepthReversed = IsDepthReversed;\nexports.OpaqueBlack = OpaqueBlack;\nexports.OpaqueWhite = OpaqueWhite;\nexports.TransparentBlack = TransparentBlack;\nexports.TransparentWhite = TransparentWhite;\nexports.UNIFORM_SETTERS = UNIFORM_SETTERS;\nexports.WebGLDeviceContribution = WebGLDeviceContribution;\nexports.WebGPUDeviceContribution = WebGPUDeviceContribution;\nexports.align = align;\nexports.alignNonPowerOfTwo = alignNonPowerOfTwo;\nexports.arrayCopy = arrayCopy;\nexports.arrayEqual = arrayEqual;\nexports.assert = assert;\nexports.assertExists = assertExists;\nexports.bindingsDescriptorCopy = bindingsDescriptorCopy;\nexports.bindingsDescriptorEquals = bindingsDescriptorEquals;\nexports.bisectRight = bisectRight;\nexports.bufferBindingCopy = bufferBindingCopy;\nexports.colorCopy = colorCopy;\nexports.colorEqual = colorEqual;\nexports.colorNewCopy = colorNewCopy;\nexports.colorNewFromRGBA = colorNewFromRGBA;\nexports.compareDepthValues = compareDepthValues;\nexports.copyAttachmentState = copyAttachmentState;\nexports.copyAttachmentStateFromSimple = copyAttachmentStateFromSimple;\nexports.copyMegaState = copyMegaState;\nexports.copyStencilFaceState = copyStencilFaceState;\nexports.defaultBindingLayoutSamplerDescriptor = defaultBindingLayoutSamplerDescriptor;\nexports.defaultMegaState = defaultMegaState;\nexports.fallbackUndefined = fallbackUndefined;\nexports.fillArray = fillArray;\nexports.fullscreenMegaState = fullscreenMegaState;\nexports.getAttributeLocations = getAttributeLocations;\nexports.getDefines = getDefines;\nexports.getFormatByteSize = getFormatByteSize;\nexports.getFormatCompByteSize = getFormatCompByteSize;\nexports.getFormatCompFlags = getFormatCompFlags;\nexports.getFormatCompFlagsComponentCount = getFormatCompFlagsComponentCount;\nexports.getFormatComponentCount = getFormatComponentCount;\nexports.getFormatFlags = getFormatFlags;\nexports.getFormatSamplerKind = getFormatSamplerKind;\nexports.getFormatTypeFlags = getFormatTypeFlags;\nexports.getFormatTypeFlagsByteSize = getFormatTypeFlagsByteSize;\nexports.getUniformSetter = getUniformSetter;\nexports.getUniforms = getUniforms;\nexports.inputLayoutBufferDescriptorCopy = inputLayoutBufferDescriptorCopy;\nexports.inputLayoutBufferDescriptorEquals = inputLayoutBufferDescriptorEquals;\nexports.inputLayoutDescriptorCopy = inputLayoutDescriptorCopy;\nexports.inputLayoutDescriptorEquals = inputLayoutDescriptorEquals;\nexports.isPowerOfTwo = isPowerOfTwo;\nexports.isTypedArray = isTypedArray;\nexports.leftPad = leftPad;\nexports.makeFormat = makeFormat;\nexports.makeMegaState = makeMegaState;\nexports.makeTextureDescriptor2D = makeTextureDescriptor2D;\nexports.nArray = nArray;\nexports.nullify = nullify;\nexports.parseUniformName = parseUniformName;\nexports.prependLineNo = prependLineNo;\nexports.preprocessProgram_GLSL = preprocessProgram_GLSL;\nexports.preprocessShader_GLSL = preprocessShader_GLSL;\nexports.range = range;\nexports.renderPipelineDescriptorCopy = renderPipelineDescriptorCopy;\nexports.renderPipelineDescriptorEquals = renderPipelineDescriptorEquals;\nexports.reverseDepthForClearValue = reverseDepthForClearValue;\nexports.reverseDepthForCompareFunction = reverseDepthForCompareFunction;\nexports.reverseDepthForDepthOffset = reverseDepthForDepthOffset;\nexports.reverseDepthForOrthographicProjectionMatrix = reverseDepthForOrthographicProjectionMatrix;\nexports.reverseDepthForPerspectiveProjectionMatrix = reverseDepthForPerspectiveProjectionMatrix;\nexports.samplerBindingCopy = samplerBindingCopy;\nexports.samplerDescriptorEquals = samplerDescriptorEquals;\nexports.setAttachmentStateSimple = setAttachmentStateSimple;\nexports.setBitFlagEnabled = setBitFlagEnabled;\nexports.setFormatComponentCount = setFormatComponentCount;\nexports.setFormatFlags = setFormatFlags;\nexports.setMegaStateFlags = setMegaStateFlags;\nexports.spliceBisectRight = spliceBisectRight;\nexports.stencilFaceStateEquals = stencilFaceStateEquals;\nexports.textureBindingCopy = textureBindingCopy;\nexports.vertexAttributeDescriptorCopy = vertexAttributeDescriptorCopy;\nexports.vertexAttributeDescriptorEquals = vertexAttributeDescriptorEquals;\n//# sourceMappingURL=index.js.map\n"]}