{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\nvar glMatrix = require('gl-matrix');\nvar gMath = require('@antv/g-math');\nvar util = require('@antv/util');\n\nvar tmpVec3a = glMatrix.vec3.create();\nvar tmpVec3b = glMatrix.vec3.create();\nvar tmpVec3c = glMatrix.vec3.create();\nvar tmpMat4 = glMatrix.mat4.create();\n/**\n * pick shape(s) with Mouse/Touch event\n *\n * 1. find AABB with r-tree\n * 2. do math calculation with geometry in an accurate way\n */\nvar CanvasPickerPlugin = /** @class */ (function () {\n    function CanvasPickerPlugin() {\n        var _this = this;\n        this.isHit = function (displayObject, position, worldTransform, isClipPath) {\n            // use picker for current shape's type\n            var pick = _this.context.pointInPathPickerFactory[displayObject.nodeName];\n            if (pick) {\n                // invert with world matrix\n                var invertWorldMat = glMatrix.mat4.invert(tmpMat4, worldTransform);\n                // transform client position to local space, do picking in local space\n                var localPosition = glMatrix.vec3.transformMat4(tmpVec3b, glMatrix.vec3.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);\n                // account for anchor\n                var halfExtents = displayObject.getGeometryBounds().halfExtents;\n                var anchor = displayObject.parsedStyle.anchor;\n                localPosition[0] += ((anchor && anchor[0]) || 0) * halfExtents[0] * 2;\n                localPosition[1] += ((anchor && anchor[1]) || 0) * halfExtents[1] * 2;\n                if (pick(displayObject, new gLite.Point(localPosition[0], localPosition[1]), isClipPath, _this.isPointInPath, _this.context, _this.runtime)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        /**\n         * use native picking method\n         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath\n         */\n        this.isPointInPath = function (displayObject, position) {\n            var context = _this.runtime.offscreenCanvasCreator.getOrCreateContext(_this.context.config.offscreenCanvas);\n            var generatePath = _this.context.pathGeneratorFactory[displayObject.nodeName];\n            if (generatePath) {\n                context.beginPath();\n                generatePath(context, displayObject.parsedStyle);\n                context.closePath();\n            }\n            return context.isPointInPath(position.x, position.y);\n        };\n    }\n    CanvasPickerPlugin.prototype.apply = function (context, runtime) {\n        var _this = this;\n        var _a;\n        var renderingService = context.renderingService, renderingContext = context.renderingContext;\n        this.context = context;\n        this.runtime = runtime;\n        var document = (_a = renderingContext.root) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n        renderingService.hooks.pick.tapPromise(CanvasPickerPlugin.tag, function (result) { return tslib.__awaiter(_this, void 0, void 0, function () {\n            return tslib.__generator(this, function (_a) {\n                return [2 /*return*/, this.pick(document, result)];\n            });\n        }); });\n        renderingService.hooks.pickSync.tap(CanvasPickerPlugin.tag, function (result) {\n            return _this.pick(document, result);\n        });\n    };\n    CanvasPickerPlugin.prototype.pick = function (document, result) {\n        var e_1, _a;\n        var topmost = result.topmost, _b = result.position, x = _b.x, y = _b.y;\n        // position in world space\n        var position = glMatrix.vec3.set(tmpVec3a, x, y, 0);\n        // query by AABB first with spatial index(r-tree)\n        var hitTestList = document.elementsFromBBox(position[0], position[1], position[0], position[1]);\n        // test with clip path & origin shape\n        // @see https://github.com/antvis/g/issues/1064\n        var pickedDisplayObjects = [];\n        try {\n            for (var hitTestList_1 = tslib.__values(hitTestList), hitTestList_1_1 = hitTestList_1.next(); !hitTestList_1_1.done; hitTestList_1_1 = hitTestList_1.next()) {\n                var displayObject = hitTestList_1_1.value;\n                var worldTransform = displayObject.getWorldTransform();\n                var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false);\n                if (isHitOriginShape) {\n                    // should look up in the ancestor node\n                    var clipped = gLite.findClosestClipPathTarget(displayObject);\n                    if (clipped) {\n                        var clipPath = clipped.parsedStyle.clipPath;\n                        var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);\n                        if (isHitClipPath) {\n                            if (topmost) {\n                                result.picked = [displayObject];\n                                return result;\n                            }\n                            else {\n                                pickedDisplayObjects.push(displayObject);\n                            }\n                        }\n                    }\n                    else {\n                        if (topmost) {\n                            result.picked = [displayObject];\n                            return result;\n                        }\n                        else {\n                            pickedDisplayObjects.push(displayObject);\n                        }\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (hitTestList_1_1 && !hitTestList_1_1.done && (_a = hitTestList_1.return)) _a.call(hitTestList_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        result.picked = pickedDisplayObjects;\n        return result;\n    };\n    CanvasPickerPlugin.tag = 'CanvasPicker';\n    return CanvasPickerPlugin;\n}());\n\nfunction isPointInPath$7(displayObject, position, isClipPath) {\n    var _a = displayObject.parsedStyle, r = _a.r, fill = _a.fill, stroke = _a.stroke, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, pointerEvents = _a.pointerEvents;\n    var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;\n    var absDistance = gMath.distance(r, r, position.x, position.y);\n    var _b = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _b[0], hasStroke = _b[1];\n    if ((hasFill && hasStroke) || isClipPath) {\n        return absDistance <= r + halfLineWidth;\n    }\n    if (hasFill) {\n        return absDistance <= r;\n    }\n    if (hasStroke) {\n        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n    }\n    return false;\n}\n\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n    return squareX / (rx * rx) + squareY / (ry * ry);\n}\nfunction isPointInPath$6(displayObject, position, isClipPath) {\n    var _a = displayObject.parsedStyle, rx = _a.rx, ry = _a.ry, fill = _a.fill, stroke = _a.stroke, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, pointerEvents = _a.pointerEvents;\n    var x = position.x, y = position.y;\n    var _b = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _b[0], hasStroke = _b[1];\n    var halfLineWith = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;\n    var squareX = (x - rx) * (x - rx);\n    var squareY = (y - ry) * (y - ry);\n    // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n    if ((hasFill && hasStroke) || isClipPath) {\n        return (ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=\n            1);\n    }\n    if (hasFill) {\n        return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n    }\n    if (hasStroke) {\n        return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >=\n            1 &&\n            ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=\n                1);\n    }\n    return false;\n}\n\nfunction inBox(minX, minY, width, height, x, y) {\n    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\n}\nfunction inRect(minX, minY, width, height, lineWidth, x, y) {\n    var halfWidth = lineWidth / 2;\n    // 将四个边看做矩形来检测，比边的检测算法要快\n    return (inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边\n        inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边\n        inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边\n        inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)); // 左边\n}\nfunction inArc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {\n    var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\n    // if (angle < startAngle || angle > endAngle) {\n    //   return false;\n    // }\n    var point = {\n        x: cx + r * Math.cos(angle),\n        y: cy + r * Math.sin(angle),\n    };\n    return gMath.distance(point.x, point.y, x, y) <= lineWidth / 2;\n}\nfunction inLine(x1, y1, x2, y2, lineWidth, x, y) {\n    var minX = Math.min(x1, x2);\n    var maxX = Math.max(x1, x2);\n    var minY = Math.min(y1, y2);\n    var maxY = Math.max(y1, y2);\n    var halfWidth = lineWidth / 2;\n    // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n    // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n    if (!(x >= minX - halfWidth &&\n        x <= maxX + halfWidth &&\n        y >= minY - halfWidth &&\n        y <= maxY + halfWidth)) {\n        return false;\n    }\n    // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n    return gMath.linePointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\nfunction inPolyline(points, lineWidth, x, y, isClose) {\n    var count = points.length;\n    if (count < 2) {\n        return false;\n    }\n    for (var i = 0; i < count - 1; i++) {\n        var x1 = points[i][0];\n        var y1 = points[i][1];\n        var x2 = points[i + 1][0];\n        var y2 = points[i + 1][1];\n        if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {\n            return true;\n        }\n    }\n    // 如果封闭，则计算起始点和结束点的边\n    if (isClose) {\n        var first = points[0];\n        var last = points[count - 1];\n        if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\n            return true;\n        }\n    }\n    return false;\n}\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nvar tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x) {\n    if (Math.abs(x) < tolerance) {\n        return 0;\n    }\n    return x < 0 ? -1 : 1;\n}\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n        Math.min(p1[0], p2[0]) <= q[0] &&\n        q[0] <= Math.max(p1[0], p2[0]) &&\n        Math.min(p1[1], p2[1]) <= q[1] &&\n        q[1] <= Math.max(p1[1], p2[1])) {\n        return true;\n    }\n    return false;\n}\n// 判断点P在多边形内-射线法\nfunction inPolygon(points, x, y) {\n    var isHit = false;\n    var n = points.length;\n    if (n <= 2) {\n        // svg 中点小于 3 个时，不显示，也无法被拾取\n        return false;\n    }\n    for (var i = 0; i < n; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % n];\n        if (onSegment(p1, p2, [x, y])) {\n            // 点在多边形一条边上\n            return true;\n        }\n        // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n        // 后一个判断被测点 在 射线与边交点 的左边\n        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {\n            isHit = !isHit;\n        }\n    }\n    return isHit;\n}\nfunction inPolygons(polygons, x, y) {\n    var isHit = false;\n    for (var i = 0; i < polygons.length; i++) {\n        var points = polygons[i];\n        isHit = inPolygon(points, x, y);\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\n\nfunction isPointInPath$5(displayObject, position, isClipPath) {\n    var _a = displayObject.parsedStyle, x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, pointerEvents = _a.pointerEvents, fill = _a.fill, stroke = _a.stroke;\n    var _d = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasStroke = _d[1];\n    if ((!hasStroke && !isClipPath) || !lineWidth) {\n        return false;\n    }\n    return inLine(x1, y1, x2, y2, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y);\n}\n\n// TODO: replace it with method in @antv/util\nfunction isPointInStroke(segments, lineWidth, px, py, length) {\n    var isHit = false;\n    var halfWidth = lineWidth / 2;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;\n        // 如果在前面已经生成过包围盒，直接按照包围盒计算\n        if (box &&\n            !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {\n            continue;\n        }\n        switch (segment.command) {\n            // L 和 Z 都是直线， M 不进行拾取\n            case 'L':\n            case 'Z':\n                isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);\n                if (isHit) {\n                    return true;\n                }\n                break;\n            case 'Q':\n                var qDistance = gMath.quadPointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);\n                isHit = qDistance <= lineWidth / 2;\n                if (isHit) {\n                    return true;\n                }\n                break;\n            case 'C':\n                var cDistance = gMath.cubicPointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n                params[2], params[3], params[4], params[5], params[6], px, py, length);\n                isHit = cDistance <= lineWidth / 2;\n                if (isHit) {\n                    return true;\n                }\n                break;\n            case 'A':\n                // cache conversion result\n                if (!segment.cubicParams) {\n                    segment.cubicParams = util.arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], undefined);\n                }\n                var args = segment.cubicParams;\n                // fixArc\n                var prePointInCubic = prePoint;\n                for (var i_1 = 0; i_1 < args.length; i_1 += 6) {\n                    var cDistance_1 = gMath.cubicPointDistance(prePointInCubic[0], // 上一段结束位置, 即 C 的起始点\n                    prePointInCubic[1], args[i_1], args[i_1 + 1], args[i_1 + 2], args[i_1 + 3], args[i_1 + 4], args[i_1 + 5], px, py, length);\n                    prePointInCubic = [args[i_1 + 4], args[i_1 + 5]];\n                    isHit = cDistance_1 <= lineWidth / 2;\n                    if (isHit) {\n                        return true;\n                    }\n                }\n                break;\n        }\n    }\n    return isHit;\n}\nfunction isPointInPath$4(displayObject, position, isClipPath, isPointInPath, renderingPluginContext, runtime) {\n    var _a = displayObject.parsedStyle, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, stroke = _a.stroke, fill = _a.fill, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, path = _a.path, pointerEvents = _a.pointerEvents;\n    var segments = path.segments, hasArc = path.hasArc, polylines = path.polylines, polygons = path.polygons;\n    var _d = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, \n    // Only a closed path can be filled.\n    (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill, stroke), 2), hasFill = _d[0], hasStroke = _d[1];\n    var totalLength = gLite.getOrCalculatePathTotalLength(displayObject);\n    var isHit = false;\n    if (hasFill || isClipPath) {\n        if (hasArc) {\n            // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n            isHit = isPointInPath(displayObject, position);\n        }\n        else {\n            // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n            isHit =\n                inPolygons(polygons, position.x + x, position.y + y) ||\n                    inPolygons(polylines, position.x + x, position.y + y);\n        }\n        return isHit;\n    }\n    else if (hasStroke || isClipPath) {\n        isHit = isPointInStroke(segments, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, totalLength);\n    }\n    return isHit;\n}\n\nfunction isPointInPath$3(displayObject, position, isClipPath) {\n    var _a = displayObject.parsedStyle, stroke = _a.stroke, fill = _a.fill, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, points = _a.points, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, pointerEvents = _a.pointerEvents;\n    var _d = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _d[0], hasStroke = _d[1];\n    var isHit = false;\n    if (hasStroke || isClipPath) {\n        isHit = inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, true);\n    }\n    if (!isHit && (hasFill || isClipPath)) {\n        isHit = inPolygon(points.points, position.x + x, position.y + y);\n    }\n    return isHit;\n}\n\nfunction isPointInPath$2(displayObject, position, isClipPath) {\n    var _a = displayObject.parsedStyle, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, points = _a.points, _b = _a.defX, x = _b === void 0 ? 0 : _b, _c = _a.defY, y = _c === void 0 ? 0 : _c, pointerEvents = _a.pointerEvents, fill = _a.fill, stroke = _a.stroke;\n    var _d = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasStroke = _d[1];\n    if ((!hasStroke && !isClipPath) || !lineWidth) {\n        return false;\n    }\n    return inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, false);\n}\n\nfunction isPointInPath$1(displayObject, position, isClipPath, isPointInPath, runtime) {\n    var _a = displayObject.parsedStyle, radius = _a.radius, fill = _a.fill, stroke = _a.stroke, lineWidth = _a.lineWidth, increasedLineWidthForHitTesting = _a.increasedLineWidthForHitTesting, width = _a.width, height = _a.height, pointerEvents = _a.pointerEvents;\n    var _b = tslib.__read(gLite.isFillOrStrokeAffected(pointerEvents, fill, stroke), 2), hasFill = _b[0], hasStroke = _b[1];\n    var hasRadius = radius && radius.some(function (r) { return r !== 0; });\n    var lineWidthForHitTesting = (lineWidth || 0) + (increasedLineWidthForHitTesting || 0);\n    // 无圆角时的策略\n    if (!hasRadius) {\n        var halfWidth = lineWidthForHitTesting / 2;\n        // 同时填充和带有边框\n        if ((hasFill && hasStroke) || isClipPath) {\n            return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);\n        }\n        // 仅填充\n        if (hasFill) {\n            return inBox(0, 0, width, height, position.x, position.y);\n        }\n        if (hasStroke) {\n            return inRect(0, 0, width, height, lineWidthForHitTesting, position.x, position.y);\n        }\n    }\n    else {\n        var isHit = false;\n        if (hasStroke || isClipPath) {\n            isHit = inRectWithRadius(0, 0, width, height, radius.map(function (r) {\n                return util.clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));\n            }), lineWidthForHitTesting, position.x, position.y);\n        }\n        // 仅填充时带有圆角的矩形直接通过图形拾取\n        // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n        if (!isHit && (hasFill || isClipPath)) {\n            isHit = isPointInPath(displayObject, position);\n        }\n        return isHit;\n    }\n    return false;\n}\nfunction inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x, y) {\n    var _a = tslib.__read(radiusArray, 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];\n    return (inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) ||\n        inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x, y) ||\n        inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x, y) ||\n        inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) ||\n        inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) ||\n        inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x, y) ||\n        inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x, y) ||\n        inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y));\n}\n\nfunction isPointInPath(displayObject, position, isClipPath, isPointInPath, renderingPluginContext, runtime) {\n    var _a = displayObject.parsedStyle, pointerEvents = _a.pointerEvents, width = _a.width, height = _a.height;\n    if (pointerEvents === 'non-transparent-pixel') {\n        var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;\n        var canvas = runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n        var context = runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {\n            willReadFrequently: true,\n        });\n        canvas.width = width;\n        canvas.height = height;\n        renderingPluginContext.defaultStyleRendererFactory[gLite.Shape.IMAGE].render(context, displayObject.parsedStyle, displayObject, undefined, undefined, undefined);\n        var imagedata = context.getImageData(position.x, position.y, 1, 1).data;\n        return imagedata.every(function (component) { return component !== 0; });\n    }\n    return true;\n}\n\nvar Plugin = /** @class */ (function (_super) {\n    tslib.__extends(Plugin, _super);\n    function Plugin() {\n        var _this = _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments), false)) || this;\n        _this.name = 'canvas-picker';\n        return _this;\n    }\n    Plugin.prototype.init = function () {\n        var _a;\n        var trueFunc = function () { return true; };\n        var pointInPathPickerFactory = (_a = {},\n            _a[gLite.Shape.CIRCLE] = isPointInPath$7,\n            _a[gLite.Shape.ELLIPSE] = isPointInPath$6,\n            _a[gLite.Shape.RECT] = isPointInPath$1,\n            _a[gLite.Shape.LINE] = isPointInPath$5,\n            _a[gLite.Shape.POLYLINE] = isPointInPath$2,\n            _a[gLite.Shape.POLYGON] = isPointInPath$3,\n            _a[gLite.Shape.PATH] = isPointInPath$4,\n            _a[gLite.Shape.TEXT] = trueFunc,\n            _a[gLite.Shape.GROUP] = null,\n            _a[gLite.Shape.IMAGE] = isPointInPath,\n            _a[gLite.Shape.HTML] = null,\n            _a[gLite.Shape.MESH] = null,\n            _a);\n        // @ts-ignore\n        this.context.pointInPathPickerFactory = pointInPathPickerFactory;\n        this.addRenderingPlugin(new CanvasPickerPlugin());\n    };\n    Plugin.prototype.destroy = function () {\n        // @ts-ignore\n        delete this.context.pointInPathPickerFactory;\n        this.removeAllRenderingPlugins();\n    };\n    return Plugin;\n}(gLite.AbstractRendererPlugin));\n\nexports.Plugin = Plugin;\n//# sourceMappingURL=index.js.map\n"]}