{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\nvar util = require('@antv/util');\n\nfunction generatePath$6(context, parsedStyle) {\n    var r = parsedStyle.r;\n    context.arc(r, r, r, 0, Math.PI * 2, false);\n}\n\nfunction generatePath$5(context, parsedStyle) {\n    var rxInPixels = parsedStyle.rx, ryInPixels = parsedStyle.ry;\n    var rx = rxInPixels;\n    var ry = ryInPixels;\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse\n    if (context.ellipse) {\n        context.ellipse(rx, ry, rx, ry, 0, 0, Math.PI * 2, false);\n    }\n    else {\n        // 如果不支持，则使用圆来绘制，进行变形\n        var r = rx > ry ? rx : ry;\n        var scaleX = rx > ry ? 1 : rx / ry;\n        var scaleY = rx > ry ? ry / rx : 1;\n        context.save();\n        context.scale(scaleX, scaleY);\n        context.arc(r, r, r, 0, Math.PI * 2);\n    }\n}\n\nfunction generatePath$4(context, parsedStyle) {\n    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n    var startOffsetX = 0;\n    var startOffsetY = 0;\n    var endOffsetX = 0;\n    var endOffsetY = 0;\n    var rad = 0;\n    var x;\n    var y;\n    if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n        x = x2 - x1;\n        y = y2 - y1;\n        rad = Math.atan2(y, x);\n        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n    }\n    if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n        x = x1 - x2;\n        y = y1 - y2;\n        rad = Math.atan2(y, x);\n        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n    }\n    context.moveTo(x1 - defX + startOffsetX, y1 - defY + startOffsetY);\n    context.lineTo(x2 - defX + endOffsetX, y2 - defY + endOffsetY);\n}\n\nfunction generatePath$3(context, parsedStyle) {\n    var _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n    var _c = parsedStyle.path, absolutePath = _c.absolutePath, segments = _c.segments;\n    var startOffsetX = 0;\n    var startOffsetY = 0;\n    var endOffsetX = 0;\n    var endOffsetY = 0;\n    var rad = 0;\n    var x;\n    var y;\n    if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n        var _d = tslib.__read(markerStart.parentNode.getStartTangent(), 2), p1 = _d[0], p2 = _d[1];\n        x = p1[0] - p2[0];\n        y = p1[1] - p2[1];\n        rad = Math.atan2(y, x);\n        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n    }\n    if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n        var _e = tslib.__read(markerEnd.parentNode.getEndTangent(), 2), p1 = _e[0], p2 = _e[1];\n        x = p1[0] - p2[0];\n        y = p1[1] - p2[1];\n        rad = Math.atan2(y, x);\n        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n    }\n    for (var i = 0; i < absolutePath.length; i++) {\n        var params = absolutePath[i];\n        var command = params[0];\n        var nextSegment = absolutePath[i + 1];\n        var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);\n        var useEndOffset = (i === absolutePath.length - 1 ||\n            (nextSegment && (nextSegment[0] === 'M' || nextSegment[0] === 'Z'))) &&\n            endOffsetX !== 0 &&\n            endOffsetY !== 0;\n        switch (command) {\n            case 'M':\n                // Use start marker offset\n                if (useStartOffset) {\n                    context.moveTo(params[1] - defX + startOffsetX, params[2] - defY + startOffsetY);\n                    context.lineTo(params[1] - defX, params[2] - defY);\n                }\n                else {\n                    context.moveTo(params[1] - defX, params[2] - defY);\n                }\n                break;\n            case 'L':\n                if (useEndOffset) {\n                    context.lineTo(params[1] - defX + endOffsetX, params[2] - defY + endOffsetY);\n                }\n                else {\n                    context.lineTo(params[1] - defX, params[2] - defY);\n                }\n                break;\n            case 'Q':\n                context.quadraticCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY);\n                if (useEndOffset) {\n                    context.lineTo(params[3] - defX + endOffsetX, params[4] - defY + endOffsetY);\n                }\n                break;\n            case 'C':\n                context.bezierCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY, params[5] - defX, params[6] - defY);\n                if (useEndOffset) {\n                    context.lineTo(params[5] - defX + endOffsetX, params[6] - defY + endOffsetY);\n                }\n                break;\n            case 'A': {\n                var arcParams = segments[i].arcParams;\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;\n                // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse\n                if (context.ellipse) {\n                    context.ellipse(cx - defX, cy - defY, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));\n                }\n                else {\n                    // @see https://stackoverflow.com/a/47494351\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    context.translate(cx - defX, cy - defY);\n                    context.rotate(xRotation);\n                    context.scale(scaleX, scaleY);\n                    context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));\n                    context.scale(1 / scaleX, 1 / scaleY);\n                    context.rotate(-xRotation);\n                    context.translate(-(cx - defX), -(cy - defY));\n                }\n                if (useEndOffset) {\n                    context.lineTo(params[6] - defX + endOffsetX, params[7] - defY + endOffsetY);\n                }\n                break;\n            }\n            case 'Z':\n                context.closePath();\n                break;\n        }\n    }\n}\n\nfunction generatePath$2(context, parsedStyle) {\n    var _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n    var points = parsedStyle.points.points;\n    var length = points.length;\n    var x1 = points[0][0] - defX;\n    var y1 = points[0][1] - defY;\n    var x2 = points[length - 1][0] - defX;\n    var y2 = points[length - 1][1] - defY;\n    var startOffsetX = 0;\n    var startOffsetY = 0;\n    var endOffsetX = 0;\n    var endOffsetY = 0;\n    var rad = 0;\n    var x;\n    var y;\n    if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n        x = points[1][0] - points[0][0];\n        y = points[1][1] - points[0][1];\n        rad = Math.atan2(y, x);\n        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n    }\n    if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n        x = points[length - 1][0] - points[0][0];\n        y = points[length - 1][1] - points[0][1];\n        rad = Math.atan2(y, x);\n        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n    }\n    context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));\n    for (var i = 1; i < length - 1; i++) {\n        var point = points[i];\n        context.lineTo(point[0] - defX, point[1] - defY);\n    }\n    context.lineTo(x2, y2);\n}\n\nfunction generatePath$1(context, parsedStyle) {\n    var _a = parsedStyle.defX, defX = _a === void 0 ? 0 : _a, _b = parsedStyle.defY, defY = _b === void 0 ? 0 : _b, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;\n    var points = parsedStyle.points.points;\n    var length = points.length;\n    var x1 = points[0][0] - defX;\n    var y1 = points[0][1] - defY;\n    var x2 = points[length - 1][0] - defX;\n    var y2 = points[length - 1][1] - defY;\n    var startOffsetX = 0;\n    var startOffsetY = 0;\n    var endOffsetX = 0;\n    var endOffsetY = 0;\n    var rad = 0;\n    var x;\n    var y;\n    if (markerStart && gLite.isDisplayObject(markerStart) && markerStartOffset) {\n        x = points[1][0] - points[0][0];\n        y = points[1][1] - points[0][1];\n        rad = Math.atan2(y, x);\n        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);\n        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);\n    }\n    if (markerEnd && gLite.isDisplayObject(markerEnd) && markerEndOffset) {\n        x = points[length - 2][0] - points[length - 1][0];\n        y = points[length - 2][1] - points[length - 1][1];\n        rad = Math.atan2(y, x);\n        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);\n        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);\n    }\n    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);\n    for (var i = 1; i < length - 1; i++) {\n        var point = points[i];\n        context.lineTo(point[0] - defX, point[1] - defY);\n    }\n    context.lineTo(x2 + endOffsetX, y2 + endOffsetY);\n}\n\nfunction generatePath(context, parsedStyle) {\n    var radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;\n    var w = width;\n    var h = height;\n    var hasRadius = radius && radius.some(function (r) { return r !== 0; });\n    if (!hasRadius) {\n        // Canvas support negative width/height of rect\n        context.rect(0, 0, w, h);\n    }\n    else {\n        var signX = width > 0 ? 1 : -1;\n        var signY = height > 0 ? 1 : -1;\n        var sweepFlag = signX + signY === 0;\n        var _a = tslib.__read(radius.map(function (r) {\n            return util.clamp(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));\n        }), 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];\n        context.moveTo(signX * tlr, 0);\n        context.lineTo(w - signX * trr, 0);\n        if (trr !== 0) {\n            context.arc(w - signX * trr, signY * trr, trr, (-signY * Math.PI) / 2, signX > 0 ? 0 : Math.PI, sweepFlag);\n        }\n        context.lineTo(w, h - signY * brr);\n        if (brr !== 0) {\n            context.arc(w - signX * brr, h - signY * brr, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);\n        }\n        context.lineTo(signX * blr, h);\n        if (blr !== 0) {\n            context.arc(signX * blr, h - signY * blr, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);\n        }\n        context.lineTo(0, signY * tlr);\n        if (tlr !== 0) {\n            context.arc(signX * tlr, signY * tlr, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);\n        }\n    }\n}\n\nvar Plugin = /** @class */ (function (_super) {\n    tslib.__extends(Plugin, _super);\n    function Plugin() {\n        var _this = _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments), false)) || this;\n        _this.name = 'canvas-path-generator';\n        return _this;\n    }\n    Plugin.prototype.init = function () {\n        var _a;\n        var pathGeneratorFactory = (_a = {},\n            _a[gLite.Shape.CIRCLE] = generatePath$6,\n            _a[gLite.Shape.ELLIPSE] = generatePath$5,\n            _a[gLite.Shape.RECT] = generatePath,\n            _a[gLite.Shape.LINE] = generatePath$4,\n            _a[gLite.Shape.POLYLINE] = generatePath$1,\n            _a[gLite.Shape.POLYGON] = generatePath$2,\n            _a[gLite.Shape.PATH] = generatePath$3,\n            _a[gLite.Shape.TEXT] = undefined,\n            _a[gLite.Shape.GROUP] = undefined,\n            _a[gLite.Shape.IMAGE] = undefined,\n            _a[gLite.Shape.HTML] = undefined,\n            _a[gLite.Shape.MESH] = undefined,\n            _a);\n        // @ts-ignore\n        this.context.pathGeneratorFactory = pathGeneratorFactory;\n    };\n    Plugin.prototype.destroy = function () {\n        // @ts-ignore\n        delete this.context.pathGeneratorFactory;\n    };\n    return Plugin;\n}(gLite.AbstractRendererPlugin));\n\nexports.Plugin = Plugin;\n//# sourceMappingURL=index.js.map\n"]}