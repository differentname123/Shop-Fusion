{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar tslib = require('tslib');\nvar gLite = require('@antv/g-lite');\nvar util = require('@antv/util');\n\nvar eps = 0.0001;\n/**\n * Provides some control methods like:\n * - play\n * - pause\n * - stop\n * - goToAndStop\n * - goToAndPlay\n * @see https://github.com/airbnb/lottie-web/blob/master/player/js/animation/AnimationItem.js\n */\nvar LottieAnimation = /** @class */ (function () {\n    function LottieAnimation(width, height, elements, context) {\n        var _this = this;\n        this.width = width;\n        this.height = height;\n        this.elements = elements;\n        this.context = context;\n        this.keyframeAnimationMap = new WeakMap();\n        this.displayObjectElementMap = new WeakMap();\n        this.animations = [];\n        this.isPaused = false;\n        this.direction = 1;\n        this.displayObjects = elements.map(function (element) {\n            return _this.buildHierachy(element);\n        });\n        // TODO: preload images\n        // TODO: preload fonts\n    }\n    LottieAnimation.prototype.generateTransform = function (tx, ty, scaleX, scaleY, rotation) {\n        var transformStr = '';\n        if (tx !== 0 || ty !== 0) {\n            transformStr += \"translate(\".concat(tx, \", \").concat(ty, \")\");\n        }\n        if (scaleX !== 1 || scaleY !== 1) {\n            transformStr += \" scale(\".concat(scaleX === 0 ? eps : scaleX, \", \").concat(scaleY === 0 ? eps : scaleY, \")\");\n        }\n        if (rotation !== 0) {\n            transformStr += \" rotate(\".concat(rotation, \"deg)\");\n        }\n        return transformStr;\n    };\n    LottieAnimation.prototype.buildHierachy = function (element) {\n        var _this = this;\n        var type = element.type, name = element.name, _a = element.anchorX, anchorX = _a === void 0 ? 0 : _a, _b = element.anchorY, anchorY = _b === void 0 ? 0 : _b, _c = element.rotation, rotation = _c === void 0 ? 0 : _c, _d = element.scaleX, scaleX = _d === void 0 ? 1 : _d, _e = element.scaleY, scaleY = _e === void 0 ? 1 : _e, _f = element.x, x = _f === void 0 ? 0 : _f, _g = element.y, y = _g === void 0 ? 0 : _g, \n        // skew = 0,\n        // skewAxis = 0,\n        children = element.children, shape = element.shape, style = element.style, keyframeAnimation = element.keyframeAnimation;\n        var displayObject;\n        var transform = this.generateTransform(x - anchorX, y - anchorY, scaleX, scaleY, rotation);\n        // const transformMat = mat4.fromRotationTranslationScaleOrigin(\n        //   mat4.create(),\n        //   quat.fromEuler(quat.create(), 0, 0, rotation),\n        //   [x - anchorX, y - anchorY, 0],\n        //   [scaleX, scaleY, 1],\n        //   [anchorX, anchorY, 0],\n        // );\n        // TODO: repeater @see https://lottiefiles.github.io/lottie-docs/shapes/#repeater\n        // @see https://lottiefiles.github.io/lottie-docs/shapes/#shape\n        // TODO: polystar, convert to Bezier @see https://lottiefiles.github.io/lottie-docs/rendering/#polystar\n        if (type === gLite.Shape.GROUP) {\n            displayObject = new gLite.Group({\n                style: {\n                    transformOrigin: \"\".concat(anchorX, \"px \").concat(anchorY, \"px\"),\n                    transform: transform,\n                },\n            });\n        }\n        else if (type === gLite.Shape.ELLIPSE) {\n            var cx = shape.cx, cy = shape.cy, rx = shape.rx, ry = shape.ry;\n            // const center = vec3.fromValues(cx, cy, 0);\n            // vec3.transformMat4(center, center, transformMat);\n            displayObject = new gLite.Ellipse({\n                style: {\n                    // cx: center[0],\n                    // cy: center[1],\n                    cx: cx,\n                    cy: cy,\n                    rx: rx,\n                    ry: ry,\n                    // reset transform-origin based on anchor & center\n                    transformOrigin: \"\".concat(anchorX - cx + rx, \"px \").concat(anchorY - cy + ry, \"px\"),\n                    transform: transform,\n                },\n            });\n        }\n        else if (type === gLite.Shape.PATH) {\n            var d = this.generatePathFromShape(shape);\n            displayObject = new gLite.Path({\n                style: {\n                    d: d, // use Path Array which can be skipped when parsing\n                    transformOrigin: \"\".concat(anchorX, \"px \").concat(anchorY, \"px\"),\n                    transform: transform,\n                },\n            });\n        }\n        else if (type === gLite.Shape.RECT) {\n            // @see https://lottiefiles.github.io/lottie-docs/shapes/#rectangle\n            var cx = shape.x, cy = shape.y, width = shape.width, height = shape.height, r = shape.r;\n            displayObject = new gLite.Rect({\n                style: {\n                    x: cx,\n                    y: cy,\n                    width: width,\n                    height: height,\n                    anchor: [0.5, 0.5], // position means the center of the rectangle\n                    radius: r,\n                    transformOrigin: \"\".concat(anchorX - cx + width / 2, \"px \").concat(anchorY - cy + height / 2, \"px\"),\n                    transform: transform,\n                },\n            });\n        }\n        else if (type === gLite.Shape.IMAGE) {\n            var width = shape.width, height = shape.height, src = shape.src;\n            displayObject = new gLite.Image({\n                style: {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height,\n                    src: src,\n                    transformOrigin: \"\".concat(anchorX, \"px \").concat(anchorY, \"px\"),\n                    transform: transform,\n                },\n            });\n        }\n        if (name) {\n            displayObject.name = name;\n        }\n        // TODO: match name `mn`, used in expressions\n        if (style) {\n            // { fill, fillOpacity, fillRule, opacity, lineDash, lineDashOffset }\n            displayObject.attr(style);\n        }\n        if (keyframeAnimation) {\n            this.keyframeAnimationMap.set(displayObject, keyframeAnimation);\n        }\n        if (children) {\n            var childNodes = children.map(function (child) { return _this.buildHierachy(child); });\n            displayObject.append.apply(displayObject, tslib.__spreadArray([], tslib.__read(childNodes), false));\n        }\n        this.displayObjectElementMap.set(displayObject, element);\n        return displayObject;\n    };\n    LottieAnimation.prototype.getAnimations = function () {\n        return this.animations;\n    };\n    /**\n     * Returns the animation duration in seconds or frames.\n     * @see https://github.com/airbnb/lottie-web#getdurationinframes\n     */\n    LottieAnimation.prototype.getDuration = function (inFrames) {\n        if (inFrames === void 0) { inFrames = false; }\n        return (((inFrames ? this.fps() : 1) *\n            (this.context.endFrame - this.context.startFrame) *\n            this.context.frameTime) /\n            1000);\n    };\n    /**\n     * Returns the animation frame rate (frames / second).\n     */\n    LottieAnimation.prototype.fps = function () {\n        return this.context.fps;\n    };\n    LottieAnimation.prototype.isSameKeyframeOptions = function (options1, options2) {\n        return (options1.delay === options2.delay &&\n            options1.duration === options2.duration &&\n            options1.easing === options2.easing);\n    };\n    LottieAnimation.prototype.isSameKeyframes = function (keyframe1, keyframe2) {\n        // const { offset: o1, easing: e1, ...rest1 } = keyframe1;\n        // const { offset: o2, easing: e2, ...rest2 } = keyframe2;\n        // const isAllApplyToTransform =\n        //   Object.keys(rest1).every((key) =>\n        //     ['x', 'y', 'scaleX', 'scaleY', 'rotation'].includes(key),\n        //   ) &&\n        //   Object.keys(rest2).every((key) =>\n        //     ['x', 'y', 'scaleX', 'scaleY', 'rotation'].includes(key),\n        //   );\n        return (keyframe1.offset === keyframe2.offset &&\n            keyframe1.easing === keyframe2.easing\n        // (keyframe1.easing === keyframe2.easing || isAllApplyToTransform)\n        );\n    };\n    LottieAnimation.prototype.generatePathFromShape = function (shape) {\n        // @see https://lottiefiles.github.io/lottie-docs/shapes/#path\n        var close = shape.close, v = shape.v, i = shape.in, out = shape.out;\n        var d = [];\n        d.push(['M', v[0][0], v[0][1]]);\n        for (var n = 1; n < v.length; n++) {\n            // @see https://lottiefiles.github.io/lottie-docs/concepts/#bezier\n            // The nth bezier segment is defined as:\n            // v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1]\n            d.push([\n                'C',\n                out[n - 1][0],\n                out[n - 1][1],\n                i[n][0],\n                i[n][1],\n                v[n][0],\n                v[n][1],\n            ]);\n        }\n        if (close) {\n            d.push([\n                'C',\n                out[v.length - 1][0],\n                out[v.length - 1][1],\n                i[0][0],\n                i[0][1],\n                v[0][0],\n                v[0][1],\n            ]);\n            d.push(['Z']);\n        }\n        return d;\n    };\n    /**\n     * render Lottie Group to canvas or a mounted display object\n     */\n    LottieAnimation.prototype.render = function (canvasOrDisplayObject) {\n        var _this = this;\n        var wrapper = new gLite.Group();\n        wrapper.append.apply(wrapper, tslib.__spreadArray([], tslib.__read(this.displayObjects), false));\n        if (gLite.isCanvas(canvasOrDisplayObject)) {\n            canvasOrDisplayObject.appendChild(wrapper);\n        }\n        else if (gLite.isDisplayObject(canvasOrDisplayObject)) {\n            if (!canvasOrDisplayObject.isConnected) {\n                throw new Error('[g-lottie-player]: Cannot render Lottie to an unmounted DisplayObject.');\n            }\n            else {\n                canvasOrDisplayObject.appendChild(wrapper);\n            }\n        }\n        else {\n            throw new Error('[g-lottie-player]: We should render Lottie to a mounted DisplayObject or Canvas.');\n        }\n        this.displayObjects.forEach(function (parent) {\n            parent.forEach(function (child) {\n                var _a;\n                var keyframeAnimation = _this.keyframeAnimationMap.get(child);\n                // console.log('keyframeAnimation', keyframeAnimation);\n                var element = _this.displayObjectElementMap.get(child);\n                if (element && element.clipPath) {\n                    var _b = element.clipPath, shape = _b.shape, keyframeAnimation_1 = _b.keyframeAnimation;\n                    var clipPath = new gLite.Path();\n                    // use clipPath as target's siblings\n                    child.parentElement.appendChild(clipPath);\n                    child.style.clipPath = clipPath;\n                    if (shape) {\n                        clipPath.style.d = _this.generatePathFromShape(shape);\n                    }\n                    // TODO: only support one clipPath now\n                    if (keyframeAnimation_1 && keyframeAnimation_1.length) {\n                        var _c = keyframeAnimation_1[0], delay = _c.delay, duration = _c.duration, easing = _c.easing, keyframes = _c.keyframes;\n                        // animate clipPath with its `d` property\n                        var clipPathAnimation = clipPath.animate(keyframes.map(function (_a) {\n                            var offset = _a.offset, shape = _a.shape, easing = _a.easing;\n                            return {\n                                offset: offset,\n                                d: util.path2String(_this.generatePathFromShape(shape)),\n                                easing: easing,\n                            };\n                        }), {\n                            delay: delay,\n                            duration: duration,\n                            easing: easing,\n                            iterations: _this.context.iterations,\n                        });\n                        _this.animations.push(clipPathAnimation);\n                    }\n                }\n                // account for animation only apply to visibility, e.g. spring\n                var visibilityStartOffset = element.visibilityStartOffset, visibilityEndOffset = element.visibilityEndOffset, visibilityFrame = element.visibilityFrame;\n                if (visibilityFrame &&\n                    (!keyframeAnimation || !keyframeAnimation.length)) {\n                    keyframeAnimation = [\n                        {\n                            duration: _this.context.frameTime * visibilityFrame,\n                            keyframes: [\n                                { offset: 0, style: { opacity: 1 } },\n                                { offset: 1, style: { opacity: 1 } },\n                            ],\n                        },\n                    ];\n                }\n                if (keyframeAnimation && keyframeAnimation.length) {\n                    var keyframesOptions_1 = [];\n                    keyframeAnimation.map(function (_a) {\n                        var _b = _a.delay, delay = _b === void 0 ? 0 : _b, duration = _a.duration, easing = _a.easing, keyframes = _a.keyframes;\n                        var formattedKeyframes = keyframes.map(function (keyframe) {\n                            return gLite.definedProps(keyframe);\n                        });\n                        var options = gLite.definedProps({\n                            delay: delay,\n                            duration: duration,\n                            easing: easing,\n                            iterations: _this.context.iterations,\n                            fill: _this.context.fill,\n                        });\n                        keyframesOptions_1.push([formattedKeyframes, options]);\n                    });\n                    var mergedKeyframesOptions = [keyframesOptions_1[0]];\n                    var _loop_1 = function (i) {\n                        var _d = tslib.__read(keyframesOptions_1[i], 2), currentKeyframes = _d[0], currentOptions = _d[1];\n                        // can merge options?\n                        var existedKeyframeOptions = mergedKeyframesOptions.find(function (_a) {\n                            var _b = tslib.__read(_a, 2), keyframes = _b[0], options = _b[1];\n                            return keyframes.length === currentKeyframes.length &&\n                                _this.isSameKeyframeOptions(currentOptions, options);\n                        });\n                        if (existedKeyframeOptions) {\n                            currentKeyframes.forEach(function (currentKeyframe) {\n                                var existedKeyframe = existedKeyframeOptions[0].find(function (keyframe) { return _this.isSameKeyframes(currentKeyframe, keyframe); });\n                                if (existedKeyframe) {\n                                    currentKeyframe.offset; \n                                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                                    currentKeyframe.easing; \n                                    var rest = tslib.__rest(currentKeyframe, [\"offset\", \"easing\"]);\n                                    // merge interpolated properties\n                                    Object.assign(existedKeyframe, rest);\n                                }\n                                else {\n                                    // append if cannot be merged\n                                    existedKeyframeOptions[0].push(currentKeyframe);\n                                }\n                            });\n                        }\n                        else {\n                            // cannot be merged since options are different\n                            mergedKeyframesOptions.push(keyframesOptions_1[i]);\n                        }\n                    };\n                    // merge [{ offset: 0, cx: 1 }, { offset: 0, cy: 1 }] into { offset: 0, cx: 1, cy: 1 }\n                    for (var i = 1; i < keyframesOptions_1.length; i++) {\n                        _loop_1(i);\n                    }\n                    // restore animations for later use\n                    (_a = _this.animations).push.apply(_a, tslib.__spreadArray([], tslib.__read(mergedKeyframesOptions\n                        .map(function (_a) {\n                        var _b = tslib.__read(_a, 2), merged = _b[0], options = _b[1];\n                        // format interpolated properties, e.g. scaleX -> transform\n                        var formatted = _this.formatKeyframes(merged, child);\n                        if (formatted.length) {\n                            // console.log(child, formatted);\n                            var animation_1 = child.animate(formatted, options);\n                            if (!util.isNil(visibilityStartOffset) &&\n                                !util.isNil(visibilityEndOffset)) {\n                                child.style.visibility = 'hidden';\n                                animation_1.onframe = function () {\n                                    var progress = animation_1.effect.getComputedTiming().progress;\n                                    if (progress >= visibilityStartOffset &&\n                                        progress < visibilityEndOffset) {\n                                        child.style.visibility = 'visible';\n                                    }\n                                    else {\n                                        child.style.visibility = 'hidden';\n                                    }\n                                };\n                            }\n                            if (!_this.context.autoplay) {\n                                animation_1.pause();\n                            }\n                            return animation_1;\n                        }\n                    })\n                        .filter(function (animation) { return !!animation; })), false));\n                }\n            });\n        });\n        return wrapper;\n    };\n    LottieAnimation.prototype.formatKeyframes = function (keyframes, object) {\n        keyframes.forEach(function (keyframe) {\n            // if ('offsetPath' in keyframe) {\n            //   if (!object.style.offsetPath) {\n            //     const [ox, oy] = object.getOrigin();\n            //     (keyframe.offsetPath as AbsoluteArray).forEach((segment) => {\n            //       if (segment[0] === 'M') {\n            //         segment[1] -= ox;\n            //         segment[2] -= oy;\n            //       } else if (segment[0] === 'C') {\n            //         segment[1] -= ox;\n            //         segment[2] -= oy;\n            //         segment[3] -= ox;\n            //         segment[4] -= oy;\n            //         segment[5] -= ox;\n            //         segment[6] -= oy;\n            //       }\n            //     });\n            //     const offsetPath = new Path({\n            //       style: {\n            //         d: keyframe.offsetPath,\n            //       },\n            //     });\n            //     object.style.offsetPath = offsetPath;\n            //     console.log(offsetPath);\n            //   }\n            //   delete keyframe.offsetPath;\n            //   // offsetPath should override x/y\n            //   delete keyframe.x;\n            //   delete keyframe.y;\n            // }\n            // should keep transform during initialization\n            // if (!object.style.offsetPath) {\n            //   keyframe.transform = object.style.transform || '';\n            // }\n            keyframe.transform = object.style.transform || '';\n            // TODO: transforms with different easing functions will conflict\n            if ('scaleX' in keyframe) {\n                keyframe.transform =\n                    (keyframe.transform || '') +\n                        \" scaleX(\".concat(keyframe.scaleX === 0 ? eps : keyframe.scaleX, \")\");\n                delete keyframe.scaleX;\n            }\n            if ('scaleY' in keyframe) {\n                keyframe.transform =\n                    (keyframe.transform || '') +\n                        \" scaleY(\".concat(keyframe.scaleY === 0 ? eps : keyframe.scaleY, \")\");\n                delete keyframe.scaleY;\n            }\n            if ('rotation' in keyframe) {\n                keyframe.transform =\n                    (keyframe.transform || '') + \" rotate(\".concat(keyframe.rotation, \"deg)\");\n                delete keyframe.rotation;\n            }\n            // TODO: skew & skewAxis\n            // if ('skew' in keyframe) {\n            //   keyframe.transform = (keyframe.transform || '') + ` skew(${keyframe.skew}deg)`;\n            //   delete keyframe.skew;\n            // }\n            if ('x' in keyframe) {\n                keyframe.transform =\n                    (keyframe.transform || '') + \" translateX(\".concat(keyframe.x, \"px)\");\n                delete keyframe.x;\n            }\n            if ('y' in keyframe) {\n                keyframe.transform =\n                    (keyframe.transform || '') + \" translateY(\".concat(keyframe.y, \"px)\");\n                delete keyframe.y;\n            }\n            // { style: { opacity: 1 } }\n            if ('style' in keyframe) {\n                Object.keys(keyframe.style).forEach(function (name) {\n                    keyframe[name] = keyframe.style[name];\n                });\n                delete keyframe.style;\n            }\n        });\n        // ignore empty interpolable attributes\n        keyframes = keyframes.filter(function (keyframe) {\n            // TODO: support negative offset\n            keyframe.ignore; keyframe.easing; var offset = keyframe.offset, rest = tslib.__rest(keyframe, [\"ignore\", \"easing\", \"offset\"]);\n            return offset >= 0 && Object.keys(rest).length > 0;\n            // return Object.keys(rest).length > 0;\n        });\n        if (keyframes.length) {\n            // padding offset = 1\n            if (keyframes[keyframes.length - 1].offset !== 1) {\n                keyframes.push(tslib.__assign(tslib.__assign({}, keyframes[keyframes.length - 1]), { offset: 1 }));\n            }\n        }\n        // sort by offset\n        keyframes.sort(function (a, b) { return a.offset - b.offset; });\n        // remove empty attributes\n        keyframes.forEach(function (keyframe) {\n            Object.keys(keyframe).forEach(function (name) {\n                if (keyframe[name] === '') {\n                    delete keyframe[name];\n                }\n            });\n        });\n        return keyframes;\n    };\n    /**\n     * Destroy all internal displayobjects.\n     */\n    LottieAnimation.prototype.destroy = function () {\n        this.displayObjects.forEach(function (object) {\n            object.destroy();\n        });\n    };\n    /**\n     * Return the size of this animation.\n     * @param outputSize - If provided, the size will be copied into here as width, height.\n     */\n    LottieAnimation.prototype.size = function (outputSize) {\n        return { width: this.width, height: this.height };\n    };\n    /**\n     * Bodymovin version\n     */\n    LottieAnimation.prototype.version = function () {\n        return this.context.version;\n    };\n    LottieAnimation.prototype.play = function () {\n        this.isPaused = false;\n        this.animations.forEach(function (animation) {\n            animation.play();\n        });\n    };\n    /**\n     * Can contain 2 numeric values that will be used as first and last frame of the animation.\n     * @see https://github.com/airbnb/lottie-web#playsegmentssegments-forceflag\n     */\n    LottieAnimation.prototype.playSegments = function (segments) {\n        var _this = this;\n        var _a = tslib.__read(segments, 2), firstFrame = _a[0], lastFrame = _a[1];\n        this.isPaused = false;\n        this.animations.forEach(function (animation) {\n            animation.currentTime = (firstFrame / _this.fps()) * 1000;\n            var originOnFrame = animation.onframe;\n            animation.onframe = function (e) {\n                if (originOnFrame) {\n                    // @ts-ignore\n                    originOnFrame(e);\n                }\n                if (animation.currentTime >= (lastFrame / _this.fps()) * 1000) {\n                    animation.finish();\n                    if (originOnFrame) {\n                        animation.onframe = originOnFrame;\n                    }\n                    else {\n                        animation.onframe = null;\n                    }\n                }\n            };\n            animation.play();\n        });\n    };\n    LottieAnimation.prototype.pause = function () {\n        this.isPaused = true;\n        this.animations.forEach(function (animation) {\n            animation.pause();\n        });\n    };\n    /**\n     *\n     */\n    LottieAnimation.prototype.togglePause = function () {\n        if (this.isPaused) {\n            this.play();\n        }\n        else {\n            this.pause();\n        }\n    };\n    /**\n     * Goto and stop at a specific time(in seconds) or frame.\n     * Split goToAndStop/Play into goTo & stop/play\n     * @see https://github.com/airbnb/lottie-web\n     */\n    LottieAnimation.prototype.goTo = function (value, isFrame) {\n        var _this = this;\n        if (isFrame === void 0) { isFrame = false; }\n        if (isFrame) {\n            this.animations.forEach(function (animation) {\n                animation.currentTime = (value / _this.fps()) * 1000;\n            });\n        }\n        else {\n            this.animations.forEach(function (animation) {\n                animation.currentTime = value * 1000;\n            });\n        }\n    };\n    /**\n     * @see https://github.com/airbnb/lottie-web#stop\n     */\n    LottieAnimation.prototype.stop = function () {\n        this.animations.forEach(function (animation) {\n            animation.finish();\n        });\n    };\n    /**\n     * 1 is normal speed.\n     * @see https://github.com/airbnb/lottie-web#setspeedspeed\n     */\n    LottieAnimation.prototype.setSpeed = function (speed) {\n        var _this = this;\n        this.animations.forEach(function (animation) {\n            animation.playbackRate = speed * _this.direction;\n        });\n    };\n    /**\n     * 1 is forward, -1 is reverse.\n     * @see https://github.com/airbnb/lottie-web#setdirectiondirection\n     */\n    LottieAnimation.prototype.setDirection = function (direction) {\n        this.direction = direction;\n        this.animations.forEach(function (animation) {\n            animation.playbackRate *= direction;\n        });\n    };\n    return LottieAnimation;\n}());\n\n/**\n * borrow from https://github.com/airbnb/lottie-web/blob/master/player/js/utils/DataManager.js#L40-L493\n */\nfunction completeLayers(layers, comps) {\n    var layerData;\n    var i;\n    var len = layers.length;\n    var j;\n    var jLen;\n    var k;\n    var kLen;\n    for (i = 0; i < len; i += 1) {\n        layerData = layers[i];\n        if ('ks' in layerData && !layerData.completed) {\n            layerData.completed = true;\n            if (layerData.tt) {\n                layers[i - 1].td = layerData.tt;\n            }\n            if (layerData.hasMask) {\n                var maskProps = layerData.masksProperties;\n                jLen = maskProps.length;\n                for (j = 0; j < jLen; j += 1) {\n                    if (maskProps[j].pt.k.i) {\n                        convertPathsToAbsoluteValues(maskProps[j].pt.k);\n                    }\n                    else {\n                        kLen = maskProps[j].pt.k.length;\n                        for (k = 0; k < kLen; k += 1) {\n                            if (maskProps[j].pt.k[k].s) {\n                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\n                            }\n                            if (maskProps[j].pt.k[k].e) {\n                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\n                            }\n                        }\n                    }\n                }\n            }\n            if (layerData.ty === 0) {\n                layerData.layers = findCompLayers(layerData.refId, comps);\n                completeLayers(layerData.layers, comps);\n            }\n            else if (layerData.ty === 4) {\n                completeShapes(layerData.shapes);\n            }\n            else if (layerData.ty === 5) {\n                completeText(layerData);\n            }\n        }\n    }\n}\nfunction completeChars(chars, assets) {\n    if (chars) {\n        var i = 0;\n        var len = chars.length;\n        for (i = 0; i < len; i += 1) {\n            if (chars[i].t === 1) {\n                // var compData = findComp(chars[i].data.refId, assets);\n                chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);\n                // chars[i].data.ip = 0;\n                // chars[i].data.op = 99999;\n                // chars[i].data.st = 0;\n                // chars[i].data.sr = 1;\n                // chars[i].w = compData.w;\n                // chars[i].data.ks = {\n                //   a: { k: [0, 0, 0], a: 0 },\n                //   p: { k: [0, -compData.h, 0], a: 0 },\n                //   r: { k: 0, a: 0 },\n                //   s: { k: [100, 100], a: 0 },\n                //   o: { k: 100, a: 0 },\n                // };\n                completeLayers(chars[i].data.layers, assets);\n            }\n        }\n    }\n}\nfunction findComp(id, comps) {\n    var i = 0;\n    var len = comps.length;\n    while (i < len) {\n        if (comps[i].id === id) {\n            return comps[i];\n        }\n        i += 1;\n    }\n    return null;\n}\nfunction findCompLayers(id, comps) {\n    var comp = findComp(id, comps);\n    if (comp) {\n        if (!comp.layers.__used) {\n            comp.layers.__used = true;\n            return comp.layers;\n        }\n        return JSON.parse(JSON.stringify(comp.layers));\n    }\n    return null;\n}\nfunction completeShapes(arr) {\n    var i;\n    var len = arr.length;\n    var j;\n    var jLen;\n    for (i = len - 1; i >= 0; i -= 1) {\n        if (arr[i].ty === 'sh') {\n            if (arr[i].ks.k.i) {\n                convertPathsToAbsoluteValues(arr[i].ks.k);\n            }\n            else {\n                jLen = arr[i].ks.k.length;\n                for (j = 0; j < jLen; j += 1) {\n                    if (arr[i].ks.k[j].s) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\n                    }\n                    if (arr[i].ks.k[j].e) {\n                        convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\n                    }\n                }\n            }\n        }\n        else if (arr[i].ty === 'gr') {\n            completeShapes(arr[i].it);\n        }\n    }\n}\nfunction convertPathsToAbsoluteValues(path) {\n    var i;\n    var len = path.i.length;\n    for (i = 0; i < len; i += 1) {\n        path.i[i][0] += path.v[i][0];\n        path.i[i][1] += path.v[i][1];\n        path.o[i][0] += path.v[i][0];\n        path.o[i][1] += path.v[i][1];\n    }\n}\nfunction checkVersion(minimum, animVersionString) {\n    var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];\n    if (minimum[0] > animVersion[0]) {\n        return true;\n    }\n    if (animVersion[0] > minimum[0]) {\n        return false;\n    }\n    if (minimum[1] > animVersion[1]) {\n        return true;\n    }\n    if (animVersion[1] > minimum[1]) {\n        return false;\n    }\n    if (minimum[2] > animVersion[2]) {\n        return true;\n    }\n    if (animVersion[2] > minimum[2]) {\n        return false;\n    }\n    return null;\n}\nvar checkText = (function () {\n    var minimumVersion = [4, 4, 14];\n    function updateTextLayer(textLayer) {\n        var documentData = textLayer.t.d;\n        textLayer.t.d = {\n            k: [\n                {\n                    s: documentData,\n                    t: 0,\n                },\n            ],\n        };\n    }\n    function iterateLayers(layers) {\n        var i;\n        var len = layers.length;\n        for (i = 0; i < len; i += 1) {\n            if (layers[i].ty === 5) {\n                updateTextLayer(layers[i]);\n            }\n        }\n    }\n    return function (animationData) {\n        if (checkVersion(minimumVersion, animationData.v)) {\n            iterateLayers(animationData.layers);\n            if (animationData.assets) {\n                var i = void 0;\n                var len = animationData.assets.length;\n                for (i = 0; i < len; i += 1) {\n                    if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                    }\n                }\n            }\n        }\n    };\n})();\nvar checkChars = (function () {\n    var minimumVersion = [4, 7, 99];\n    return function (animationData) {\n        if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n            var i = void 0;\n            var len = animationData.chars.length;\n            for (i = 0; i < len; i += 1) {\n                var charData = animationData.chars[i];\n                if (charData.data && charData.data.shapes) {\n                    completeShapes(charData.data.shapes);\n                    charData.data.ip = 0;\n                    charData.data.op = 99999;\n                    charData.data.st = 0;\n                    charData.data.sr = 1;\n                    charData.data.ks = {\n                        p: { k: [0, 0], a: 0 },\n                        s: { k: [100, 100], a: 0 },\n                        a: { k: [0, 0], a: 0 },\n                        r: { k: 0, a: 0 },\n                        o: { k: 100, a: 0 },\n                    };\n                    if (!animationData.chars[i].t) {\n                        charData.data.shapes.push({\n                            ty: 'no',\n                        });\n                        charData.data.shapes[0].it.push({\n                            p: { k: [0, 0], a: 0 },\n                            s: { k: [100, 100], a: 0 },\n                            a: { k: [0, 0], a: 0 },\n                            r: { k: 0, a: 0 },\n                            o: { k: 100, a: 0 },\n                            sk: { k: 0, a: 0 },\n                            sa: { k: 0, a: 0 },\n                            ty: 'tr',\n                        });\n                    }\n                }\n            }\n        }\n    };\n})();\nvar checkPathProperties = (function () {\n    var minimumVersion = [5, 7, 15];\n    function updateTextLayer(textLayer) {\n        var pathData = textLayer.t.p;\n        if (typeof pathData.a === 'number') {\n            pathData.a = {\n                a: 0,\n                k: pathData.a,\n            };\n        }\n        if (typeof pathData.p === 'number') {\n            pathData.p = {\n                a: 0,\n                k: pathData.p,\n            };\n        }\n        if (typeof pathData.r === 'number') {\n            pathData.r = {\n                a: 0,\n                k: pathData.r,\n            };\n        }\n    }\n    function iterateLayers(layers) {\n        var i;\n        var len = layers.length;\n        for (i = 0; i < len; i += 1) {\n            if (layers[i].ty === 5) {\n                updateTextLayer(layers[i]);\n            }\n        }\n    }\n    return function (animationData) {\n        if (checkVersion(minimumVersion, animationData.v)) {\n            iterateLayers(animationData.layers);\n            if (animationData.assets) {\n                var i = void 0;\n                var len = animationData.assets.length;\n                for (i = 0; i < len; i += 1) {\n                    if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                    }\n                }\n            }\n        }\n    };\n})();\nvar checkColors = (function () {\n    var minimumVersion = [4, 1, 9];\n    function iterateShapes(shapes) {\n        var i;\n        var len = shapes.length;\n        var j;\n        var jLen;\n        for (i = 0; i < len; i += 1) {\n            if (shapes[i].ty === 'gr') {\n                iterateShapes(shapes[i].it);\n            }\n            else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {\n                if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                    jLen = shapes[i].c.k.length;\n                    for (j = 0; j < jLen; j += 1) {\n                        if (shapes[i].c.k[j].s) {\n                            shapes[i].c.k[j].s[0] /= 255;\n                            shapes[i].c.k[j].s[1] /= 255;\n                            shapes[i].c.k[j].s[2] /= 255;\n                            shapes[i].c.k[j].s[3] /= 255;\n                        }\n                        if (shapes[i].c.k[j].e) {\n                            shapes[i].c.k[j].e[0] /= 255;\n                            shapes[i].c.k[j].e[1] /= 255;\n                            shapes[i].c.k[j].e[2] /= 255;\n                            shapes[i].c.k[j].e[3] /= 255;\n                        }\n                    }\n                }\n                else {\n                    shapes[i].c.k[0] /= 255;\n                    shapes[i].c.k[1] /= 255;\n                    shapes[i].c.k[2] /= 255;\n                    shapes[i].c.k[3] /= 255;\n                }\n            }\n        }\n    }\n    function iterateLayers(layers) {\n        var i;\n        var len = layers.length;\n        for (i = 0; i < len; i += 1) {\n            if (layers[i].ty === 4) {\n                iterateShapes(layers[i].shapes);\n            }\n        }\n    }\n    return function (animationData) {\n        if (checkVersion(minimumVersion, animationData.v)) {\n            iterateLayers(animationData.layers);\n            if (animationData.assets) {\n                var i = void 0;\n                var len = animationData.assets.length;\n                for (i = 0; i < len; i += 1) {\n                    if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                    }\n                }\n            }\n        }\n    };\n})();\nvar checkShapes = (function () {\n    var minimumVersion = [4, 4, 18];\n    function completeClosingShapes(arr) {\n        var i;\n        var len = arr.length;\n        var j;\n        var jLen;\n        for (i = len - 1; i >= 0; i -= 1) {\n            if (arr[i].ty === 'sh') {\n                if (arr[i].ks.k.i) {\n                    arr[i].ks.k.c = arr[i].closed;\n                }\n                else {\n                    jLen = arr[i].ks.k.length;\n                    for (j = 0; j < jLen; j += 1) {\n                        if (arr[i].ks.k[j].s) {\n                            arr[i].ks.k[j].s[0].c = arr[i].closed;\n                        }\n                        if (arr[i].ks.k[j].e) {\n                            arr[i].ks.k[j].e[0].c = arr[i].closed;\n                        }\n                    }\n                }\n            }\n            else if (arr[i].ty === 'gr') {\n                completeClosingShapes(arr[i].it);\n            }\n        }\n    }\n    function iterateLayers(layers) {\n        var layerData;\n        var i;\n        var len = layers.length;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        for (i = 0; i < len; i += 1) {\n            layerData = layers[i];\n            if (layerData.hasMask) {\n                var maskProps = layerData.masksProperties;\n                jLen = maskProps.length;\n                for (j = 0; j < jLen; j += 1) {\n                    if (maskProps[j].pt.k.i) {\n                        maskProps[j].pt.k.c = maskProps[j].cl;\n                    }\n                    else {\n                        kLen = maskProps[j].pt.k.length;\n                        for (k = 0; k < kLen; k += 1) {\n                            if (maskProps[j].pt.k[k].s) {\n                                maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\n                            }\n                            if (maskProps[j].pt.k[k].e) {\n                                maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\n                            }\n                        }\n                    }\n                }\n            }\n            if (layerData.ty === 4) {\n                completeClosingShapes(layerData.shapes);\n            }\n        }\n    }\n    return function (animationData) {\n        if (checkVersion(minimumVersion, animationData.v)) {\n            iterateLayers(animationData.layers);\n            if (animationData.assets) {\n                var i = void 0;\n                var len = animationData.assets.length;\n                for (i = 0; i < len; i += 1) {\n                    if (animationData.assets[i].layers) {\n                        iterateLayers(animationData.assets[i].layers);\n                    }\n                }\n            }\n        }\n    };\n})();\nfunction completeData(animationData) {\n    if (animationData.__complete) {\n        return;\n    }\n    checkColors(animationData);\n    checkText(animationData);\n    checkChars(animationData);\n    checkPathProperties(animationData);\n    checkShapes(animationData);\n    completeLayers(animationData.layers, animationData.assets);\n    completeChars(animationData.chars, animationData.assets);\n    animationData.__complete = true;\n}\nfunction completeText(data) {\n    if (data.t.a.length === 0 && !('m' in data.t.p)) ;\n}\n\n/**\n * https://lottiefiles.github.io/lottie-docs/constants/\n */\nvar BlendMode;\n(function (BlendMode) {\n    BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\n    BlendMode[BlendMode[\"Multiply\"] = 1] = \"Multiply\";\n    BlendMode[BlendMode[\"Screen\"] = 2] = \"Screen\";\n    BlendMode[BlendMode[\"Overlay\"] = 3] = \"Overlay\";\n    BlendMode[BlendMode[\"Darken\"] = 4] = \"Darken\";\n    BlendMode[BlendMode[\"Lighten\"] = 5] = \"Lighten\";\n    BlendMode[BlendMode[\"ColorDodge\"] = 6] = \"ColorDodge\";\n    BlendMode[BlendMode[\"ColorBurn\"] = 7] = \"ColorBurn\";\n    BlendMode[BlendMode[\"HardLight\"] = 8] = \"HardLight\";\n    BlendMode[BlendMode[\"SoftLight\"] = 9] = \"SoftLight\";\n    BlendMode[BlendMode[\"Difference\"] = 10] = \"Difference\";\n    BlendMode[BlendMode[\"Exclusion\"] = 11] = \"Exclusion\";\n    BlendMode[BlendMode[\"Hue\"] = 12] = \"Hue\";\n    BlendMode[BlendMode[\"Saturation\"] = 13] = \"Saturation\";\n    BlendMode[BlendMode[\"Color\"] = 14] = \"Color\";\n    BlendMode[BlendMode[\"Luminosity\"] = 15] = \"Luminosity\";\n    BlendMode[BlendMode[\"Add\"] = 16] = \"Add\";\n    BlendMode[BlendMode[\"HardMix\"] = 17] = \"HardMix\";\n})(BlendMode || (BlendMode = {}));\n/**\n * @see https://lottiefiles.github.io/lottie-docs/constants/#mattemode\n */\nvar MatteMode;\n(function (MatteMode) {\n    MatteMode[MatteMode[\"Normal\"] = 0] = \"Normal\";\n    MatteMode[MatteMode[\"Alpha\"] = 1] = \"Alpha\";\n    MatteMode[MatteMode[\"InvertedAlpha\"] = 2] = \"InvertedAlpha\";\n    MatteMode[MatteMode[\"Luma\"] = 3] = \"Luma\";\n    MatteMode[MatteMode[\"InvertedLuma\"] = 4] = \"InvertedLuma\";\n})(MatteMode || (MatteMode = {}));\nvar Layer3DMode;\n(function (Layer3DMode) {\n    Layer3DMode[Layer3DMode[\"Off\"] = 0] = \"Off\";\n    Layer3DMode[Layer3DMode[\"On\"] = 1] = \"On\";\n})(Layer3DMode || (Layer3DMode = {}));\nvar AutoOrientMode;\n(function (AutoOrientMode) {\n    AutoOrientMode[AutoOrientMode[\"Off\"] = 0] = \"Off\";\n    AutoOrientMode[AutoOrientMode[\"On\"] = 1] = \"On\";\n})(AutoOrientMode || (AutoOrientMode = {}));\nvar EffectValueType;\n(function (EffectValueType) {\n    EffectValueType[EffectValueType[\"Number\"] = 0] = \"Number\";\n    EffectValueType[EffectValueType[\"Color\"] = 2] = \"Color\";\n    EffectValueType[EffectValueType[\"MultiDimensional\"] = 3] = \"MultiDimensional\";\n    EffectValueType[EffectValueType[\"Boolean\"] = 7] = \"Boolean\";\n})(EffectValueType || (EffectValueType = {}));\nvar EffectType;\n(function (EffectType) {\n    EffectType[EffectType[\"Transform\"] = 5] = \"Transform\";\n    EffectType[EffectType[\"DropShadow\"] = 25] = \"DropShadow\";\n})(EffectType || (EffectType = {}));\nvar MaskMode;\n(function (MaskMode) {\n    MaskMode[\"No\"] = \"n\";\n    MaskMode[\"Add\"] = \"a\";\n    MaskMode[\"Subtract\"] = \"s\";\n    MaskMode[\"Intersect\"] = \"i\";\n    MaskMode[\"Lighten\"] = \"l\";\n    MaskMode[\"Darken\"] = \"d\";\n    MaskMode[\"Difference\"] = \"f\";\n})(MaskMode || (MaskMode = {}));\nvar LayerType;\n(function (LayerType) {\n    LayerType[LayerType[\"precomp\"] = 0] = \"precomp\";\n    LayerType[LayerType[\"solid\"] = 1] = \"solid\";\n    LayerType[LayerType[\"image\"] = 2] = \"image\";\n    LayerType[LayerType[\"null\"] = 3] = \"null\";\n    LayerType[LayerType[\"shape\"] = 4] = \"shape\";\n    LayerType[LayerType[\"text\"] = 5] = \"text\";\n    LayerType[LayerType[\"audio\"] = 6] = \"audio\";\n    LayerType[LayerType[\"pholderVideo\"] = 7] = \"pholderVideo\";\n    LayerType[LayerType[\"imageSeq\"] = 8] = \"imageSeq\";\n    LayerType[LayerType[\"video\"] = 9] = \"video\";\n    LayerType[LayerType[\"pholderStill\"] = 10] = \"pholderStill\";\n    LayerType[LayerType[\"guide\"] = 11] = \"guide\";\n    LayerType[LayerType[\"adjustment\"] = 12] = \"adjustment\";\n    LayerType[LayerType[\"camera\"] = 13] = \"camera\";\n    LayerType[LayerType[\"light\"] = 14] = \"light\";\n    LayerType[LayerType[\"data\"] = 15] = \"data\";\n})(LayerType || (LayerType = {}));\nvar TextJustify;\n(function (TextJustify) {\n    TextJustify[TextJustify[\"Left\"] = 0] = \"Left\";\n    TextJustify[TextJustify[\"Right\"] = 1] = \"Right\";\n    TextJustify[TextJustify[\"Center\"] = 2] = \"Center\";\n})(TextJustify || (TextJustify = {}));\nvar VerticalJustify;\n(function (VerticalJustify) {\n    VerticalJustify[VerticalJustify[\"Top\"] = 0] = \"Top\";\n    VerticalJustify[VerticalJustify[\"Center\"] = 1] = \"Center\";\n    VerticalJustify[VerticalJustify[\"Bottom\"] = 2] = \"Bottom\";\n})(VerticalJustify || (VerticalJustify = {}));\nvar RangeSelectorDomain;\n(function (RangeSelectorDomain) {\n    RangeSelectorDomain[RangeSelectorDomain[\"Characters\"] = 1] = \"Characters\";\n    RangeSelectorDomain[RangeSelectorDomain[\"CharactersExcludingSpaces\"] = 2] = \"CharactersExcludingSpaces\";\n    RangeSelectorDomain[RangeSelectorDomain[\"Words\"] = 3] = \"Words\";\n    RangeSelectorDomain[RangeSelectorDomain[\"Lines\"] = 4] = \"Lines\";\n})(RangeSelectorDomain || (RangeSelectorDomain = {}));\nvar RangeSelectorShape;\n(function (RangeSelectorShape) {\n    RangeSelectorShape[RangeSelectorShape[\"Square\"] = 1] = \"Square\";\n    RangeSelectorShape[RangeSelectorShape[\"RampUp\"] = 2] = \"RampUp\";\n    RangeSelectorShape[RangeSelectorShape[\"RampDown\"] = 3] = \"RampDown\";\n    RangeSelectorShape[RangeSelectorShape[\"Triangle\"] = 4] = \"Triangle\";\n    RangeSelectorShape[RangeSelectorShape[\"Round\"] = 5] = \"Round\";\n    RangeSelectorShape[RangeSelectorShape[\"Smooth\"] = 6] = \"Smooth\";\n})(RangeSelectorShape || (RangeSelectorShape = {}));\nvar RangeSelectorUnits;\n(function (RangeSelectorUnits) {\n    RangeSelectorUnits[RangeSelectorUnits[\"Percentage\"] = 1] = \"Percentage\";\n    RangeSelectorUnits[RangeSelectorUnits[\"Index\"] = 2] = \"Index\";\n})(RangeSelectorUnits || (RangeSelectorUnits = {}));\nvar RangeSelectorMode;\n(function (RangeSelectorMode) {\n    RangeSelectorMode[RangeSelectorMode[\"Add\"] = 1] = \"Add\";\n    RangeSelectorMode[RangeSelectorMode[\"Subtract\"] = 2] = \"Subtract\";\n    RangeSelectorMode[RangeSelectorMode[\"Intersect\"] = 3] = \"Intersect\";\n    RangeSelectorMode[RangeSelectorMode[\"Min\"] = 4] = \"Min\";\n    RangeSelectorMode[RangeSelectorMode[\"Max\"] = 5] = \"Max\";\n    RangeSelectorMode[RangeSelectorMode[\"Difference\"] = 6] = \"Difference\";\n})(RangeSelectorMode || (RangeSelectorMode = {}));\n/**\n * @see https://lottiefiles.github.io/lottie-docs/shapes/#shape-types\n */\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[\"Rectangle\"] = \"rc\";\n    ShapeType[\"Ellipse\"] = \"el\";\n    ShapeType[\"PolyStar\"] = \"sr\";\n    ShapeType[\"Path\"] = \"sh\";\n    ShapeType[\"Fill\"] = \"fl\";\n    ShapeType[\"Stroke\"] = \"st\";\n    ShapeType[\"GradientFill\"] = \"gf\";\n    ShapeType[\"GradientStroke\"] = \"gs\";\n    ShapeType[\"NoStyle\"] = \"no\";\n    ShapeType[\"Group\"] = \"gr\";\n    ShapeType[\"Transform\"] = \"tr\";\n    ShapeType[\"Repeater\"] = \"rp\";\n    ShapeType[\"Trim\"] = \"tm\";\n    ShapeType[\"RoundedCorners\"] = \"rd\";\n    ShapeType[\"PuckerOrBloat\"] = \"pb\";\n    ShapeType[\"Merge\"] = \"mm\";\n    ShapeType[\"Twist\"] = \"tw\";\n    ShapeType[\"OffsetPath\"] = \"op\";\n    ShapeType[\"ZigZag\"] = \"zz\";\n})(ShapeType || (ShapeType = {}));\n/**\n * @see https://lottiefiles.github.io/lottie-docs/constants/#fillrule\n */\nvar FillRule;\n(function (FillRule) {\n    FillRule[FillRule[\"NonZero\"] = 1] = \"NonZero\";\n    FillRule[FillRule[\"EvenOdd\"] = 2] = \"EvenOdd\";\n})(FillRule || (FillRule = {}));\n/**\n * @see https://lottiefiles.github.io/lottie-docs/constants/#linejoin\n */\nvar LineJoin;\n(function (LineJoin) {\n    LineJoin[LineJoin[\"Miter\"] = 1] = \"Miter\";\n    LineJoin[LineJoin[\"Round\"] = 2] = \"Round\";\n    LineJoin[LineJoin[\"Bevel\"] = 3] = \"Bevel\";\n})(LineJoin || (LineJoin = {}));\n/**\n * @see https://lottiefiles.github.io/lottie-docs/constants/#linecap\n */\nvar LineCap;\n(function (LineCap) {\n    LineCap[LineCap[\"Butt\"] = 1] = \"Butt\";\n    LineCap[LineCap[\"Round\"] = 2] = \"Round\";\n    LineCap[LineCap[\"Square\"] = 3] = \"Square\";\n})(LineCap || (LineCap = {}));\n/**\n * @see https://lottiefiles.github.io/lottie-docs/constants/#gradienttype\n */\nvar GradientType;\n(function (GradientType) {\n    GradientType[GradientType[\"Linear\"] = 1] = \"Linear\";\n    GradientType[GradientType[\"Radial\"] = 2] = \"Radial\";\n})(GradientType || (GradientType = {}));\nvar FontPathOrigin;\n(function (FontPathOrigin) {\n    FontPathOrigin[FontPathOrigin[\"CssUrl\"] = 1] = \"CssUrl\";\n    FontPathOrigin[FontPathOrigin[\"ScriptUrl\"] = 2] = \"ScriptUrl\";\n    FontPathOrigin[FontPathOrigin[\"FontUrl\"] = 3] = \"FontUrl\";\n})(FontPathOrigin || (FontPathOrigin = {}));\n\nvar ParseContext = /** @class */ (function () {\n    function ParseContext() {\n        this.frameTime = 1000 / 30;\n        this.startFrame = 0;\n        this.autoplay = false;\n        this.fill = 'auto';\n        this.iterations = 0;\n        this.assetsMap = new Map();\n    }\n    return ParseContext;\n}());\nfunction isNumberArray(val) {\n    return Array.isArray(val) && typeof val[0] === 'number';\n}\nfunction isMultiDimensionalValue(val) {\n    return isNumberArray(val === null || val === void 0 ? void 0 : val.k);\n}\nfunction isMultiDimensionalKeyframedValue(val) {\n    var k = val === null || val === void 0 ? void 0 : val.k;\n    return Array.isArray(k) && k[0].t !== undefined && isNumberArray(k[0].s);\n}\nfunction isValue(val) {\n    // TODO is [100] sort of value?\n    return typeof (val === null || val === void 0 ? void 0 : val.k) === 'number';\n}\nfunction isKeyframedValue(val) {\n    var k = val === null || val === void 0 ? void 0 : val.k;\n    return Array.isArray(k) && k[0].t !== undefined && typeof k[0].s === 'number';\n}\nfunction toColorString(val) {\n    var opacity = getMultiDimensionValue(val, 3);\n    return \"rgba(\".concat([\n        Math.round(getMultiDimensionValue(val, 0) * 255),\n        Math.round(getMultiDimensionValue(val, 1) * 255),\n        Math.round(getMultiDimensionValue(val, 2) * 255),\n        !util.isNil(opacity) ? opacity : 1,\n    ].join(','), \")\");\n}\nfunction getMultiDimensionValue(val, dimIndex) {\n    return val != null\n        ? typeof val === 'number'\n            ? val\n            : val[dimIndex || 0]\n        : NaN;\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/concepts/#easing-handles\n */\nfunction getMultiDimensionEasingBezierString(kf, nextKf, dimIndex) {\n    var _a, _b, _c, _d;\n    var bezierEasing = [];\n    bezierEasing.push((((_a = kf.o) === null || _a === void 0 ? void 0 : _a.x) &&\n        (getMultiDimensionValue(kf.o.x, dimIndex) ||\n            getMultiDimensionValue(kf.o.x, 0))) ||\n        0, (((_b = kf.o) === null || _b === void 0 ? void 0 : _b.y) &&\n        (getMultiDimensionValue(kf.o.y, dimIndex) ||\n            getMultiDimensionValue(kf.o.y, 0))) ||\n        0, (((_c = kf.i) === null || _c === void 0 ? void 0 : _c.x) &&\n        (getMultiDimensionValue(kf.i.x, dimIndex) ||\n            getMultiDimensionValue(kf.i.x, 0))) ||\n        1, (((_d = kf.i) === null || _d === void 0 ? void 0 : _d.y) &&\n        (getMultiDimensionValue(kf.i.y, dimIndex) ||\n            getMultiDimensionValue(kf.i.y, 0))) ||\n        1);\n    // linear by default\n    if (!(bezierEasing[0] === 0 &&\n        bezierEasing[1] === 0 &&\n        bezierEasing[2] === 1 &&\n        bezierEasing[3] === 1)) {\n        return \"cubic-bezier(\".concat(bezierEasing.join(','), \")\");\n    }\n    return;\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/concepts/#keyframe\n */\nfunction parseKeyframe(kfs, bezierEasingDimIndex, context, setVal) {\n    var kfsLen = kfs.length;\n    // const offset = context.layerStartTime;\n    var duration = context.endFrame - context.startFrame;\n    var out = {\n        duration: 0,\n        delay: 0,\n        keyframes: [],\n    };\n    var prevKf;\n    for (var i = 0; i < kfsLen; i++) {\n        var kf = kfs[i];\n        var nextKf = kfs[i + 1];\n        // If h is present and it's 1, you don't need i and o,\n        // as the property will keep the same value until the next keyframe.\n        var isDiscrete = kf.h === 1;\n        var offset = (kf.t + context.layerOffsetTime - context.startFrame) / duration;\n        var outKeyframe = {\n            offset: offset,\n        };\n        if (!isDiscrete) {\n            outKeyframe.easing = getMultiDimensionEasingBezierString(kf, nextKf, bezierEasingDimIndex);\n        }\n        // Use end state of later frame if start state not exits.\n        // @see https://lottiefiles.github.io/lottie-docs/concepts/#old-lottie-keyframes\n        var startVal = kf.s || (prevKf === null || prevKf === void 0 ? void 0 : prevKf.e);\n        if (startVal) {\n            setVal(outKeyframe, startVal);\n        }\n        if (outKeyframe.offset > 0 && i === 0) {\n            // Set initial\n            var initialKeyframe = {\n                offset: 0,\n            };\n            if (startVal) {\n                setVal(initialKeyframe, startVal);\n            }\n            out.keyframes.push(initialKeyframe);\n        }\n        out.keyframes.push(outKeyframe);\n        if (isDiscrete && nextKf) {\n            // Use two keyframe to simulate the discrete animation.\n            var extraKeyframe = {\n                offset: Math.max((nextKf.t + context.layerOffsetTime - context.startFrame) / duration, 0),\n            };\n            setVal(extraKeyframe, startVal);\n            out.keyframes.push(extraKeyframe);\n        }\n        prevKf = kf;\n    }\n    if (kfsLen) {\n        out.duration = context.frameTime * duration;\n    }\n    return out;\n}\nfunction parseOffsetKeyframe(kfs, targetPropName, propNames, keyframeAnimations, context, convertVal) {\n    var _loop_1 = function (dimIndex) {\n        var propName = propNames[dimIndex];\n        var keyframeAnim = parseKeyframe(kfs, dimIndex, context, function (outKeyframe, startVal) {\n            var val = getMultiDimensionValue(startVal, dimIndex);\n            if (convertVal) {\n                val = convertVal(val);\n            }\n            (targetPropName\n                ? (outKeyframe[targetPropName] = {})\n                : outKeyframe)[propName] = val;\n        });\n        // moving position around a curved path\n        var needOffsetPath = kfs.some(function (kf) { return kf.ti && kf.to; });\n        if (needOffsetPath) {\n            var offsetPath_1 = [];\n            kfs.forEach(function (kf, i) {\n                keyframeAnim.keyframes[i].offsetPath = offsetPath_1;\n                // convert to & ti(Tangent for values (eg: moving position around a curved path)) to offsetPath & offsetDistance\n                // @see https://lottiefiles.github.io/lottie-docs/concepts/#animated-position\n                if (kf.ti && kf.to) {\n                    if (i === 0) {\n                        offsetPath_1.push(['M', kf.s[0], kf.s[1]]);\n                    }\n                    keyframeAnim.keyframes[i].segmentLength = util.getTotalLength(offsetPath_1);\n                    // @see https://lottiefiles.github.io/lottie-docs/concepts/#bezier\n                    // The nth bezier segment is defined as:\n                    // v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1]\n                    offsetPath_1.push([\n                        'C',\n                        kf.s[0] + kf.to[0],\n                        kf.s[1] + kf.to[1],\n                        kf.s[0] + kf.ti[0],\n                        kf.s[1] + kf.ti[1],\n                        kf.e[0],\n                        kf.e[1],\n                    ]);\n                }\n            });\n            // calculate offsetDistance: segmentLength / totalLength\n            var totalLength_1 = util.getTotalLength(offsetPath_1);\n            keyframeAnim.keyframes.forEach(function (kf) {\n                kf.offsetDistance = util.isNil(kf.segmentLength)\n                    ? 1\n                    : kf.segmentLength / totalLength_1;\n                delete kf.segmentLength;\n            });\n        }\n        if (keyframeAnim.keyframes.length) {\n            keyframeAnimations.push(keyframeAnim);\n        }\n    };\n    for (var dimIndex = 0; dimIndex < propNames.length; dimIndex++) {\n        _loop_1(dimIndex);\n    }\n}\nfunction parseColorOffsetKeyframe(kfs, targetPropName, propName, keyframeAnimations, context) {\n    var keyframeAnim = parseKeyframe(kfs, 0, context, function (outKeyframe, startVal) {\n        (targetPropName\n            ? (outKeyframe[targetPropName] = {})\n            : outKeyframe)[propName] = toColorString(startVal);\n    });\n    if (keyframeAnim.keyframes.length) {\n        keyframeAnimations.push(keyframeAnim);\n    }\n}\nfunction parseValue(lottieVal, attrs, targetPropName, propNames, animations, context, convertVal) {\n    if (targetPropName) {\n        attrs[targetPropName] = attrs[targetPropName] || {};\n    }\n    var target = targetPropName ? attrs[targetPropName] : attrs;\n    if (isValue(lottieVal)) {\n        var val = lottieVal.k;\n        target[propNames[0]] = convertVal ? convertVal(val) : val;\n    }\n    else if (isKeyframedValue(lottieVal)) {\n        parseOffsetKeyframe(lottieVal.k, targetPropName, propNames, animations, context, convertVal);\n    }\n    else if (isMultiDimensionalValue(lottieVal)) {\n        for (var i = 0; i < propNames.length; i++) {\n            var val = getMultiDimensionValue(lottieVal.k, i);\n            target[propNames[i]] = convertVal ? convertVal(val) : val;\n        }\n    }\n    else if (isMultiDimensionalKeyframedValue(lottieVal)) {\n        // TODO Merge dimensions\n        parseOffsetKeyframe(lottieVal.k, targetPropName, propNames, animations, context, convertVal);\n    }\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/concepts/#transform\n */\nfunction parseTransforms(ks, attrs, animations, context, targetProp, transformProps) {\n    if (targetProp === void 0) { targetProp = ''; }\n    if (transformProps === void 0) { transformProps = {\n        x: 'x',\n        y: 'y',\n        rotation: 'rotation',\n        scaleX: 'scaleX',\n        scaleY: 'scaleY',\n        anchorX: 'anchorX',\n        anchorY: 'anchorY',\n        skew: 'skew',\n        skewAxis: 'skewAxis',\n    }; }\n    // @see https://lottiefiles.github.io/lottie-docs/concepts/#split-vector\n    if (ks.p.s) {\n        parseValue(ks.p.x, attrs, targetProp, [transformProps.x], animations, context);\n        parseValue(ks.p.y, attrs, targetProp, [transformProps.y], animations, context);\n    }\n    else {\n        parseValue(ks.p, attrs, targetProp, [transformProps.x, transformProps.y], animations, context);\n    }\n    parseValue(ks.s, attrs, targetProp, [transformProps.scaleX, transformProps.scaleY], animations, context, function (val) { return val / 100; });\n    parseValue(ks.r, attrs, targetProp, [transformProps.rotation], animations, context);\n    parseValue(ks.a, attrs, targetProp, [transformProps.anchorX, transformProps.anchorY], animations, context);\n    parseValue(ks.sk, attrs, targetProp, [transformProps.skew], animations, context);\n    parseValue(ks.sa, attrs, targetProp, [transformProps.skewAxis], animations, context);\n}\nfunction isGradientFillOrStroke(fl) {\n    return fl.g && fl.s && fl.e;\n}\nfunction convertColorStops(arr, count) {\n    var colorStops = [];\n    for (var i = 0; i < count * 4;) {\n        var offset = arr[i++];\n        var r = Math.round(arr[i++] * 255);\n        var g = Math.round(arr[i++] * 255);\n        var b = Math.round(arr[i++] * 255);\n        colorStops.push({\n            offset: offset,\n            color: \"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\"),\n        });\n    }\n    return colorStops;\n}\nfunction joinColorStops(colorStops) {\n    return \"\".concat(colorStops\n        .map(function (_a) {\n        var offset = _a.offset, color = _a.color;\n        return \"\".concat(color, \" \").concat(offset * 100, \"%\");\n    })\n        .join(', '));\n}\n/**\n * TODO:\n * * Transition\n * * Highlight length & angle in Radial Gradient\n *\n * @see https://lottiefiles.github.io/lottie-docs/concepts/#gradients\n * @see https://lottiefiles.github.io/lottie-docs/shapes/#gradients\n */\nfunction parseGradient(shape) {\n    var colorArr = shape.g.k.k;\n    var colorStops = convertColorStops(colorArr, shape.g.p);\n    // @see https://lottiefiles.github.io/lottie-docs/constants/#gradienttype\n    if (shape.t === GradientType.Linear) {\n        var angle = gLite.rad2deg(Math.atan2(shape.e.k[1] - shape.s.k[1], shape.e.k[0] - shape.s.k[0]));\n        // @see https://g-next.antv.vision/zh/docs/api/css/css-properties-values-api#linear-gradient\n        return \"linear-gradient(\".concat(angle, \"deg, \").concat(joinColorStops(colorStops), \")\");\n    }\n    else if (shape.t === GradientType.Radial) {\n        // TODO: highlight length & angle (h & a)\n        // Highlight Length, as a percentage between s and e\n        // Highlight Angle, relative to the direction from s to e\n        var size = util.distanceSquareRoot(shape.e.k, shape.s.k);\n        // @see https://g-next.antv.vision/zh/docs/api/css/css-properties-values-api#radial-gradient\n        return \"radial-gradient(circle \".concat(size, \"px at \").concat(shape.s.k[0], \"px \").concat(shape.s.k[1], \"px, \").concat(joinColorStops(colorStops), \")\");\n    }\n    else {\n        // Invalid gradient\n        return '#000';\n    }\n}\nfunction parseFill(fl, attrs, animations, context) {\n    attrs.style = attrs.style || {};\n    // Color\n    if (isGradientFillOrStroke(fl)) {\n        attrs.style.fill = parseGradient(fl);\n    }\n    else {\n        if (isMultiDimensionalValue(fl.c)) {\n            attrs.style.fill = toColorString(fl.c.k);\n        }\n        else if (isMultiDimensionalKeyframedValue(fl.c)) {\n            parseColorOffsetKeyframe(fl.c.k, 'style', 'fill', animations, context);\n        }\n    }\n    // FillRule @see https://lottiefiles.github.io/lottie-docs/constants/#fillrule\n    attrs.style.fillRule =\n        fl.r === FillRule.EvenOdd ? 'evenodd' : 'nonzero';\n    // Opacity\n    parseValue(fl.o, attrs, 'style', ['fillOpacity'], animations, context, function (opacity) { return opacity / 100; });\n}\nfunction parseStroke(st, attrs, animations, context) {\n    attrs.style = attrs.style || {};\n    // Color\n    if (isGradientFillOrStroke(st)) {\n        attrs.style.stroke = parseGradient(st);\n    }\n    else {\n        if (isMultiDimensionalValue(st.c)) {\n            attrs.style.stroke = toColorString(st.c.k);\n        }\n        else if (isMultiDimensionalKeyframedValue(st.c)) {\n            parseColorOffsetKeyframe(st.c.k, 'style', 'stroke', animations, context);\n        }\n    }\n    // Opacity\n    parseValue(st.o, attrs, 'style', ['strokeOpacity'], animations, context, function (opacity) { return opacity / 100; });\n    // Line width\n    parseValue(st.w, attrs, 'style', ['lineWidth'], animations, context);\n    switch (st.lj) {\n        case LineJoin.Bevel:\n            attrs.style.lineJoin = 'bevel';\n            break;\n        case LineJoin.Round:\n            attrs.style.lineJoin = 'round';\n            break;\n        case LineJoin.Miter:\n            attrs.style.lineJoin = 'miter';\n            break;\n    }\n    switch (st.lc) {\n        case LineCap.Butt:\n            attrs.style.lineCap = 'butt';\n            break;\n        case LineCap.Round:\n            attrs.style.lineCap = 'round';\n            break;\n        case LineCap.Square:\n            attrs.style.lineCap = 'square';\n            break;\n    }\n    // Line dash\n    var dashArray = [];\n    var dashOffset = 0;\n    if (st.d) {\n        st.d.forEach(function (item) {\n            if (item.n !== 'o') {\n                dashArray.push(item.v.k);\n            }\n            else {\n                dashOffset = item.v.k;\n            }\n        });\n        attrs.style.lineDash = dashArray;\n        attrs.style.lineDashOffset = dashOffset;\n    }\n}\nfunction isBezier(k) {\n    return k && k.i && k.o && k.v;\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/shapes/#path\n */\nfunction parseShapePaths(shape, animations, context) {\n    var attrs = {\n        type: gLite.Shape.PATH,\n        // Should have no fill and stroke by default\n        style: {\n            fill: 'none',\n            stroke: 'none',\n        },\n    };\n    // @see https://lottiefiles.github.io/lottie-docs/concepts/#bezier\n    if (isBezier(shape.ks.k)) {\n        attrs.shape = {\n            in: shape.ks.k.i,\n            out: shape.ks.k.o,\n            v: shape.ks.k.v,\n            close: shape.ks.k.c,\n        };\n    }\n    else if (Array.isArray(shape.ks.k)) {\n        var keyframeAnim = parseKeyframe(shape.ks.k, 0, context, function (outKeyframe, startVal) {\n            outKeyframe.shape = {\n                in: startVal[0].i,\n                out: startVal[0].o,\n                v: startVal[0].v,\n                close: startVal[0].c,\n            };\n        });\n        if (keyframeAnim.keyframes.length) {\n            animations.push(keyframeAnim);\n        }\n    }\n    return attrs;\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/shapes/#rectangle\n */\nfunction parseShapeRect(shape, animations, context) {\n    var attrs = {\n        type: gLite.Shape.RECT,\n        // Should have no fill and stroke by default\n        style: {\n            fill: 'none',\n            stroke: 'none',\n        },\n        shape: {},\n    };\n    parseValue(shape.p, attrs, 'shape', ['x', 'y'], animations, context);\n    parseValue(shape.s, attrs, 'shape', ['width', 'height'], animations, context);\n    parseValue(shape.r, attrs, 'shape', ['r'], animations, context);\n    return attrs;\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/layers/#image-layer\n */\nfunction parseImageLayer(layer, context) {\n    var attrs = {\n        type: gLite.Shape.IMAGE,\n        style: {},\n        shape: {\n            width: 0,\n            height: 0,\n            src: '',\n        },\n    };\n    var asset = context.assetsMap.get(layer.refId);\n    if (asset) {\n        attrs.shape.width = asset.w;\n        attrs.shape.height = asset.h;\n        // TODO: url to fetch\n        attrs.shape.src = asset.p;\n    }\n    return attrs;\n}\n/**\n * @see https://lottiefiles.github.io/lottie-docs/shapes/#ellipse\n */\nfunction parseShapeEllipse(shape, animations, context) {\n    var attrs = {\n        type: gLite.Shape.ELLIPSE,\n        // Should have no fill and stroke by default\n        style: {\n            fill: 'none',\n            stroke: 'none',\n        },\n        shape: {},\n    };\n    parseValue(shape.p, attrs, 'shape', ['cx', 'cy'], animations, context);\n    parseValue(shape.s, attrs, 'shape', ['rx', 'ry'], animations, context, function (val) { return val / 2; });\n    return attrs;\n}\nfunction parseShapeLayer(layer, context) {\n    function tryCreateShape(shape, keyframeAnimations) {\n        var ecEl;\n        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n        switch (shape.ty) {\n            case ShapeType.Path:\n                ecEl = parseShapePaths(shape, keyframeAnimations, context);\n                break;\n            case ShapeType.Ellipse:\n                ecEl = parseShapeEllipse(shape, keyframeAnimations, context);\n                break;\n            case ShapeType.Rectangle:\n                ecEl = parseShapeRect(shape, keyframeAnimations, context);\n                break;\n            case ShapeType.PolyStar:\n                // TODO: parseShapePolyStar\n                break;\n        }\n        return ecEl;\n    }\n    function parseModifiers(shapes, modifiers) {\n        shapes.forEach(function (shape) {\n            if (shape.hd) {\n                return;\n            }\n            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n            switch (shape.ty) {\n                case ShapeType.Repeater:\n                    parseValue(shape.c, modifiers.attrs, 'shape', ['repeat'], modifiers.keyframeAnimations, context);\n                    parseTransforms(shape.tr, modifiers.attrs, modifiers.keyframeAnimations, context, 'shape', {\n                        x: 'repeatX',\n                        y: 'repeatY',\n                        rotation: 'repeatRot',\n                        scaleX: 'repeatScaleX',\n                        scaleY: 'repeatScaleY',\n                        anchorX: 'repeatAnchorX',\n                        anchorY: 'repeatAnchorY',\n                        skew: 'repeatSkew',\n                        skewAxis: 'repeatSkewAxis',\n                    });\n                    break;\n                case ShapeType.Trim:\n                    parseValue(shape.s, modifiers.attrs, 'shape', ['trimStart'], modifiers.keyframeAnimations, context);\n                    parseValue(shape.e, modifiers.attrs, 'shape', ['trimEnd'], modifiers.keyframeAnimations, context);\n                    break;\n            }\n        });\n    }\n    function parseIterations(shapes, modifiers) {\n        var ecEls = [];\n        var attrs = {};\n        var keyframeAnimations = [];\n        // Order is reversed\n        shapes = shapes.slice().reverse();\n        // Modifiers first:\n        parseModifiers(shapes, modifiers);\n        shapes.forEach(function (shape) {\n            if (shape.hd) {\n                return;\n            }\n            var ecEl;\n            switch (shape.ty) {\n                case ShapeType.Group:\n                    ecEl = {\n                        type: gLite.Shape.GROUP,\n                        children: parseIterations(shape.it, \n                        // Modifiers will be applied to all childrens.\n                        modifiers),\n                    };\n                    break;\n                // TODO Multiple fill and stroke\n                case ShapeType.Fill:\n                case ShapeType.GradientFill:\n                    parseFill(shape, attrs, keyframeAnimations, context);\n                    break;\n                case ShapeType.Stroke:\n                case ShapeType.GradientStroke:\n                    parseStroke(shape, attrs, keyframeAnimations, context);\n                    break;\n                case ShapeType.Transform:\n                    parseTransforms(shape, attrs, keyframeAnimations, context);\n                    break;\n                // TODO Multiple shapes.\n                default:\n                    ecEl = tryCreateShape(shape, keyframeAnimations);\n            }\n            if (ecEl) {\n                ecEl.name = shape.nm;\n                ecEls.push(ecEl);\n            }\n        });\n        ecEls.forEach(function (el, idx) {\n            // Apply modifiers first\n            el = tslib.__assign(tslib.__assign(tslib.__assign({}, el), gLite.definedProps(modifiers.attrs)), attrs);\n            if (keyframeAnimations.length || modifiers.keyframeAnimations.length) {\n                el.keyframeAnimation = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(modifiers.keyframeAnimations), false), tslib.__read(keyframeAnimations), false);\n            }\n            ecEls[idx] = el;\n        });\n        return ecEls;\n    }\n    return {\n        type: gLite.Shape.GROUP,\n        children: parseIterations(layer.shapes, {\n            attrs: {},\n            keyframeAnimations: [],\n        }),\n    };\n}\nfunction traverse(el, cb) {\n    var _a;\n    cb(el);\n    if (el.type === gLite.Shape.GROUP) {\n        (_a = el.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            traverse(child, cb);\n        });\n    }\n}\nfunction addLayerOpacity(layer, layerGroup, context) {\n    var _a, _b;\n    var opacityAttrs = {};\n    var opacityAnimations = [];\n    if ((_a = layer.ks) === null || _a === void 0 ? void 0 : _a.o) {\n        parseValue(layer.ks.o, opacityAttrs, 'style', ['opacity'], opacityAnimations, context, function (val) { return val / 100; });\n        if (((_b = opacityAttrs.style) === null || _b === void 0 ? void 0 : _b.opacity) || opacityAnimations.length) {\n            // apply opacity to group's children\n            traverse(layerGroup, function (el) {\n                if (el.type !== gLite.Shape.GROUP && el.style) {\n                    Object.assign(el.style, opacityAttrs.style);\n                    if (opacityAnimations.length) {\n                        el.keyframeAnimation = (el.keyframeAnimation || []).concat(opacityAnimations);\n                    }\n                }\n            });\n        }\n    }\n}\nfunction parseSolidShape(layer) {\n    return {\n        type: gLite.Shape.RECT,\n        shape: {\n            x: 0,\n            y: 0,\n            width: layer.sw,\n            height: layer.sh,\n        },\n        style: {\n            fill: layer.sc,\n        },\n    };\n}\nfunction parseLayers(layers, context, precompLayerTl) {\n    var elements = [];\n    // Order is reversed\n    layers = layers.slice().reverse();\n    var layerIndexMap = new Map();\n    var offsetTime = (precompLayerTl === null || precompLayerTl === void 0 ? void 0 : precompLayerTl.st) || 0;\n    layers === null || layers === void 0 ? void 0 : layers.forEach(function (layer) {\n        // Layer time is offseted by the precomp layer.\n        var _a, _b;\n        // Use the ip, op, st of ref from.\n        var layerIp = offsetTime + layer.ip;\n        var layerOp = offsetTime + layer.op;\n        var layerSt = offsetTime + layer.st;\n        context.layerOffsetTime = offsetTime;\n        var layerGroup;\n        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n        switch (layer.ty) {\n            case LayerType.shape:\n                // @see https://lottiefiles.github.io/lottie-docs/layers/#shape-layer\n                layerGroup = parseShapeLayer(layer, context);\n                break;\n            case LayerType.null:\n                // @see https://lottiefiles.github.io/lottie-docs/layers/#null-layer\n                layerGroup = {\n                    type: gLite.Shape.GROUP,\n                    children: [],\n                };\n                break;\n            case LayerType.solid:\n                // @see https://lottiefiles.github.io/lottie-docs/layers/#solid-color-layer\n                layerGroup = {\n                    type: gLite.Shape.GROUP,\n                    children: [],\n                };\n                // Anything you can do with solid layers, you can do better with a shape layer and a rectangle shape\n                // since none of this layer's own properties can be animated.\n                if (layer.sc) {\n                    layerGroup.children.push(parseSolidShape(layer));\n                }\n                break;\n            case LayerType.precomp:\n                // @see https://lottiefiles.github.io/lottie-docs/layers/#precomposition-layer\n                layerGroup = {\n                    type: gLite.Shape.GROUP,\n                    children: parseLayers(((_a = context.assetsMap.get(layer.refId)) === null || _a === void 0 ? void 0 : _a.layers) || [], context, {\n                        st: layerSt,\n                    }),\n                };\n                break;\n            case LayerType.text:\n                // TODO: https://lottiefiles.github.io/lottie-docs/layers/#text-layer\n                break;\n            case LayerType.image:\n                // TODO: https://lottiefiles.github.io/lottie-docs/layers/#image-layer\n                layerGroup = layerGroup = {\n                    type: gLite.Shape.GROUP,\n                    children: [parseImageLayer(layer, context)],\n                };\n                break;\n        }\n        if (layerGroup) {\n            var keyframeAnimations = [];\n            var attrs = {\n                name: layer.nm,\n            };\n            if (layer.ks) {\n                parseTransforms(layer.ks, attrs, keyframeAnimations, context);\n            }\n            Object.assign(layerGroup, attrs);\n            if (layer.ind != null) {\n                layerIndexMap.set(layer.ind, layerGroup);\n            }\n            layerGroup.extra = {\n                layerParent: layer.parent,\n            };\n            // Masks @see https://lottiefiles.github.io/lottie-docs/layers/#masks\n            // @see https://lottie-animation-community.github.io/docs/specs/layers/common/#clipping-masks\n            // TODO: not support alpha and other modes.\n            // @see https://lottie-animation-community.github.io/docs/specs/properties/mask-mode-types/\n            if (layer.hasMask && ((_b = layer.masksProperties) === null || _b === void 0 ? void 0 : _b.length)) {\n                var maskKeyframeAnimations = [];\n                // TODO: Only support one mask now.\n                var attrs_1 = parseShapePaths({\n                    ks: layer.masksProperties[0].pt,\n                }, maskKeyframeAnimations, context);\n                layerGroup.clipPath = tslib.__assign({ type: gLite.Shape.PATH }, attrs_1);\n                if (maskKeyframeAnimations.length) {\n                    layerGroup.clipPath.keyframeAnimation = maskKeyframeAnimations;\n                }\n            }\n            addLayerOpacity(layer, layerGroup, context);\n            // Update in and out animation.\n            if (layerIp != null &&\n                layerOp != null &&\n                (layerIp > context.startFrame || layerOp < context.endFrame)) {\n                var duration = context.endFrame - context.startFrame;\n                var visibilityStartOffset = (layerIp - context.startFrame) / duration;\n                var visibilityEndOffset = (layerOp - context.startFrame) / duration;\n                layerGroup.visibilityStartOffset = visibilityStartOffset;\n                layerGroup.visibilityEndOffset = visibilityEndOffset;\n                layerGroup.visibilityFrame = duration;\n            }\n            if (keyframeAnimations.length) {\n                layerGroup.keyframeAnimation = keyframeAnimations;\n            }\n            elements.push(layerGroup);\n        }\n    });\n    // Build hierarchy\n    return elements.filter(function (el) {\n        var _a, _b;\n        var parentLayer = layerIndexMap.get((_a = el.extra) === null || _a === void 0 ? void 0 : _a.layerParent);\n        if (parentLayer) {\n            (_b = parentLayer.children) === null || _b === void 0 ? void 0 : _b.push(el);\n            return false;\n        }\n        return true;\n    });\n}\nvar DEFAULT_LOAD_ANIMATION_OPTIONS = {\n    loop: true,\n    autoplay: false,\n    fill: 'both',\n};\nfunction parse(data, options) {\n    var _a;\n    completeData(data);\n    var _b = tslib.__assign(tslib.__assign({}, DEFAULT_LOAD_ANIMATION_OPTIONS), options), loop = _b.loop, autoplay = _b.autoplay, fill = _b.fill;\n    var context = new ParseContext();\n    context.fps = data.fr || 30;\n    context.frameTime = 1000 / context.fps;\n    context.startFrame = data.ip;\n    context.endFrame = data.op;\n    context.version = data.v;\n    context.autoplay = !!autoplay;\n    context.fill = fill;\n    context.iterations = util.isNumber(loop) ? loop : loop ? Infinity : 1;\n    // @see https://lottiefiles.github.io/lottie-docs/assets/\n    (_a = data.assets) === null || _a === void 0 ? void 0 : _a.forEach(function (asset) {\n        context.assetsMap.set(asset.id, asset);\n    });\n    var elements = parseLayers(data.layers || [], context);\n    return {\n        width: data.w,\n        height: data.h,\n        elements: elements,\n        context: context,\n    };\n}\n\n/**\n * @see https://github.com/airbnb/lottie-web/wiki/loadAnimation-options\n * @see https://github.com/airbnb/lottie-web#other-loading-options\n */\nfunction loadAnimation(data, options) {\n    var _a = parse(data, options), width = _a.width, height = _a.height, elements = _a.elements, context = _a.context;\n    return new LottieAnimation(width, height, elements, context);\n}\n\nexports.loadAnimation = loadAnimation;\n//# sourceMappingURL=index.js.map\n"]}