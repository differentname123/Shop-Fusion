我正在使用微信开发者工具开发一款小程序，现在有个抽奖的lottery页面，现在有下面几点需要修改:
1.你帮我分析一下，下面代码有没有能够优化的地方，比如 性能 结构 可读性 冗余代码之类的，给我优化后的完整代码。
2.现在逻辑和相关配置都在js中间是不是有点不合理。
相关代码如下,所涉及到修改的文件，你直接给我完整的修改后的代码，不用给出中间的过程，不修改的文件就不用提供给我了:
lottery.js代码如下:

// lottery.js
Page({
  data: {
    canvasWidth: 500,
    canvasHeight: 500,
    prizes: [
      {
        name: '10积分',
        icon: '/assets/icon1.png',
        range: 1,
        idleAnimation: true,
      },
      {
        name: '20积分',
        icon: '/assets/icon2.png',
        range: 2,
        idleAnimation: false,
      },
      {
        name: '30积分',
        icon: '/assets/icon3.png',
        range: 3,
        idleAnimation: true,
      },
      {
        name: '40积分',
        icon: '/assets/icon4.png',
        range: 2,
        idleAnimation: false,
      },
      {
        name: '50积分',
        icon: '/assets/icon5.png',
        range: 1,
        idleAnimation: true,
      },
      {
        name: '100积分',
        icon: '/assets/icon6.png',
        range: 1,
        idleAnimation: false,
      },
    ],
    totalRange: 0,
    isSpinning: false,
    spinningAngle: 0,
    selectedPrizeIndex: null,
    prizeAnimationFrameId: null,
    idleAnimationFrameId: null,
    canvas: null,
    ctx: null,
    rotationFrameId: null,
    rotateSound: null,
    endSound: null,
    pointerImage: null,
  },

  onLoad() {
    const totalRange = this.data.prizes.reduce((sum, prize) => sum + prize.range, 0);
    this.setData({
      totalRange,
    });

    this.rotateSound = wx.createInnerAudioContext();
    this.rotateSound.src = '/audio/rotate.mp3';
    this.endSound = wx.createInnerAudioContext();
    this.endSound.src = '/audio/end.mp3';

    const query = wx.createSelectorQuery().in(this);
    query.select('#wheelCanvas')
      .node()
      .exec((res) => {
        const canvas = res[0].node;
        const ctx = canvas.getContext('2d');

        this.canvas = canvas;
        this.ctx = ctx;

        const dpr = wx.getSystemInfoSync().pixelRatio;
        canvas.width = this.data.canvasWidth * dpr;
        canvas.height = this.data.canvasHeight * dpr;
        ctx.scale(dpr, dpr);

        Promise.all([
          this.loadPrizeImages(),
          this.loadPointerImage(),
        ]).then(() => {
          this.drawWheel(0);
          this.startIdleAnimation();
        });
      });
  },

  onUnload() {
    if (this.rotationFrameId) {
      this.canvas.cancelAnimationFrame(this.rotationFrameId);
    }
    if (this.prizeAnimationFrameId) {
      this.canvas.cancelAnimationFrame(this.prizeAnimationFrameId);
    }
    if (this.idleAnimationFrameId) {
      this.canvas.cancelAnimationFrame(this.idleAnimationFrameId);
    }
    if (this.rotateSound) {
      this.rotateSound.stop();
      this.rotateSound.destroy();
    }
    if (this.endSound) {
      this.endSound.stop();
      this.endSound.destroy();
    }
  },

  loadPrizeImages() {
    const loadPromises = this.data.prizes.map((prize) => {
      return new Promise((resolve, reject) => {
        const image = this.canvas.createImage();
        image.src = prize.icon;
        image.onload = () => {
          prize.image = image;
          resolve();
        };
        image.onerror = (err) => {
          console.error('加载图片失败：', err);
          reject(err);
        };
      });
    });
    return Promise.all(loadPromises);
  },

  loadPointerImage() {
    return new Promise((resolve, reject) => {
      const image = this.canvas.createImage();
      image.src = '/assets/pointer_rotate1.png';
      image.onload = () => {
        this.pointerImage = image;
        resolve();
      };
      image.onerror = (err) => {
        console.error('加载指针图片失败：', err);
        reject(err);
      };
    });
  },

  drawWheel(angle) {
    const ctx = this.ctx;
    const { canvasWidth, canvasHeight, prizes, totalRange } = this.data;
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    const radius = Math.min(centerX, centerY) - 10;

    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(((angle - 90) * Math.PI) / 180);
    ctx.translate(-centerX, -centerY);

    let startAngle = 0;
    prizes.forEach((prize, index) => {
      const anglePerPrize = (prize.range / totalRange) * 2 * Math.PI;

      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startAngle, startAngle + anglePerPrize);
      ctx.closePath();
      ctx.fillStyle = this.getColor(index);
      ctx.fill();

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(startAngle + anglePerPrize / 2);

      ctx.fillStyle = '#000';
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(prize.name, radius - 60, 0);

      const imgSize = 40;
      let scale = 1;
      if (this.prizeAnimationFrameId && index === this.data.selectedPrizeIndex) {
        scale = 1 + 0.05 * Math.sin((Date.now() % 500) / 500 * Math.PI * 2); // 中奖奖品跳动幅度
      } else if (!this.data.isSpinning && prize.idleAnimation) {
        scale = 1 + 0.1 * Math.sin((Date.now() % 1000) / 1000 * Math.PI * 2); // 闲置状态跳动
      }
      ctx.scale(scale, scale);


      if (prize.image) {
        ctx.drawImage(
          prize.image,
          radius - 180,
          -imgSize / 2,
          imgSize,
          imgSize
        );
      }

      ctx.restore();

      startAngle += anglePerPrize;
    });

    ctx.restore();

    if (this.pointerImage) {
      const pointerSize = 60;
      ctx.drawImage(
        this.pointerImage,
        centerX - pointerSize / 2,
        centerY - pointerSize / 2,
        pointerSize,
        pointerSize
      );
    } else {
      ctx.beginPath();
      ctx.moveTo(centerX, centerY - 20);
      ctx.lineTo(centerX - 10, centerY + 10);
      ctx.lineTo(centerX + 10, centerY + 10);
      ctx.closePath();
      ctx.fillStyle = '#FF0000';
      ctx.fill();
    }
  },

  getColor(index) {
    const colors = ['#FFB6C1', '#FFD700', '#ADFF2F', '#87CEFA', '#FFA500', '#90EE90'];
    return colors[index % colors.length];
  },

  startIdleAnimation() {
    const animate = () => {
      if (!this.data.isSpinning) {
        this.drawWheel(this.data.spinningAngle);
      }
      this.idleAnimationFrameId = this.canvas.requestAnimationFrame(animate);
    };
    this.idleAnimationFrameId = this.canvas.requestAnimationFrame(animate);
  },

  onClick() {
    if (this.data.isSpinning) return;

    this.setData({
      isSpinning: true,
    });

    if (this.idleAnimationFrameId) {
      this.canvas.cancelAnimationFrame(this.idleAnimationFrameId);
      this.idleAnimationFrameId = null;
    }

    this.rotateSound.play();
    let stopAngle = this.getStopAngle();
    console.log(stopAngle);
    this.startRotation(stopAngle);
  },

  getStopAngle() {
    const { prizes, totalRange } = this.data;

    const randomNum = Math.floor(Math.random() * totalRange) + 1;
    let accumulatedRange = 0;
    let selectedPrizeIndex = 0;
    for (let i = 0; i < prizes.length; i++) {
      accumulatedRange += prizes[i].range;
      if (randomNum <= accumulatedRange) {
        selectedPrizeIndex = i;
        break;
      }
    }

    this.setData({
      selectedPrizeIndex,
    });
    console.log(selectedPrizeIndex)
    let startAngle = 0;
    for (let i = 0; i < selectedPrizeIndex; i++) {
      startAngle += (prizes[i].range / totalRange) * 360;
    }
    const prizeAngle = (prizes[selectedPrizeIndex].range / totalRange) * 360;
    const prizeCenterAngle = 360 - startAngle - 9 * prizeAngle / 10;
    const stopAngle = 360 * 5 + prizeCenterAngle;

    return stopAngle;
  },

  startRotation(stopAngle) {
    const duration = 500; // 动画持续时间5秒
    const startTime = Date.now();
    console.log(startTime);
    const initialAngle = this.data.spinningAngle;

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = elapsed / duration;

      if (progress >= 1) {
        // 动画结束
        this.setData({
          spinningAngle: stopAngle % 360,
          isSpinning: false,
        });
        this.drawWheel(this.data.spinningAngle);
        this.rotateSound.stop();
        this.endSound.play();
        const endTime = Date.now();
        console.log(endTime);
        this.showPrize();
        return;
      }

      // 使用一个更加平滑的减速缓动函数
      const easeOutExpo = (t) => 1 - Math.pow(2, -10 * t);
      const easedProgress = easeOutExpo(progress);

      // 更新旋转角度
      const currentAngle = initialAngle + (stopAngle - initialAngle) * easedProgress;

      this.setData({
        spinningAngle: currentAngle % 360,
      });

      this.drawWheel(this.data.spinningAngle);

      // 继续请求动画帧
      this.rotationFrameId = this.canvas.requestAnimationFrame(animate);
    };

    this.rotationFrameId = this.canvas.requestAnimationFrame(animate);
  },


  showPrize() {
    const prize = this.data.prizes[this.data.selectedPrizeIndex];

    // 开始中奖奖品的跳动动画
    this.startPrizeBounceAnimation();

    wx.showModal({
      title: '恭喜中奖',
      content: `您获得了：${prize.name}`,
      showCancel: false,
      success: () => {
        // 停止跳动动画
        if (this.prizeAnimationFrameId) {
          this.canvas.cancelAnimationFrame(this.prizeAnimationFrameId);
          this.prizeAnimationFrameId = null;
        }
        // 重新绘制转盘，停止跳动
        this.drawWheel(this.data.spinningAngle);
        // 恢复闲置动画
        this.startIdleAnimation();
      },
    });
  },

  startPrizeBounceAnimation() {
    const animate = () => {
      this.drawWheel(this.data.spinningAngle);
      this.prizeAnimationFrameId = this.canvas.requestAnimationFrame(animate);
    };
    this.prizeAnimationFrameId = this.canvas.requestAnimationFrame(animate);
  },


  animatePrize() {
    const animate = () => {
      if (this.data.isSpinning) return;
      this.drawWheel(this.data.spinningAngle);
      this.prizeAnimationFrameId = this.canvas.requestAnimationFrame(animate);
    };
    this.prizeAnimationFrameId = this.canvas.requestAnimationFrame(animate);
  },
});
lottery.wxml代码如下:
<!-- lottery.wxml -->
<view class="container">
  <canvas type="2d" id="wheelCanvas" style="width: 500rpx; height: 500rpx;"></canvas>
  <button bindtap="onClick" class="draw-button">点击抽奖</button>
</view>
lottery.wxss代码如下:
/* lottery.wxss */
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
}
.draw-button {
  margin-top: 20px;
  width: 200rpx;
  height: 80rpx;
  background-color: #f39c12;
  color: white;
  text-align: center;
  line-height: 80rpx;
  border-radius: 10px;
}